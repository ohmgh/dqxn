---
phase: 03-sdk-observability-analytics-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - android/sdk/observability/build.gradle.kts
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/LogLevel.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/LogTag.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/LogTags.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/LogEntry.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/LogSink.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/SafeLogSink.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/RingBufferSink.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/LogcatSink.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/JsonLinesLogSink.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/RedactingSink.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/SamplingLogSink.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/DqxnLogger.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/DqxnLoggerImpl.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/trace/TraceContext.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/trace/DqxnTracer.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/ErrorContext.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/CrashReporter.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/ErrorReporter.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/DeduplicatingErrorReporter.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/CrashEvidenceWriter.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/WidgetErrorContext.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/metrics/LongArrayRingBuffer.kt
  - android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/log/DqxnLoggerTest.kt
  - android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/log/JsonLinesLogSinkTest.kt
  - android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/log/RingBufferSinkTest.kt
  - android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/log/SamplingLogSinkTest.kt
  - android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/crash/CrashEvidenceWriterTest.kt
  - android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/crash/DeduplicatingErrorReporterTest.kt
  - android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/metrics/LongArrayRingBufferTest.kt
autonomous: true
requirements:
  - F12.1
  - F13.7
  - NF36

must_haves:
  truths:
    - "DqxnLogger disabled path produces zero allocations (no lambda, no string concat, no ImmutableMap creation)"
    - "JsonLinesLogSink writes structured JSON-lines to a rotated file (10MB max, 3 files)"
    - "CrashEvidenceWriter persists crash data synchronously via SharedPreferences.commit() in UncaughtExceptionHandler"
    - "LongArrayRingBuffer stores primitive longs without boxing using modular arithmetic wrap-around"
    - "All LogSink writes are wrapped in try/catch — observability never crashes the app"
  artifacts:
    - path: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/DqxnLogger.kt"
      provides: "Logger interface with isEnabled() guard + inline extension functions"
      contains: "inline fun DqxnLogger"
    - path: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/DqxnLoggerImpl.kt"
      provides: "Concrete logger dispatching to sinks with session ID and trace correlation"
      contains: "class DqxnLoggerImpl"
    - path: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/JsonLinesLogSink.kt"
      provides: "Machine-readable JSON-lines file log sink with rotation (F13.7)"
      contains: "class JsonLinesLogSink"
    - path: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/CrashEvidenceWriter.kt"
      provides: "Sync crash persistence for safe mode and diagnose-crash"
      contains: "class CrashEvidenceWriter"
    - path: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/CrashReporter.kt"
      provides: "Interface for crash reporting (Firebase Crashlytics contract)"
      contains: "interface CrashReporter"
    - path: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/ErrorReporter.kt"
      provides: "Interface for non-fatal error reporting with ErrorContext"
      contains: "interface ErrorReporter"
    - path: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/metrics/LongArrayRingBuffer.kt"
      provides: "Lock-free primitive ring buffer for high-frequency metrics"
      contains: "class LongArrayRingBuffer"
  key_links:
    - from: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/DqxnLoggerImpl.kt"
      to: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/LogSink.kt"
      via: "DqxnLoggerImpl dispatches LogEntry to each LogSink"
      pattern: "sinks\\.forEach"
    - from: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/SafeLogSink.kt"
      to: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/LogSink.kt"
      via: "SafeLogSink wraps any LogSink with try/catch"
      pattern: "try.*delegate\\.write"
    - from: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/CrashEvidenceWriter.kt"
      to: "SharedPreferences"
      via: "Synchronous commit() in uncaughtException handler"
      pattern: "commit\\(\\)"
---

<objective>
Build the observability foundation layer: logging primitives, log sinks, tracing, crash reporting interfaces, CrashEvidenceWriter, and LongArrayRingBuffer.

Purpose: This is the bottom layer of the observability stack. Every module in the project depends on `:sdk:observability` for `DqxnLogger`. The logging system must be zero-allocation on disabled paths (<5ns), self-protecting (sinks wrapped in try/catch), and machine-readable (JsonLinesLogSink for F13.7). The crash layer provides interfaces that `:core:firebase` implements in Phase 5, plus sync crash evidence persistence for safe mode recovery.

Output: Compilable `:sdk:observability` module with logging, tracing, crash interfaces, and the LongArrayRingBuffer primitive. All unit tests passing.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-sdk-observability-analytics-ui/03-RESEARCH.md
@.planning/arch/observability.md
@.planning/migration/phase-03.md
@.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Observability build config + logging primitives + all log sinks</name>
  <files>
    android/sdk/observability/build.gradle.kts
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/LogLevel.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/LogTag.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/LogTags.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/LogEntry.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/LogSink.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/SafeLogSink.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/RingBufferSink.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/LogcatSink.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/JsonLinesLogSink.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/RedactingSink.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/SamplingLogSink.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/DqxnLogger.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/DqxnLoggerImpl.kt
  </files>
  <action>
    **Build config:** Update `build.gradle.kts` to add dependencies:
    - `implementation(project(":sdk:contracts"))` — for `WidgetRegistry`, `DataProviderRegistry` interfaces (used by MetricsCollector in Plan 02, but contracts module is a Phase 2 deliverable available by then)
    - `implementation(project(":sdk:common"))` — for `@ApplicationScope`, dispatcher qualifiers
    - `implementation(libs.kotlinx.collections.immutable)` — for `ImmutableMap` in `LogEntry`
    - `implementation(libs.kotlinx.coroutines.core)` — for `AtomicLong`, coroutine context
    - `implementation(libs.kotlinx.coroutines.android)` — for `Dispatchers.IO` in async file writes
    - `implementation(libs.kotlinx.serialization.json)` — for JSON serialization in `JsonLinesLogSink`
    - Do NOT add Compose dependencies — `:sdk:observability` has no Compose compiler

    **LogLevel.kt:** Enum with `VERBOSE`, `DEBUG`, `INFO`, `WARN`, `ERROR`. Ordinal comparison for level filtering.

    **LogTag.kt:** `@JvmInline value class LogTag(val value: String)`. No registration — packs define their own tags freely.

    **LogTags.kt:** Object with standard tags: `DASHBOARD`, `WIDGET`, `PROVIDER`, `THEME`, `LAYOUT`, `BINDING`, `LIFECYCLE`, `AGENTIC`, `DIAGNOSTIC`, `THERMAL`, `ANALYTICS`, `SETUP`, `PROFILE`, `NOTIFICATION`.

    **LogEntry.kt:** `@Immutable` data class with: `timestamp: Long` (elapsedRealtimeNanos), `level: LogLevel`, `tag: LogTag`, `message: String`, `throwable: Throwable? = null`, `traceId: String? = null`, `spanId: String? = null`, `fields: ImmutableMap<String, Any> = persistentMapOf()`, `sessionId: String`. Use `@Immutable` from compose.runtime (available transitively via `:sdk:contracts` → `compileOnly(compose.runtime)`). If annotation not available without Compose compiler, use `@Stable` or omit — do NOT add Compose compiler to this module.

    **LogSink.kt:** Interface with `fun write(entry: LogEntry)`.

    **SafeLogSink.kt:** Decorator wrapping any `LogSink` in try/catch. `try { delegate.write(entry) } catch (_: Exception) { }`. Every sink in the pipeline should be wrapped.

    **RingBufferSink.kt:** Lock-free ring buffer for `LogEntry` objects using `AtomicReferenceArray<LogEntry?>`. Capacity constructor parameter. `toList()` returns ordered entries. NOT the same as `LongArrayRingBuffer` (this stores objects, not primitives).

    **LogcatSink.kt:** Routes to `android.util.Log` using appropriate level methods. Debug builds only — constructor takes `isDebugBuild: Boolean`, returns early if false.

    **JsonLinesLogSink.kt (F13.7):** Writes one JSON object per line using kotlinx.serialization. Rotation: when file exceeds 10MB, rotate (rename current → .1, .1 → .2, delete .3 if exists — max 3 files). Debug builds only — constructor takes `isDebugBuild: Boolean`. Write to `context.filesDir / "logs" / "dqxn.jsonl"`. Atomic write: append mode, flush after each entry. Serialization: `timestamp`, `level`, `tag`, `message`, `traceId`, `spanId`, `fields`, `sessionId`. Do NOT serialize `throwable` object — serialize `throwable?.stackTraceToString()` as a string field `stackTrace`.

    **RedactingSink.kt:** Decorator that scrubs GPS coordinates (regex for lat/lon patterns) and BLE MAC addresses (regex for XX:XX:XX:XX:XX:XX) from `LogEntry.message` and string values in `LogEntry.fields` before delegating.

    **SamplingLogSink.kt:** Per-tag rate limiting. Constructor takes `rateLimitPerSecond: Map<LogTag, Int>` with default unlimited. Uses `ConcurrentHashMap<String, AtomicLong>` tracking last-allowed timestamp per tag. Drops entries exceeding rate.

    **DqxnLogger.kt:** Interface with:
    - `fun isEnabled(level: LogLevel, tag: LogTag): Boolean`
    - `fun log(level: LogLevel, tag: LogTag, message: String, throwable: Throwable? = null, fields: ImmutableMap<String, Any> = persistentMapOf())`
    - Inline extension functions: `debug(tag, message)`, `info(tag, message)`, `warn(tag, message)`, `error(tag, message)`, `error(tag, throwable, message)`. Each checks `isEnabled()` before evaluating lambda — this is the zero-allocation mechanism.
    - Additional overloads with `fields: () -> ImmutableMap<String, Any>` parameter.
    - A `NoOpLogger` object implementing `DqxnLogger` that always returns false from `isEnabled()`.

    **DqxnLoggerImpl.kt:** Concrete implementation. Constructor: `sinks: List<LogSink>`, `minimumLevel: LogLevel = LogLevel.DEBUG`, `sessionId: String`. `isEnabled()` is a simple `level.ordinal >= minimumLevel.ordinal` — fast path, no map lookup, no allocation. `log()` creates a `LogEntry` and dispatches to each sink with inline try/catch (defense in depth beyond SafeLogSink). For `traceId`/`spanId`, accept them as optional parameters in `log()`. The inline extensions in `DqxnLogger.kt` can pass null for non-coroutine contexts. A separate set of `suspend inline fun` overloads reads `currentCoroutineContext()[TraceContext]` for coroutine-aware call sites.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :sdk:observability:compileDebugKotlin --console=plain 2>&1 | tail -5</automated>
    <manual>Verify no Compose compiler applied to this module, verify LogEntry uses ImmutableMap</manual>
  </verify>
  <done>Build config with all dependencies, logging primitives (LogLevel, LogTag, LogTags, LogEntry, LogSink), all 6 sinks (SafeLogSink, RingBufferSink, LogcatSink, JsonLinesLogSink, RedactingSink, SamplingLogSink), DqxnLogger interface with inline zero-allocation extensions, and DqxnLoggerImpl compile successfully. No Compose compiler on this module.</done>
</task>

<task type="auto">
  <name>Task 2: Tracing + crash reporting + metrics primitives</name>
  <files>
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/trace/TraceContext.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/trace/DqxnTracer.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/ErrorContext.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/WidgetErrorContext.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/CrashReporter.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/ErrorReporter.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/DeduplicatingErrorReporter.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/CrashEvidenceWriter.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/metrics/LongArrayRingBuffer.kt
  </files>
  <action>
    Depends on Task 1 compilation succeeding — these types reference `DqxnLogger`, `LogTag`, and `TraceContext` from the logging layer.

    **TraceContext.kt:** `CoroutineContext.Element` with `traceId: String` and `spanId: String`. Companion `Key`. Factory `fun newTrace(agenticTraceId: String? = null): TraceContext` generating UUID-based IDs.

    **DqxnTracer.kt:** `suspend fun <T> withSpan(name: String, block: suspend CoroutineScope.() -> T): T` that creates a child `TraceContext` in the coroutine context. Tracks active spans in a `ConcurrentHashMap` for diagnostics. `fun activeSpans(): List<SpanInfo>` returns current active spans.

    **ErrorContext.kt (F12.1):** Sealed hierarchy:
    - `Coordinator(val command: String)`
    - `Widget(val typeId: String, val widgetId: String)`
    - `Provider(val sourceId: String)`
    - `System(val component: String)`

    **WidgetErrorContext.kt:** Extends `ErrorContext.Widget` (or is a data class holding `ErrorContext.Widget` + extras): `crashCount: Int`, `stackTraceSummary: String`, `lastCrashTimestamp: Long`.

    **CrashReporter.kt (F12.1):** Interface: `fun log(message: String)`, `fun logException(e: Throwable)`, `fun setKey(key: String, value: String)`, `fun setUserId(id: String)`. Implementation in `:core:firebase` Phase 5. Include `NoOpCrashReporter` object.

    **ErrorReporter.kt (F12.1):** Interface: `fun reportNonFatal(e: Throwable, context: ErrorContext)`, `fun reportWidgetCrash(typeId: String, widgetId: String, context: WidgetErrorContext)`. Include `NoOpErrorReporter` object.

    **DeduplicatingErrorReporter.kt:** Decorator around `ErrorReporter`. Uses `ConcurrentHashMap<String, Long>` keyed by `"${e::class.simpleName}:${context}"` with cooldown period (default 60s). Drops duplicate reports within cooldown. Prevents report flooding (NF36).

    **CrashEvidenceWriter.kt:** Implements `Thread.UncaughtExceptionHandler`. Constructor takes `SharedPreferences` and stores reference to default handler via `Thread.getDefaultUncaughtExceptionHandler()`. In `uncaughtException(t, e)`:
    1. Wrap entire body in try/catch (must never interfere)
    2. `prefs.edit().putString("last_crash_type_id", extractWidgetTypeId(e)).putString("last_crash_exception", "${e::class.simpleName}: ${e.message}").putString("last_crash_stack_top5", e.stackTrace.take(5).joinToString("\n")).putLong("last_crash_timestamp", System.currentTimeMillis()).commit()` — MUST be `commit()`, NOT `apply()`
    3. In finally block: `delegate?.uncaughtException(t, e)`
    `extractWidgetTypeId()`: Walk exception cause chain looking for widget context pattern in message. Return `String?`.
    Also provide `fun readLastCrash(): CrashEvidence?` for safe mode recovery.
    `CrashEvidence` data class: `typeId: String?`, `exception: String`, `stackTop5: String`, `timestamp: Long`.

    **LongArrayRingBuffer.kt:** Lock-free primitive ring buffer. `LongArray(capacity)` + `AtomicInteger` write index. `fun add(value: Long)`: `buffer[writeIndex.getAndIncrement() % capacity] = value`. `fun toList(): List<Long>`: ordered from oldest to newest. `fun percentile(p: Double): Long`: for P50/P95/P99 calculations. `fun average(): Double`. `fun count(): Int`: min of writeIndex and capacity.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :sdk:observability:compileDebugKotlin --console=plain 2>&1 | tail -5</automated>
    <manual>Verify ErrorContext sealed hierarchy has 4 variants, CrashEvidenceWriter uses commit() not apply()</manual>
  </verify>
  <done>TraceContext, DqxnTracer, ErrorContext hierarchy (F12.1), CrashReporter/ErrorReporter interfaces (F12.1), DeduplicatingErrorReporter, CrashEvidenceWriter, and LongArrayRingBuffer compile successfully on top of Task 1 logging layer.</done>
</task>

<task type="auto">
  <name>Task 3: Logging + crash + ring buffer unit tests</name>
  <files>
    android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/log/DqxnLoggerTest.kt
    android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/log/JsonLinesLogSinkTest.kt
    android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/log/RingBufferSinkTest.kt
    android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/log/SamplingLogSinkTest.kt
    android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/crash/CrashEvidenceWriterTest.kt
    android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/crash/DeduplicatingErrorReporterTest.kt
    android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/metrics/LongArrayRingBufferTest.kt
  </files>
  <action>
    All tests use JUnit5 + Truth. Tests requiring Android APIs (SharedPreferences) use Robolectric. Tests are in `src/test/kotlin/` (unit tests, not androidTest).

    **DqxnLoggerTest.kt:**
    - `disabled path does not invoke sink` — create logger with minimumLevel=ERROR, call `logger.debug(tag) { "message" }`, verify sink never receives entry. This is the zero-allocation test: the lambda body should not execute. Use a counting sink that increments an `AtomicInteger` on write.
    - `enabled path dispatches to all sinks` — create logger with minimumLevel=DEBUG, two mock sinks, call `logger.info(tag) { "msg" }`, verify both sinks receive the entry.
    - `log entry contains correct fields` — verify timestamp > 0, level matches, tag matches, message matches, sessionId matches.
    - `error with throwable captures throwable` — verify LogEntry.throwable is non-null and matches.
    - `NoOpLogger always returns false from isEnabled` — verify `NoOpLogger.isEnabled(LogLevel.ERROR, tag)` returns false.

    **JsonLinesLogSinkTest.kt:**
    - `writes valid JSON lines` — write 3 entries, read file, verify each line parses as valid JSON with expected fields.
    - `rotates at 10MB` — write entries until file exceeds 10MB, verify rotation occurred (check for .1 file).
    - `max 3 files` — force 4 rotations, verify only 3 files exist.
    - `disabled in non-debug builds` — construct with `isDebugBuild=false`, write entry, verify no file created.
    - `throwable serialized as stackTrace string` — write entry with throwable, verify JSON contains `stackTrace` field with string value (not serialized Throwable object).
    Use temp directory for file operations.

    **RingBufferSinkTest.kt:**
    - `stores entries up to capacity` — write capacity+5 entries, verify `toList()` returns exactly capacity entries.
    - `oldest entries evicted first` — write capacity+1 entries, verify first entry is gone.
    - `empty buffer returns empty list` — verify empty buffer.

    **SamplingLogSinkTest.kt:**
    - `unlimited tag passes all entries` — no rate limit configured, all entries pass.
    - `rate limited tag drops excess` — configure 1/sec for tag, write 5 entries rapidly, verify delegate receives exactly 1.
    - `different tags have independent limits` — tag A limited, tag B unlimited, both written.

    **CrashEvidenceWriterTest.kt (Robolectric):**
    - `uncaughtException persists evidence to SharedPreferences` — create writer, call uncaughtException with a test exception, verify prefs contain `last_crash_type_id`, `last_crash_exception`, `last_crash_stack_top5`, `last_crash_timestamp`.
    - `delegates to original handler` — verify the original UncaughtExceptionHandler is called in finally block.
    - `extractWidgetTypeId finds typeId in nested cause chain` — create exception with `cause = RuntimeException("Widget [essentials:clock] crashed")`, verify extraction returns `essentials:clock`.
    - `extractWidgetTypeId returns null for non-widget exception` — verify null for `IllegalStateException("random error")`.
    - `readLastCrash returns CrashEvidence` — write evidence, then read it back, verify round-trip.
    - `uncaughtException handles prefs failure gracefully` — use a prefs mock that throws on commit, verify no exception propagated and delegate still called.

    **DeduplicatingErrorReporterTest.kt:**
    - `first report passes through` — verify delegate receives the report.
    - `duplicate within cooldown dropped` — report same error twice within 60s, verify delegate receives only 1.
    - `duplicate after cooldown passes` — simulate time passage (or use short cooldown), verify second report passes.
    - `different errors not deduplicated` — two different exceptions, both pass.

    **LongArrayRingBufferTest.kt:**
    - `add and retrieve within capacity` — add 5 values to capacity-10 buffer, verify toList returns all 5 in order.
    - `wraps around correctly` — add capacity+3 values, verify toList returns last `capacity` values in order.
    - `percentile calculation` — add known values, verify P50, P95, P99.
    - `average calculation` — add known values, verify average.
    - `empty buffer returns empty list` — verify count=0, toList empty.
    - `single element` — add 1, verify count=1.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :sdk:observability:testDebugUnitTest --console=plain 2>&1 | tail -20</automated>
    <manual>Verify test XML output exists in build/test-results/ confirming JUnit5 actually executed</manual>
  </verify>
  <done>All logging, crash, and ring buffer tests pass. DqxnLogger disabled-path test confirms zero sink invocations. CrashEvidenceWriter persists and reads crash evidence. JsonLinesLogSink produces valid rotated JSON-lines. LongArrayRingBuffer wrap-around and percentile calculations verified. Test XML present in build/test-results/.</done>
</task>

</tasks>

<verification>
1. `./gradlew :sdk:observability:compileDebugKotlin --console=plain` succeeds
2. `./gradlew :sdk:observability:testDebugUnitTest --console=plain` — all tests pass
3. No Compose compiler on `:sdk:observability` (verify build.gradle.kts has no `dqxn.android.compose`)
4. Test XML files exist in `sdk/observability/build/test-results/testDebugUnitTest/`
</verification>

<success_criteria>
- DqxnLogger with inline zero-allocation extensions compiles
- 6+ log sinks (Safe, RingBuffer, Logcat, JsonLines, Redacting, Sampling) compile
- CrashReporter and ErrorReporter interfaces defined
- CrashEvidenceWriter uses sync SharedPreferences.commit()
- LongArrayRingBuffer primitive ring buffer works correctly
- All unit tests pass with JUnit5
</success_criteria>

<output>
After completion, create `.planning/phases/03-sdk-observability-analytics-ui/03-01-SUMMARY.md`
</output>
