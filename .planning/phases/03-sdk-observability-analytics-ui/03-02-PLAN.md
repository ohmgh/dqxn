---
phase: 03-sdk-observability-analytics-ui
plan: 02
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/metrics/MetricsCollector.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/metrics/MetricsSnapshot.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/metrics/JankDetector.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/health/WidgetHealthMonitor.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/health/ProviderStatusProvider.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/health/AnrWatchdog.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/diagnostic/AnomalyTrigger.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/diagnostic/DiagnosticSnapshot.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/diagnostic/DiagnosticSnapshotCapture.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/diagnostic/DiagnosticFileWriter.kt
  - android/sdk/analytics/build.gradle.kts
  - android/sdk/analytics/src/main/kotlin/app/dqxn/android/sdk/analytics/AnalyticsTracker.kt
  - android/sdk/analytics/src/main/kotlin/app/dqxn/android/sdk/analytics/AnalyticsEvent.kt
  - android/sdk/analytics/src/main/kotlin/app/dqxn/android/sdk/analytics/PackAnalytics.kt
  - android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/metrics/MetricsCollectorTest.kt
  - android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/metrics/JankDetectorTest.kt
  - android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/health/AnrWatchdogTest.kt
  - android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/health/WidgetHealthMonitorTest.kt
  - android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/diagnostic/DiagnosticSnapshotCaptureTest.kt
  - android/sdk/analytics/src/test/kotlin/app/dqxn/android/sdk/analytics/AnalyticsTrackerTest.kt
autonomous: true
requirements:
  - F12.1
  - F13.5
  - F13.6
  - NF36

must_haves:
  truths:
    - "MetricsCollector records frame durations into histogram buckets with <25ns overhead"
    - "JankDetector fires DiagnosticSnapshotCapture at exponential thresholds (5, 20, 100 consecutive janky frames)"
    - "DiagnosticSnapshotCapture drops concurrent captures via AtomicBoolean guard"
    - "DiagnosticSnapshotCapture uses three separate rotation pools (crash:20, thermal:10, perf:10)"
    - "AnrWatchdog fires on 2 consecutive misses but not 1, and suppresses under debugger"
    - "WidgetHealthMonitor detects stale data and stalled renders on 10s intervals"
    - "AnalyticsTracker isEnabled() gates all event tracking"
  artifacts:
    - path: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/metrics/MetricsCollector.kt"
      provides: "Frame histogram + per-widget/provider metrics with lock-free recording"
      contains: "class MetricsCollector"
    - path: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/metrics/JankDetector.kt"
      provides: "Consecutive jank frame tracking with exponential capture triggers"
      contains: "class JankDetector"
    - path: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/diagnostic/DiagnosticSnapshotCapture.kt"
      provides: "Anomaly auto-capture with concurrent guard and rotation pools"
      contains: "class DiagnosticSnapshotCapture"
    - path: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/health/AnrWatchdog.kt"
      provides: "Daemon thread ANR detection with 2.5s timeout"
      contains: "class AnrWatchdog"
    - path: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/health/WidgetHealthMonitor.kt"
      provides: "Periodic widget liveness and staleness checks"
      contains: "class WidgetHealthMonitor"
    - path: "android/sdk/analytics/src/main/kotlin/app/dqxn/android/sdk/analytics/AnalyticsTracker.kt"
      provides: "Analytics contract interface (F12.1)"
      contains: "interface AnalyticsTracker"
    - path: "android/sdk/analytics/src/main/kotlin/app/dqxn/android/sdk/analytics/AnalyticsEvent.kt"
      provides: "Sealed hierarchy of analytics events (F12.2, F12.3, F12.6, F12.7)"
      contains: "sealed interface AnalyticsEvent"
  key_links:
    - from: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/metrics/JankDetector.kt"
      to: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/diagnostic/DiagnosticSnapshotCapture.kt"
      via: "JankDetector triggers capture at threshold"
      pattern: "diagnosticCapture\\.capture"
    - from: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/metrics/MetricsCollector.kt"
      to: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/metrics/LongArrayRingBuffer.kt"
      via: "Per-widget draw time stored in ring buffer"
      pattern: "LongArrayRingBuffer"
    - from: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/health/AnrWatchdog.kt"
      to: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/diagnostic/DiagnosticSnapshotCapture.kt"
      via: "ANR detection triggers diagnostic capture"
      pattern: "diagnosticCapture\\.capture"
---

<objective>
Build the metrics, health monitoring, diagnostic capture, and analytics contract layers on top of the observability primitives from Plan 01.

Purpose: MetricsCollector provides the per-widget/provider performance data that feeds debug overlays (F13.6) and structured state dumps (F13.5). JankDetector + DiagnosticSnapshotCapture + AnrWatchdog form the anomaly auto-detection pipeline that underpins NF36 crash-free rate targets. AnalyticsTracker interface (F12.1) provides the contract that `:core:firebase` implements in Phase 5.

Output: Complete `:sdk:observability` module with all planned types. Complete `:sdk:analytics` module with contract interfaces. All unit tests passing.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-sdk-observability-analytics-ui/03-RESEARCH.md
@.planning/phases/03-sdk-observability-analytics-ui/03-01-SUMMARY.md
@.planning/arch/observability.md
@.planning/migration/phase-03.md
@.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: MetricsCollector + JankDetector + diagnostics + AnrWatchdog + WidgetHealthMonitor + analytics contracts</name>
  <files>
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/metrics/MetricsCollector.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/metrics/MetricsSnapshot.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/metrics/JankDetector.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/health/WidgetHealthMonitor.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/health/ProviderStatusProvider.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/health/AnrWatchdog.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/diagnostic/AnomalyTrigger.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/diagnostic/DiagnosticSnapshot.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/diagnostic/DiagnosticSnapshotCapture.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/diagnostic/DiagnosticFileWriter.kt
    android/sdk/analytics/build.gradle.kts
    android/sdk/analytics/src/main/kotlin/app/dqxn/android/sdk/analytics/AnalyticsTracker.kt
    android/sdk/analytics/src/main/kotlin/app/dqxn/android/sdk/analytics/AnalyticsEvent.kt
    android/sdk/analytics/src/main/kotlin/app/dqxn/android/sdk/analytics/PackAnalytics.kt
  </files>
  <action>
    **MetricsCollector.kt:** Constructor takes no registries yet — pre-population from `WidgetRegistry`/`DataProviderRegistry` deferred to Phase 6/7 DI wiring. Uses `getOrPut` at recording sites for late registration.
    - `private val frameHistogram = AtomicLongArray(6)` — buckets: <8ms, <12ms, <16ms, <24ms, <33ms, >33ms
    - `private val totalFrameCount = AtomicLong(0)`
    - `private val widgetDrawTimes = ConcurrentHashMap<String, LongArrayRingBuffer>()` — keyed by typeId, ring buffer capacity 64
    - `private val providerLatencies = ConcurrentHashMap<String, LongArrayRingBuffer>()` — keyed by providerId
    - `private val recompositionCounts = ConcurrentHashMap<String, AtomicLong>()` — keyed by widget typeId
    - `fun recordFrame(durationMs: Long)` — increment histogram bucket + total count
    - `fun recordWidgetDraw(typeId: String, durationNanos: Long)` — `getOrPut` + ring buffer add
    - `fun recordProviderLatency(providerId: String, durationMs: Long)` — `getOrPut` + ring buffer add
    - `fun recordRecomposition(typeId: String)` — `getOrPut` + increment
    - `fun snapshot(): MetricsSnapshot` — read-only copy of all metrics. This provides the data for F13.5 state dumps and F13.6 debug overlays
    - Performance budget: <25ns for `recordFrame()` — just atomic increment + ring buffer write

    **MetricsSnapshot.kt:** `@Immutable` data class with `frameHistogram: ImmutableList<Long>`, `totalFrameCount: Long`, `widgetDrawTimes: ImmutableMap<String, List<Long>>`, `providerLatencies: ImmutableMap<String, List<Long>>`, `recompositionCounts: ImmutableMap<String, Long>`, `captureTimestamp: Long`.

    **JankDetector.kt:** Constructor takes `DiagnosticSnapshotCapture` and `DqxnLogger`. Tracks consecutive janky frame count (>16ms). Threshold triggers: fire capture at 5th, 20th, 100th consecutive janky frames. 4th, 19th, 99th do NOT trigger. `fun onFrameRendered(durationMs: Long)` — if >16ms increment counter, check thresholds, fire capture with `AnomalyTrigger.JankSpike(consecutiveCount)`. If <=16ms, reset counter to 0. Distinct class, NOT folded into MetricsCollector.

    **AnomalyTrigger.kt:** Sealed interface hierarchy:
    - `WidgetCrash(val typeId: String, val widgetId: String, val exception: String)`
    - `AnrDetected(val mainThreadStackTrace: String, val fdCount: Int)`
    - `ThermalEscalation(val fromTier: String, val toTier: String)`
    - `JankSpike(val consecutiveFrames: Int)`
    - `ProviderTimeout(val providerId: String, val timeoutMs: Long)`
    - `EscalatedStaleness(val typeId: String, val staleSeconds: Long)`
    - `BindingStalled(val widgetId: String, val stalledMs: Long)`
    - `DataStoreCorruption(val storeName: String)`

    **DiagnosticSnapshot.kt:** `@Immutable` data class with `id: String` (UUID), `timestamp: Long`, `trigger: AnomalyTrigger`, `agenticTraceId: String? = null`, `metricsSnapshot: MetricsSnapshot? = null`, `activeSpans: ImmutableList<String> = persistentListOf()`, `logTail: ImmutableList<String> = persistentListOf()`.

    **DiagnosticSnapshotCapture.kt:** Constructor takes `DqxnLogger`, `metricsCollector: MetricsCollector`, `tracer: DqxnTracer`, `logRingBuffer: RingBufferSink`, `fileWriter: DiagnosticFileWriter`.
    - `private val capturing = AtomicBoolean(false)` — concurrent capture guard
    - `fun capture(trigger: AnomalyTrigger, agenticTraceId: String? = null): DiagnosticSnapshot?` — if `!capturing.compareAndSet(false, true)`, log warning and return null. Otherwise assemble snapshot from metrics, active spans, log tail. Write to file via `fileWriter`. Return snapshot. Reset in finally block.
    - Three separate rotation pools managed by `DiagnosticFileWriter`: crash (20 files), thermal (10 files), perf (10 files). Pool assignment based on trigger type.
    - `fun recentSnapshots(pool: String? = null): List<DiagnosticSnapshot>` — read from file writer

    **DiagnosticFileWriter.kt:** Constructor takes `File` (base directory) and `DqxnLogger`.
    - Three pools: `crash/` (max 20), `thermal/` (max 10), `perf/` (max 10)
    - `fun write(snapshot: DiagnosticSnapshot, pool: String)` — serialize to JSON, write to pool directory, evict oldest if at capacity
    - `fun read(pool: String): List<DiagnosticSnapshot>` — deserialize all files in pool
    - `fun checkStoragePressure(): Boolean` — `StatFs` check, return true if <10MB free (skip capture)
    - File naming: `{pool}_{timestamp}_{id}.json`

    **AnrWatchdog.kt:** Daemon thread implementation.
    - Constructor takes `DiagnosticSnapshotCapture`, `DqxnLogger`, `timeoutMs: Long = 2500`
    - Daemon thread posts `CountDownLatch(1).countDown()` to main handler, then `latch.await(timeoutMs)`. If timeout → miss. 2 consecutive misses → capture with `AnomalyTrigger.AnrDetected`. 1 miss → no capture.
    - `Thread.getAllStackTraces()` for stack dump. Count `/proc/self/fd` files for fdCount.
    - `Debug.isDebuggerConnected()` guard: if debugger attached, reset miss counter and sleep instead of counting.
    - `writeAnrFile()` via direct `FileOutputStream` — no `Dispatchers.IO`. Process may die before coroutine dispatches.
    - `fun start()` / `fun stop()` lifecycle methods. Thread is daemon (won't prevent JVM shutdown).
    - `fun query(): AnrInfo?` — lock-free read of last ANR info for agentic `/anr` path.

    **WidgetHealthMonitor.kt:** Constructor takes `DqxnLogger`, `scope: CoroutineScope`.
    - `private val widgetStatuses = ConcurrentHashMap<String, WidgetHealthStatus>()`
    - `data class WidgetHealthStatus(val widgetId: String, val typeId: String, val lastDataTimestamp: Long, val lastDrawTimestamp: Long, val status: Status)`
    - `enum class Status { ACTIVE, STALE_DATA, STALLED_RENDER, CRASHED, SETUP_REQUIRED }`
    - `fun reportData(widgetId: String, typeId: String)` — update lastDataTimestamp
    - `fun reportDraw(widgetId: String, typeId: String)` — update lastDrawTimestamp
    - `fun reportCrash(widgetId: String, typeId: String)` — set status CRASHED
    - `fun allStatuses(): Map<String, WidgetHealthStatus>` — for state dumps (F13.5)
    - Internal: `scope.launch { while(true) { delay(10_000); checkLiveness() } }` on `Dispatchers.Default`. `checkLiveness()`: for each widget, if `now - lastDataTimestamp > stalenessThreshold` → STALE_DATA. If `now - lastDrawTimestamp > 2 * targetFrameInterval` → STALLED_RENDER.
    - Staleness thresholds per data type will be configurable later; for now use 10s default.

    **ProviderStatusProvider.kt:** Interface:
    - `fun providerStatuses(): Flow<Map<String, ProviderStatus>>`
    - `data class ProviderStatus(val providerId: String, val displayName: String, val isConnected: Boolean, val lastUpdateTimestamp: Long, val errorDescription: String? = null)`
    - Implementation deferred to `WidgetBindingCoordinator` in Phase 7. Consumed by `:feature:diagnostics` without cross-feature dependency.

    **Analytics module:**

    **build.gradle.kts (`:sdk:analytics`):** Update to add:
    - `implementation(libs.kotlinx.collections.immutable)` — for `ImmutableMap` in event params
    - Do NOT add dependency on `:sdk:observability` — analytics contracts are independent. Callers populate metrics fields.

    **AnalyticsTracker.kt:** Interface with:
    - `fun isEnabled(): Boolean`
    - `fun setEnabled(enabled: Boolean)`
    - `fun track(event: AnalyticsEvent)`
    - `fun setUserProperty(key: String, value: String)`
    - `NoOpAnalyticsTracker` object: `isEnabled()` returns false, all methods are no-ops.

    **AnalyticsEvent.kt:** Sealed interface hierarchy with `name: String` and `params: ImmutableMap<String, Any>` (default `persistentMapOf()`). Events:
    - Funnel (F12.2): `AppLaunch`, `OnboardingComplete`, `FirstWidgetAdded`, `FirstCustomization(source: String)`
    - Widget: `WidgetAdded(typeId: String)`, `WidgetRemoved(typeId: String)`, `WidgetSettingsChanged(typeId: String, setting: String)`
    - Theme: `ThemeChanged(themeId: String, isDark: Boolean)`, `ThemePreviewStarted(themeId: String)`, `ThemePreviewCommitted(themeId: String)`, `ThemePreviewReverted(themeId: String)`
    - Upsell (F12.6): `UpsellImpression(trigger: String, packId: String)`, `UpsellConversion(trigger: String, packId: String)`
    - Engagement (F12.3): `SessionStart`, `SessionEnd(durationMs: Long, widgetCount: Int, editCount: Int, jankPercent: Float, peakThermalLevel: String, widgetRenderFailures: Int, providerErrors: Int)` — session quality metrics per F12.7
    - Edit: `EditModeEntered`, `EditModeExited(widgetsAdded: Int, widgetsRemoved: Int, widgetsMoved: Int, widgetsResized: Int)`
    - Profile: `ProfileCreated`, `ProfileSwitched(profileId: String)`, `ProfileDeleted`
    Each event class overrides `name` and `params` with concrete values using `persistentMapOf()`.

    **PackAnalytics.kt:** Interface for scoped per-pack analytics:
    - `fun track(event: AnalyticsEvent)` — prepends pack ID to event params
    - Constructor-injected `packId: String` and `delegate: AnalyticsTracker`
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :sdk:observability:compileDebugKotlin :sdk:analytics:compileDebugKotlin --console=plain 2>&1 | tail -5</automated>
    <manual>Verify MetricsCollector uses AtomicLongArray (not synchronized), verify analytics has no observability dependency</manual>
  </verify>
  <done>MetricsCollector, JankDetector, DiagnosticSnapshotCapture, DiagnosticFileWriter, AnrWatchdog, WidgetHealthMonitor, ProviderStatusProvider all compile. AnalyticsTracker, AnalyticsEvent hierarchy, and PackAnalytics compile in :sdk:analytics. No circular dependencies between analytics and observability.</done>
</task>

<task type="auto">
  <name>Task 2: Metrics + health + diagnostics + analytics unit tests</name>
  <files>
    android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/metrics/MetricsCollectorTest.kt
    android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/metrics/JankDetectorTest.kt
    android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/health/AnrWatchdogTest.kt
    android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/health/WidgetHealthMonitorTest.kt
    android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/diagnostic/DiagnosticSnapshotCaptureTest.kt
    android/sdk/analytics/src/test/kotlin/app/dqxn/android/sdk/analytics/AnalyticsTrackerTest.kt
  </files>
  <action>
    All tests JUnit5 + Truth + MockK. Flow tests use Turbine + `StandardTestDispatcher`.

    **MetricsCollectorTest.kt:**
    - `recordFrame buckets correctly` — record frame durations 5ms, 10ms, 15ms, 20ms, 30ms, 50ms. Verify snapshot histogram counts: bucket[0]=1, [1]=1, [2]=1, [3]=1, [4]=1, [5]=1.
    - `recordFrame concurrent writes` — launch 100 coroutines each recording 100 frames, verify totalFrameCount == 10000.
    - `recordWidgetDraw stores in ring buffer` — record 70 draw times for typeId "essentials:clock", verify snapshot widgetDrawTimes has 64 entries (ring buffer capacity).
    - `recordProviderLatency late registration` — record latency for unknown provider (not pre-populated), verify it creates entry via getOrPut.
    - `snapshot returns immutable copy` — take snapshot, record more frames, verify snapshot values unchanged.
    - `recordRecomposition increments counter` — record 5 recompositions, verify count is 5.

    **JankDetectorTest.kt:**
    - `non-janky frame resets counter` — 4 janky frames then 1 non-janky, verify no capture triggered.
    - `5th consecutive janky frame triggers capture` — 5 frames at 20ms each, verify capture called once with `JankSpike(5)`.
    - `4th consecutive janky frame does NOT trigger` — 4 frames at 20ms, verify capture NOT called.
    - `20th consecutive janky frame triggers capture` — 20 frames, verify capture called at frame 5 and frame 20 (2 calls total).
    - `100th consecutive janky frame triggers capture` — 100 frames, verify 3 captures total (at 5, 20, 100).
    - `99th consecutive janky frame does NOT trigger third capture` — 99 frames, verify only 2 captures (at 5, 20).
    Use MockK to mock `DiagnosticSnapshotCapture` and verify `capture()` calls.

    **DiagnosticSnapshotCaptureTest.kt:**
    - `capture assembles snapshot from metrics and log tail` — provide mock metrics + tracer + log ring, verify snapshot contains non-null metricsSnapshot and logTail entries.
    - `concurrent capture dropped` — use `AtomicBoolean` trick: first capture blocks (via CountDownLatch), second capture returns null. Verify warning logged.
    - `rotation pool assignment` — capture with `WidgetCrash` trigger, verify file written to crash pool. Capture with `ThermalEscalation`, verify thermal pool. Capture with `JankSpike`, verify perf pool.
    - `rotation eviction respects pool limits` — write 22 crash snapshots, verify only 20 files in crash directory (oldest 2 evicted).
    - `storage pressure skips capture` — mock `DiagnosticFileWriter.checkStoragePressure()` returning true, verify capture returns null.

    **AnrWatchdogTest.kt:**
    - Testing the ANR watchdog daemon thread is inherently timing-sensitive. Use a short timeout (100ms) for tests.
    - `single miss does not trigger capture` — simulate 1 missed latch, verify no capture.
    - `two consecutive misses trigger capture` — simulate 2 missed latches (block main thread handler in test), verify `AnomalyTrigger.AnrDetected` capture.
    - `debugger attached suppresses detection` — mock `Debug.isDebuggerConnected()` returning true (Robolectric shadow), verify no capture even after multiple misses.
    - `query returns last ANR info` — trigger ANR, call query(), verify non-null result.
    - Note: These tests may need Robolectric for Handler and Debug shadowing. Use `@Config(shadows = [ShadowDebug::class])` if needed. If timing is too fragile, use a `TestAnrWatchdog` subclass with injectable clock/latch.

    **WidgetHealthMonitorTest.kt:**
    - Uses `StandardTestDispatcher` + `TestScope`.
    - `reportData updates lastDataTimestamp` — report data, verify status is ACTIVE.
    - `stale data detected after threshold` — report data, advance time by 11s (past 10s default threshold), trigger check, verify status is STALE_DATA.
    - `reportDraw resets stalled render` — report draw, verify not STALLED_RENDER.
    - `stalled render detected` — report draw, advance time, trigger check, verify STALLED_RENDER.
    - `reportCrash sets CRASHED status` — verify status immediately changes.
    - `allStatuses returns all tracked widgets` — register 3 widgets, verify map has 3 entries.

    **AnalyticsTrackerTest.kt (MockK):**
    - `isEnabled gates track calls` — create mock implementing AnalyticsTracker, verify that when `isEnabled()` returns false, `track()` should still be callable (contract test — the gating is caller responsibility, not interface enforcement). Actually, test the NoOpAnalyticsTracker: verify `isEnabled()` returns false and `track()` doesn't throw.
    - `AnalyticsEvent.WidgetAdded has correct name and params` — verify `name == "widget_added"`, `params["type_id"] == "essentials:clock"`.
    - `AnalyticsEvent.SessionEnd includes session quality metrics` — verify `params` contains `jank_percent`, `peak_thermal_level`, `widget_render_failures`, `provider_errors` fields (F12.7).
    - `AnalyticsEvent.UpsellImpression includes trigger_source` — verify `params["trigger_source"]` present (F12.6).
    - `PackAnalytics prepends packId to event params` — create PackAnalytics with packId="essentials", track event, verify delegate receives event with `pack_id` param added.
    - `all event subclasses have non-empty name` — iterate through representative events, verify `name.isNotEmpty()`.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :sdk:observability:testDebugUnitTest :sdk:analytics:testDebugUnitTest --console=plain 2>&1 | tail -20</automated>
    <manual>Verify JankDetector exponential thresholds (5, 20, 100) tested explicitly. Verify test XML in both modules.</manual>
  </verify>
  <done>All metrics, health, diagnostics, and analytics tests pass. MetricsCollector concurrent write correctness verified. JankDetector exponential thresholds confirmed (5, 20, 100 fire; 4, 19, 99 do not). DiagnosticSnapshotCapture concurrent guard and rotation pool eviction verified. AnrWatchdog 2-miss trigger confirmed. WidgetHealthMonitor staleness detection verified. AnalyticsEvent structure and PackAnalytics delegation confirmed. Test XML present in both modules.</done>
</task>

</tasks>

<verification>
1. `./gradlew :sdk:observability:compileDebugKotlin :sdk:analytics:compileDebugKotlin --console=plain` succeeds
2. `./gradlew :sdk:observability:testDebugUnitTest :sdk:analytics:testDebugUnitTest --console=plain` — all tests pass
3. No dependency from `:sdk:analytics` to `:sdk:observability`
4. Test XML files exist in both modules' `build/test-results/testDebugUnitTest/`
5. MetricsCollector uses `AtomicLongArray` and `ConcurrentHashMap` (no `synchronized`)
6. DiagnosticSnapshotCapture has three separate pools
</verification>

<success_criteria>
- MetricsCollector records frames with <25ns overhead (lock-free atomics only)
- JankDetector fires captures exactly at thresholds 5, 20, 100
- DiagnosticSnapshotCapture guards concurrent captures, manages 3 rotation pools
- AnrWatchdog detects ANR on 2+ consecutive misses with debugger guard
- WidgetHealthMonitor detects stale data and stalled renders
- AnalyticsTracker + AnalyticsEvent + PackAnalytics contracts defined
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-sdk-observability-analytics-ui/03-02-SUMMARY.md`
</output>
