---
phase: 09-themes-demo-chaos
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/ChaosProviderInterceptor.kt
  - android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/ChaosProfile.kt
  - android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/ChaosSession.kt
  - android/app/src/main/kotlin/app/dqxn/android/StubEntitlementManager.kt
  - android/core/agentic/src/test/kotlin/app/dqxn/android/core/agentic/chaos/ChaosProviderInterceptorTest.kt
  - android/app/src/test/kotlin/app/dqxn/android/StubEntitlementManagerTest.kt
autonomous: true
requirements: [F8.5]

must_haves:
  truths:
    - "ChaosProviderInterceptor intercepts provider flows and applies ProviderFault transformations"
    - "StubEntitlementManager supports simulateRevocation and simulateGrant with flow emission"
    - "Injected faults can be cleared per-provider or globally"
    - "Interceptor returns upstream unchanged when no fault is active for a provider"
  artifacts:
    - path: "android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/ChaosProviderInterceptor.kt"
      provides: "DataProviderInterceptor implementation for chaos testing"
      contains: "DataProviderInterceptor"
    - path: "android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/ChaosProfile.kt"
      provides: "7 chaos profile definitions"
      contains: "ChaosProfile"
    - path: "android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/ChaosSession.kt"
      provides: "Session state tracking with injection log"
      contains: "ChaosSession"
    - path: "android/app/src/main/kotlin/app/dqxn/android/StubEntitlementManager.kt"
      provides: "Extended StubEntitlementManager with simulateRevocation/simulateGrant"
      contains: "simulateRevocation"
  key_links:
    - from: "ChaosProviderInterceptor"
      to: "DataProviderInterceptor"
      via: "implements interface"
      pattern: "DataProviderInterceptor"
    - from: "ChaosProviderInterceptor"
      to: "ProviderFault"
      via: "applies fault transformations"
      pattern: "ProviderFault"
    - from: "StubEntitlementManager"
      to: "entitlementChanges"
      via: "MutableStateFlow emission on mutation"
      pattern: "MutableStateFlow"
---

<objective>
Create ChaosProviderInterceptor, chaos profiles, session tracking, and extend StubEntitlementManager with programmatic entitlement simulation.

Purpose: Delivers the core chaos infrastructure (ChaosProviderInterceptor) and F8.5 (debug "Simulate Free User" toggle via simulateRevocation/simulateGrant). ChaosEngine and agentic handlers build on these in Plan 05.

Output: ChaosProviderInterceptor, ChaosProfile (7 profiles), ChaosSession, extended StubEntitlementManager, tests for all.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-themes-demo-chaos/09-RESEARCH.md
@android/sdk/contracts/src/main/kotlin/app/dqxn/android/sdk/contracts/provider/DataProviderInterceptor.kt
@android/sdk/contracts/src/main/kotlin/app/dqxn/android/sdk/contracts/fault/ProviderFault.kt
@android/app/src/main/kotlin/app/dqxn/android/StubEntitlementManager.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: ChaosProviderInterceptor + ChaosProfile + ChaosSession</name>
  <files>
    android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/ChaosProviderInterceptor.kt
    android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/ChaosProfile.kt
    android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/ChaosSession.kt
    android/core/agentic/src/test/kotlin/app/dqxn/android/core/agentic/chaos/ChaosProviderInterceptorTest.kt
  </files>
  <action>
    **1. Create ChaosProviderInterceptor.kt** in `android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/`:
    ```kotlin
    @Singleton
    public class ChaosProviderInterceptor @Inject constructor() : DataProviderInterceptor {
      private val activeFaults = ConcurrentHashMap<String, ProviderFault>()

      public fun injectFault(providerId: String, fault: ProviderFault) {
        activeFaults[providerId] = fault
      }
      public fun clearFault(providerId: String) { activeFaults.remove(providerId) }
      public fun clearAll() { activeFaults.clear() }
      public fun getActiveFaults(): Map<String, ProviderFault> = activeFaults.toMap()

      override fun <T : DataSnapshot> intercept(
        provider: DataProvider<T>,
        upstream: Flow<T>,
      ): Flow<T> {
        val fault = activeFaults[provider.sourceId] ?: return upstream
        return applyFault(upstream, fault)
      }
    }
    ```

    The `applyFault()` function uses `transformLatest` per the `ProviderFault` sealed hierarchy:
    - `Kill` → emit nothing (flow completes)
    - `Delay(delayMs)` → `delay(delayMs)` before each emission
    - `Error(exception)` → throw the exception
    - `ErrorOnNext(exception)` → throw on first emission, then pass through
    - `Corrupt(transform)` → apply transform to each emission (`@Suppress("UNCHECKED_CAST")` for the DataSnapshot → T cast)
    - `Flap(onMillis, offMillis)` → alternating on/off windows: emit during `onMillis`, drop during `offMillis`
    - `Stall` → `awaitCancellation()` (never emits)

    **2. Create ChaosProfile.kt:**
    Sealed interface with 7 concrete profiles. Each profile defines:
    - `name: String` (matches `chaos-start` param)
    - `fun generatePlan(random: Random, providerIds: List<String>): List<ScheduledFault>`
    - `ScheduledFault(delayMs: Long, providerId: String, fault: ProviderFault, description: String)`

    Profiles:
    - `ProviderStress` — rapid Kill/Error on random providers, 500ms-2s intervals
    - `ProviderFlap` — Flap faults with short on/off windows (1s/1s to 3s/3s)
    - `ThermalRamp` — placeholder (records intent but no actual thermal injection — thermal is separate system)
    - `EntitlementChurn` — placeholder (records intent for entitlement simulation)
    - `WidgetStorm` — rapid Corrupt faults producing extreme values
    - `ProcessDeath` — Kill all providers simultaneously after random delay
    - `Combined` — merges faults from at least 3 other profiles

    Each profile uses the provided `Random(seed)` for deterministic fault selection. `generatePlan()` produces a flat list of `ScheduledFault` sorted by `delayMs`.

    **3. Create ChaosSession.kt:**
    ```kotlin
    public data class ChaosSession(
      val sessionId: String,
      val seed: Long,
      val profile: String,
      val job: Job,
      val startedAtMs: Long = System.currentTimeMillis(),
    ) {
      private val injections = mutableListOf<InjectedFault>()

      public fun recordInjection(fault: ScheduledFault, atMs: Long) {
        injections.add(InjectedFault(fault.providerId, fault.fault.toString(), fault.description, atMs))
      }

      public fun toSummary(): ChaosSessionSummary = ChaosSessionSummary(
        sessionId = sessionId,
        seed = seed,
        profile = profile,
        injectedFaults = injections.toList(),
        durationMs = System.currentTimeMillis() - startedAtMs,
      )
    }

    public data class InjectedFault(
      val providerId: String,
      val faultType: String,
      val description: String,
      val atMs: Long,
    )

    public data class ChaosSessionSummary(
      val sessionId: String,
      val seed: Long,
      val profile: String,
      val injectedFaults: List<InjectedFault>,
      val durationMs: Long,
    )
    ```

    **4. Create ChaosProviderInterceptorTest.kt:**
    Tests using JUnit5 + MockK + Turbine + `StandardTestDispatcher`:
    - `intercept returns upstream unchanged when no fault active`
    - `injectFault Kill terminates flow`
    - `injectFault Delay adds latency to emissions`
    - `injectFault Error throws on first emission`
    - `injectFault ErrorOnNext throws then passes through`
    - `injectFault Stall never emits`
    - `injectFault Flap alternates emission windows`
    - `injectFault Corrupt transforms snapshot data`
    - `clearFault removes fault for specific provider`
    - `clearAll removes all active faults`
    - `getActiveFaults returns current fault map`

    Use a simple fake provider emitting test snapshots with `flow { repeat(10) { emit(snapshot); delay(100) } }`.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :core:agentic:testDebugUnitTest --tests "*.ChaosProviderInterceptorTest" --console=plain 2>&1 | tail -20</automated>
  </verify>
  <done>ChaosProviderInterceptor applies all 7 ProviderFault types correctly. 7 chaos profiles defined. Session tracking records injections. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Extend StubEntitlementManager + tests</name>
  <files>
    android/app/src/main/kotlin/app/dqxn/android/StubEntitlementManager.kt
    android/app/src/test/kotlin/app/dqxn/android/StubEntitlementManagerTest.kt
  </files>
  <action>
    **1. Update StubEntitlementManager.kt** to support programmatic entitlement simulation:

    Current state: `private val activeEntitlements: Set<String> = setOf("free")` (immutable, no mutation support).

    Change to:
    ```kotlin
    public class StubEntitlementManager : EntitlementManager {
      private val _entitlements = MutableStateFlow(setOf("free"))

      override fun hasEntitlement(id: String): Boolean = id in _entitlements.value
      override fun getActiveEntitlements(): Set<String> = _entitlements.value
      override val entitlementChanges: Flow<Set<String>> = _entitlements

      public fun simulateRevocation(id: String) {
        _entitlements.value = _entitlements.value - id
      }

      public fun simulateGrant(id: String) {
        _entitlements.value = _entitlements.value + id
      }

      public fun reset() {
        _entitlements.value = setOf("free")
      }
    }
    ```

    Key points:
    - `_entitlements.value = _entitlements.value - id` creates a new Set (structural change triggers StateFlow emission)
    - `entitlementChanges` is now backed by `_entitlements` MutableStateFlow (was previously a separate `MutableStateFlow(activeEntitlements)` with static reference)
    - `reset()` returns to initial state
    - **Do NOT use `toMutableSet().apply { remove(id) }`** — the minus/plus operators on Set already produce new instances

    **2. Create StubEntitlementManagerTest.kt** (or extend if it exists):

    Tests using JUnit5 + Truth + Turbine:
    - `initial state has free entitlement only`
    - `hasEntitlement returns true for free`
    - `hasEntitlement returns false for themes`
    - `simulateGrant adds entitlement and emits via flow`
    - `simulateRevocation removes entitlement and emits via flow`
    - `simulateRevocation of nonexistent entitlement is no-op`
    - `simulateGrant then simulateRevocation returns to previous state`
    - `entitlementChanges flow emits initial state on collection`
    - `reset returns to free-only state`
    - `multiple sequential grants accumulate correctly`

    Use Turbine for flow assertions:
    ```kotlin
    @Test
    fun `simulateGrant emits updated set`() = runTest {
      val manager = StubEntitlementManager()
      manager.entitlementChanges.test {
        assertThat(awaitItem()).containsExactly("free")
        manager.simulateGrant("themes")
        assertThat(awaitItem()).containsExactly("free", "themes")
      }
    }
    ```
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :app:testDebugUnitTest --tests "*.StubEntitlementManagerTest" --console=plain 2>&1 | tail -20</automated>
  </verify>
  <done>StubEntitlementManager supports simulateRevocation/simulateGrant/reset with proper StateFlow emission. All tests pass including flow emission verification.</done>
</task>

</tasks>

<verification>
```bash
cd /Users/ohm/Workspace/dqxn/android && ./gradlew :core:agentic:testDebugUnitTest --tests "*.ChaosProviderInterceptorTest" :app:testDebugUnitTest --tests "*.StubEntitlementManagerTest" --console=plain
```
All chaos interceptor tests and entitlement manager tests pass.
</verification>

<success_criteria>
- ChaosProviderInterceptor applies all 7 ProviderFault types
- 7 chaos profiles generate deterministic fault plans from seed
- ChaosSession tracks injection history
- StubEntitlementManager.simulateRevocation/simulateGrant emit via entitlementChanges flow
- StubEntitlementManager.reset returns to free-only state
- All tests green
</success_criteria>

<output>
After completion, create `.planning/phases/09-themes-demo-chaos/09-04-SUMMARY.md`
</output>
