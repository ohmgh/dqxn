---
phase: 09-themes-demo-chaos
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - android/app/src/test/kotlin/app/dqxn/android/debug/handlers/ChaosCorrelationTest.kt
autonomous: true
gap_closure: true
requirements: [F13.1]

must_haves:
  truths:
    - "inject-fault followed by capture-snapshot followed by list-diagnostics since= returns the captured snapshot"
    - "list-diagnostics since= filters out snapshots timestamped before the fault injection"
    - "The captured snapshot's agenticTraceId contains the command ID linking it to the capture request"
  artifacts:
    - path: "android/app/src/test/kotlin/app/dqxn/android/debug/handlers/ChaosCorrelationTest.kt"
      provides: "SC3 chaos-to-diagnostics pipeline integration test"
      min_lines: 60
  key_links:
    - from: "ChaosInjectHandler"
      to: "ChaosProviderInterceptor"
      via: "interceptor.injectFault()"
      pattern: "interceptor\\.injectFault"
    - from: "CaptureSnapshotHandler"
      to: "DiagnosticSnapshotCapture"
      via: "diagnosticCapture.capture()"
      pattern: "diagnosticCapture\\.capture"
    - from: "ListDiagnosticsHandler"
      to: "DiagnosticSnapshotCapture"
      via: "diagnosticCapture.recentSnapshots()"
      pattern: "diagnosticCapture\\.recentSnapshots"
---

<objective>
Close SC3 verification gap: prove the agentic debug workflow "inject-fault → capture-snapshot → list-diagnostics since=" produces correlated diagnostic output.

Purpose: ROADMAP SC3 requires a test demonstrating that ChaosProviderInterceptor fault injection, followed by diagnostic capture, produces a snapshot retrievable via list-diagnostics with a since= filter. No automatic coupling exists between these systems — the test validates the manual agentic pipeline that a developer would use via ADB.

Output: One integration test file exercising all three handlers with real collaborators (ChaosProviderInterceptor, DiagnosticSnapshotCapture with temp-dir-backed DiagnosticFileWriter).
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-themes-demo-chaos/09-VERIFICATION.md

# Source files for test subjects
@android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ChaosInjectHandler.kt
@android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/CaptureSnapshotHandler.kt
@android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ListDiagnosticsHandler.kt
@android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/diagnostic/DiagnosticSnapshotCapture.kt
@android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/diagnostic/DiagnosticFileWriter.kt
@android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/diagnostic/AnomalyTrigger.kt
@android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/ChaosProviderInterceptor.kt
@android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/CommandParams.kt

# Test patterns to follow
@android/app/src/test/kotlin/app/dqxn/android/debug/handlers/ChaosInjectHandlerTest.kt
@android/sdk/observability/src/test/kotlin/app/dqxn/android/sdk/observability/diagnostic/DiagnosticSnapshotCaptureTest.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: SC3 chaos-to-diagnostics correlation integration test</name>
  <files>android/app/src/test/kotlin/app/dqxn/android/debug/handlers/ChaosCorrelationTest.kt</files>
  <action>
Create `ChaosCorrelationTest.kt` in the `:app` debug handler test package. This test proves the SC3 agentic pipeline: inject-fault → capture-snapshot → list-diagnostics since= produces correlated output.

**Test setup pattern** (follows existing handler + DiagnosticSnapshotCaptureTest patterns):
- Direct instantiation of all three handlers (no Hilt, no MockK for collaborators)
- Real `ChaosProviderInterceptor()` (no-arg constructor)
- Real `DiagnosticSnapshotCapture` with real `DiagnosticFileWriter` backed by `@TempDir`
- `NoOpLogger` from `app.dqxn.android.sdk.observability.log`
- `MetricsCollector()` (no-arg constructor)
- `DqxnTracer` object
- `RingBufferSink(100)` for log tail
- `CommandParams(raw = mapOf(...), traceId = "...")` for handler invocation
- `@Tag("fast")` on class, JUnit5 `@Test` annotations, `runTest` for suspend handler.execute()

**Test methods:**

1. `inject fault then capture snapshot then list diagnostics since before injection returns snapshot`
   - Record `beforeMs = System.currentTimeMillis()`
   - Call `chaosInjectHandler.execute(params with providerId="test:speed", fault="kill")` and assert `CommandResult.Success`
   - Call `captureSnapshotHandler.execute(params with reason="chaos-correlation")` and assert `CommandResult.Success` with `captured=true`
   - Call `listDiagnosticsHandler.execute(params with since=beforeMs.toString())` and assert `CommandResult.Success`
   - Parse the JSON response: assert `count >= 1`
   - Assert at least one snapshot in the `snapshots` array has `timestamp >= beforeMs`
   - Assert at least one snapshot has `agenticTraceId` containing "chaos-correlation"

2. `list diagnostics since future timestamp returns zero snapshots`
   - Inject a fault and capture a snapshot (same setup as test 1)
   - Call `listDiagnosticsHandler.execute(params with since=(System.currentTimeMillis() + 100000).toString())`
   - Assert `count == 0` and `snapshots` array is empty
   - This proves the since= filter works correctly

3. `multiple fault injections followed by single capture produces one snapshot`
   - Inject faults into 3 different providers via `chaosInjectHandler.execute()` (kill, stall, delay)
   - Capture one snapshot via `captureSnapshotHandler.execute()`
   - List diagnostics since before the injections
   - Assert `count == 1` — multiple faults don't cause multiple snapshots; only explicit capture-snapshot produces a snapshot

**Imports needed:**
- `app.dqxn.android.core.agentic.CommandParams`
- `app.dqxn.android.core.agentic.CommandResult`
- `app.dqxn.android.core.agentic.chaos.ChaosProviderInterceptor`
- `app.dqxn.android.sdk.observability.diagnostic.DiagnosticSnapshotCapture`
- `app.dqxn.android.sdk.observability.diagnostic.DiagnosticFileWriter`
- `app.dqxn.android.sdk.observability.log.NoOpLogger`
- `app.dqxn.android.sdk.observability.log.RingBufferSink`
- `app.dqxn.android.sdk.observability.metrics.MetricsCollector`
- `app.dqxn.android.sdk.observability.trace.DqxnTracer`
- `com.google.common.truth.Truth.assertThat`
- `kotlinx.coroutines.test.runTest`
- `kotlinx.serialization.json.Json`
- `kotlinx.serialization.json.jsonArray`
- `kotlinx.serialization.json.jsonObject`
- `kotlinx.serialization.json.jsonPrimitive`
- `org.junit.jupiter.api.Tag`
- `org.junit.jupiter.api.Test`
- `org.junit.jupiter.api.io.TempDir`
- `java.io.File`

**Key details:**
- All three handlers share the same `ChaosProviderInterceptor` instance and the same `DiagnosticSnapshotCapture` instance (simulating singleton injection in production)
- The `CaptureSnapshotHandler` hardcodes `AnomalyTrigger.JankSpike(consecutiveFrames = 0)` — this is the correct trigger type for agentic-initiated captures (matches existing source)
- DiagnosticFileWriter needs the `NoOpLogger` import from `app.dqxn.android.sdk.observability.log` — the same `NoOpLogger` used by `DiagnosticSnapshotCaptureTest`
- Parse `CommandResult.Success.data` as JSON using `kotlinx.serialization.json.Json.parseToJsonElement()`
- The `since` param is a string (Long serialized) — `ListDiagnosticsHandler` calls `toLongOrNull()` on it
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :app:testDebugUnitTest --tests "*.ChaosCorrelationTest" --console=plain 2>&1 | tail -20</automated>
  </verify>
  <done>Three tests pass proving: (1) inject-fault + capture-snapshot + list-diagnostics since= returns correlated snapshot with matching agenticTraceId, (2) since= filter excludes future-timestamped queries, (3) multiple fault injections produce exactly one snapshot per explicit capture. SC3 verification gap closed.</done>
</task>

</tasks>

<verification>
SC3 gap closure verified by:
1. `./gradlew :app:testDebugUnitTest --tests "*.ChaosCorrelationTest" --console=plain` — all 3 tests pass
2. The test exercises the complete agentic debug pipeline: ChaosInjectHandler → ChaosProviderInterceptor → CaptureSnapshotHandler → DiagnosticSnapshotCapture → DiagnosticFileWriter → ListDiagnosticsHandler → filtered read
3. Real collaborators (no mocks for the pipeline components) — the only non-production piece is the @TempDir backing the DiagnosticFileWriter
</verification>

<success_criteria>
- `ChaosCorrelationTest` exists with 3 test methods
- All 3 tests pass via `./gradlew :app:testDebugUnitTest --tests "*.ChaosCorrelationTest" --console=plain`
- Test proves: fault injection + capture-snapshot + list-diagnostics since= returns snapshot timestamped after fault, with agenticTraceId linking to the capture command
- SC3 from VERIFICATION.md is resolved
</success_criteria>

<output>
After completion, create `.planning/phases/09-themes-demo-chaos/09-07-SUMMARY.md`
</output>
