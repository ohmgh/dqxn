---
phase: 09-themes-demo-chaos
plan: 05
type: execute
wave: 2
depends_on: [09-04]
files_modified:
  - android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/ChaosEngine.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ChaosStartHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ChaosStopHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ChaosInjectHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/DebugModule.kt
  - android/core/agentic/src/test/kotlin/app/dqxn/android/core/agentic/chaos/ChaosEngineTest.kt
  - android/app/src/test/kotlin/app/dqxn/android/debug/handlers/ChaosStartHandlerTest.kt
  - android/app/src/test/kotlin/app/dqxn/android/debug/handlers/ChaosStopHandlerTest.kt
  - android/app/src/test/kotlin/app/dqxn/android/debug/handlers/ChaosInjectHandlerTest.kt
autonomous: true
requirements: [F8.5, F13.1]

must_haves:
  truths:
    - "ChaosEngine starts deterministic fault sessions from seed"
    - "Same seed + same profile produces same fault sequence"
    - "chaos-start handler returns session info with active faults"
    - "chaos-stop handler returns injection summary"
    - "chaos-inject handler injects single fault into specific provider"
    - "ChaosEngine stop cancels session job and clears all faults"
  artifacts:
    - path: "android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/ChaosEngine.kt"
      provides: "Seed-based deterministic fault orchestration"
      contains: "Random(seed)"
    - path: "android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ChaosStartHandler.kt"
      provides: "Agentic handler for starting chaos sessions"
      contains: "@AgenticCommand"
    - path: "android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ChaosStopHandler.kt"
      provides: "Agentic handler for stopping chaos sessions"
      contains: "@AgenticCommand"
    - path: "android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ChaosInjectHandler.kt"
      provides: "Agentic handler for single fault injection"
      contains: "@AgenticCommand"
  key_links:
    - from: "ChaosEngine"
      to: "ChaosProviderInterceptor"
      via: "injectFault calls"
      pattern: "interceptor\\.injectFault"
    - from: "ChaosStartHandler"
      to: "ChaosEngine"
      via: "engine.start()"
      pattern: "engine\\.start"
    - from: "ChaosStopHandler"
      to: "ChaosEngine"
      via: "engine.stop()"
      pattern: "engine\\.stop"
    - from: "ChaosInjectHandler"
      to: "ChaosProviderInterceptor"
      via: "interceptor.injectFault()"
      pattern: "interceptor\\.injectFault"
---

<objective>
Create ChaosEngine for deterministic fault orchestration and 3 agentic command handlers (chaos-start, chaos-stop, chaos-inject). Wire chaos infrastructure into DebugModule.

Purpose: Completes chaos testing infrastructure. ChaosEngine uses seed-based Random for deterministic reproduction (SC4). Handlers enable ADB-driven chaos testing. DebugModule binding ensures chaos stays out of release builds.

Output: ChaosEngine, 3 agentic handlers, DebugModule wiring, comprehensive tests.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-themes-demo-chaos/09-RESEARCH.md
@.planning/phases/09-themes-demo-chaos/09-04-SUMMARY.md
@android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/CommandHandler.kt
@android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/AgenticCommand.kt
@android/app/src/debug/kotlin/app/dqxn/android/debug/DebugModule.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: ChaosEngine + determinism tests</name>
  <files>
    android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/ChaosEngine.kt
    android/core/agentic/src/test/kotlin/app/dqxn/android/core/agentic/chaos/ChaosEngineTest.kt
  </files>
  <action>
    **1. Create ChaosEngine.kt** in `android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/`:

    ```kotlin
    @Singleton
    public class ChaosEngine @Inject constructor(
      private val interceptor: ChaosProviderInterceptor,
    ) {
      private var activeSession: ChaosSession? = null

      public fun start(
        seed: Long,
        profileName: String,
        providerIds: List<String>,
        scope: CoroutineScope,
      ): ChaosSession {
        check(activeSession == null) { "Chaos session already active" }

        val random = Random(seed)
        val profile = ChaosProfile.forName(profileName)
        val plan = profile.generatePlan(random, providerIds)
        val sessionJob = Job(scope.coroutineContext.job)
        val sessionScope = CoroutineScope(scope.coroutineContext + sessionJob)

        val session = ChaosSession(
          sessionId = "chaos-${seed}-${profileName}",
          seed = seed,
          profile = profileName,
          job = sessionJob,
        )
        activeSession = session

        sessionScope.launch {
          for (scheduledFault in plan) {
            delay(scheduledFault.delayMs)
            interceptor.injectFault(scheduledFault.providerId, scheduledFault.fault)
            session.recordInjection(scheduledFault, atMs = System.currentTimeMillis())
          }
        }
        return session
      }

      public fun stop(): ChaosSessionSummary {
        val session = activeSession ?: error("No active chaos session")
        session.job.cancel()
        interceptor.clearAll()
        activeSession = null
        return session.toSummary()
      }

      public fun isActive(): Boolean = activeSession != null
      public fun currentSession(): ChaosSession? = activeSession
    }
    ```

    Key design:
    - `start()` takes a `CoroutineScope` param (injected from handler or test) — session Job is child of that scope
    - `stop()` cancels session Job, clears all faults, returns summary
    - `ChaosProfile.forName(name)` resolves profile by name string
    - Determinism: `Random(seed)` in `generatePlan()` produces identical fault sequences for same seed+profile
    - Only one session active at a time (check guard)

    **2. Create ChaosEngineTest.kt:**
    Tests using JUnit5 + MockK + Truth + `StandardTestDispatcher` + `runTest`:

    - `start creates session with correct seed and profile`
    - `stop cancels session job and clears interceptor faults`
    - `stop on inactive session throws`
    - `start while active session throws`
    - `isActive returns true during active session`
    - `determinism — same seed same profile produces same fault sequence`:
      ```kotlin
      @Test
      fun `same seed produces same fault sequence`() = runTest {
        val interceptor1 = ChaosProviderInterceptor()
        val engine1 = ChaosEngine(interceptor1)
        val session1 = engine1.start(42L, "provider-stress", providers, backgroundScope)
        advanceTimeBy(5000)
        val summary1 = engine1.stop()

        val interceptor2 = ChaosProviderInterceptor()
        val engine2 = ChaosEngine(interceptor2)
        val session2 = engine2.start(42L, "provider-stress", providers, backgroundScope)
        advanceTimeBy(5000)
        val summary2 = engine2.stop()

        assertThat(summary1.injectedFaults.map { it.faultType })
          .isEqualTo(summary2.injectedFaults.map { it.faultType })
        assertThat(summary1.injectedFaults.map { it.providerId })
          .isEqualTo(summary2.injectedFaults.map { it.providerId })
      }
      ```
    - `different seeds produce different fault sequences`
    - `each of 7 profiles produces non-empty fault plan`
    - `combined profile includes faults from at least 3 categories`
    - `session summary includes all injected faults`
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :core:agentic:testDebugUnitTest --tests "*.ChaosEngineTest" --console=plain 2>&1 | tail -20</automated>
  </verify>
  <done>ChaosEngine orchestrates deterministic fault sessions. Same seed = same sequence proven. All 7 profiles produce non-empty plans. Stop clears faults and returns summary.</done>
</task>

<task type="auto">
  <name>Task 2: Chaos agentic handlers + DebugModule wiring + handler tests</name>
  <files>
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ChaosStartHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ChaosStopHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ChaosInjectHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/DebugModule.kt
    android/app/src/test/kotlin/app/dqxn/android/debug/handlers/ChaosStartHandlerTest.kt
    android/app/src/test/kotlin/app/dqxn/android/debug/handlers/ChaosStopHandlerTest.kt
    android/app/src/test/kotlin/app/dqxn/android/debug/handlers/ChaosInjectHandlerTest.kt
  </files>
  <action>
    **1. Create ChaosStartHandler.kt:**
    ```kotlin
    @AgenticCommand(
      name = "chaos-start",
      description = "Start a deterministic chaos testing session",
      category = "chaos",
    )
    public class ChaosStartHandler @Inject constructor(
      private val engine: ChaosEngine,
      private val providerRegistry: DataProviderRegistry,
    ) : CommandHandler {
      override val name: String = "chaos-start"
      override val description: String = "Start a deterministic chaos testing session"
      override val category: String = "chaos"
      override val aliases: List<String> = emptyList()

      override suspend fun execute(params: CommandParams, commandId: String): CommandResult {
        val seed = params.getLong("seed") ?: System.currentTimeMillis()
        val profile = params.getString("profile") ?: "combined"
        val providerIds = providerRegistry.getAll().map { it.sourceId }
        // Use a simple CoroutineScope for the session
        val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)
        val session = engine.start(seed, profile, providerIds, scope)
        return CommandResult.success(
          mapOf(
            "sessionId" to session.sessionId,
            "seed" to seed.toString(),
            "profile" to profile,
            "providerCount" to providerIds.size.toString(),
          )
        )
      }

      override fun paramsSchema(): Map<String, String> = mapOf(
        "seed" to "Random seed for deterministic reproduction (Long, default: current time)",
        "profile" to "Chaos profile name: provider-stress, provider-flap, thermal-ramp, entitlement-churn, widget-storm, process-death, combined (default: combined)",
      )
    }
    ```

    **2. Create ChaosStopHandler.kt:**
    - `@AgenticCommand(name = "chaos-stop", ...)`, category = "chaos"
    - Calls `engine.stop()` and returns the `ChaosSessionSummary` as JSON
    - Returns error result if no active session

    **3. Create ChaosInjectHandler.kt:**
    - `@AgenticCommand(name = "chaos-inject", ...)`, category = "chaos"
    - Params: `providerId` (required), `fault` (required: "kill", "stall", "delay", "error", "flap"), `delayMs` (optional), `onMs`/`offMs` (optional for flap)
    - Calls `interceptor.injectFault(providerId, fault)` directly (no ChaosEngine session needed)
    - Returns current active faults map

    **4. Update DebugModule.kt** — add `@Provides @Singleton` for `ChaosProviderInterceptor` and `ChaosEngine`:
    ```kotlin
    @Provides
    @Singleton
    fun provideChaosProviderInterceptor(): ChaosProviderInterceptor = ChaosProviderInterceptor()

    @Provides
    @Singleton
    fun provideChaosEngine(interceptor: ChaosProviderInterceptor): ChaosEngine = ChaosEngine(interceptor)
    ```

    Also add `@Binds @IntoSet` for `ChaosProviderInterceptor as DataProviderInterceptor` so `WidgetDataBinder` receives it. This requires adding `DataProviderInterceptor` multibinding to DebugModule (if not already present). Check if `AppModule` or `ReleaseModule` has `@Multibinds fun dataProviderInterceptors(): Set<DataProviderInterceptor>`. If not, add `@Multibinds` in `AppModule` and `@Binds @IntoSet` in `DebugModule`.

    **Note:** ChaosProviderInterceptor has `@Inject constructor()` so Hilt can construct it. But ChaosEngine takes `ChaosProviderInterceptor` (not the interface), so `@Provides` may not be needed if the types are visible. Use `@Inject` on constructor and let Hilt wire automatically. Only add explicit `@Provides` if Hilt can't see the type (it's in `:core:agentic` which is `debugImplementation`).

    Actually, `:core:agentic` classes have `@Inject` constructors but `:app` adds them via `debugImplementation`. For debug builds, Hilt sees the classes. The `@Binds @IntoSet DataProviderInterceptor` binding is the key addition. Add it in DebugModule's abstract section.

    **5. Create handler tests (3 files):**
    Each test: JUnit5 + MockK, mock ChaosEngine/ChaosProviderInterceptor/DataProviderRegistry.

    - ChaosStartHandlerTest: `execute with default params starts combined profile`, `execute with explicit seed and profile`, `execute returns session info`
    - ChaosStopHandlerTest: `execute stops session and returns summary`, `execute with no active session returns error`
    - ChaosInjectHandlerTest: `execute injects kill fault`, `execute injects delay fault with delayMs`, `execute injects flap fault with onMs/offMs`, `execute with missing providerId returns error`
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :app:testDebugUnitTest --tests "*.ChaosStartHandlerTest" --tests "*.ChaosStopHandlerTest" --tests "*.ChaosInjectHandlerTest" --console=plain 2>&1 | tail -20</automated>
  </verify>
  <done>3 agentic handlers route chaos commands correctly. DebugModule wires ChaosProviderInterceptor as DataProviderInterceptor. All handler tests pass.</done>
</task>

</tasks>

<verification>
```bash
cd /Users/ohm/Workspace/dqxn/android && ./gradlew :core:agentic:testDebugUnitTest --tests "*.ChaosEngineTest" :app:testDebugUnitTest --tests "*.Chaos*" --console=plain
```
ChaosEngine determinism verified. All 3 handlers tested. Debug-only wiring confirmed.
</verification>

<success_criteria>
- ChaosEngine.start(seed=42, "provider-stress") produces identical fault sequence across runs
- chaos-start returns session info, chaos-stop returns injection summary, chaos-inject injects single fault
- ChaosProviderInterceptor registered as DataProviderInterceptor in debug builds only
- All tests green
</success_criteria>

<output>
After completion, create `.planning/phases/09-themes-demo-chaos/09-05-SUMMARY.md`
</output>
