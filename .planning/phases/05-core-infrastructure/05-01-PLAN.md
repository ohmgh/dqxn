---
phase: 05-core-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - android/data/proto/src/main/proto/dashboard_layout.proto
  - android/data/proto/src/main/proto/paired_devices.proto
  - android/data/proto/src/main/proto/custom_themes.proto
  - android/core/thermal/build.gradle.kts
  - android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/ThermalLevel.kt
  - android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/RenderConfig.kt
  - android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/ThermalManager.kt
  - android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/FramePacer.kt
  - android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/FakeThermalManager.kt
  - android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/di/ThermalModule.kt
  - android/core/thermal/src/test/kotlin/app/dqxn/android/core/thermal/ThermalManagerTest.kt
  - android/core/thermal/src/test/kotlin/app/dqxn/android/core/thermal/FramePacerTest.kt
autonomous: true
requirements: [NF12, NF13, F7.1]

must_haves:
  truths:
    - "Proto schemas generate Java/Kotlin classes for dashboard layout, paired devices, and custom themes"
    - "ThermalManager maps PowerManager thermal status to 4-level ThermalLevel enum"
    - "RenderConfig derives targetFps and glowEnabled from ThermalLevel (60/45/30/24 fps)"
    - "FramePacer calls Window.setFrameRate() on API 34+ and provides throttling control for API 31-33"
    - "FakeThermalManager provides controllable MutableStateFlow for testing and chaos injection"
  artifacts:
    - path: "android/data/proto/src/main/proto/dashboard_layout.proto"
      provides: "DashboardStore, ProfileCanvas, SavedWidget proto messages"
      contains: "message DashboardStore"
    - path: "android/data/proto/src/main/proto/paired_devices.proto"
      provides: "PairedDeviceStore, PairedDeviceMetadata proto messages"
      contains: "message PairedDeviceStore"
    - path: "android/data/proto/src/main/proto/custom_themes.proto"
      provides: "CustomThemeStore, CustomTheme proto messages"
      contains: "message CustomThemeStore"
    - path: "android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/ThermalManager.kt"
      provides: "Thermal headroom monitoring and status listener"
      contains: "class ThermalManager"
    - path: "android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/FramePacer.kt"
      provides: "Frame rate control via Window.setFrameRate()"
      contains: "class FramePacer"
  key_links:
    - from: "android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/ThermalManager.kt"
      to: "android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/RenderConfig.kt"
      via: "thermalLevel.map { RenderConfig(...) }"
      pattern: "ThermalLevel\\..* -> RenderConfig"
---

<objective>
Create Proto DataStore schemas for all structured persistence and implement the thermal management system.

Purpose: Proto schemas are the foundation for all `:data` repositories (Plans 03-05). The thermal module provides proactive degradation before OS throttling, consumed by Phase 7's dashboard coordinators.
Output: 3 `.proto` files generating Kotlin/Java classes, complete `:core:thermal` module with ThermalManager, FramePacer, RenderConfig, FakeThermalManager, and tests.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-core-infrastructure/05-RESEARCH.md
@android/data/proto/build.gradle.kts
@android/core/thermal/build.gradle.kts
@android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/log/DqxnLogger.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Proto DataStore schemas for layout, devices, and themes</name>
  <files>
    android/data/proto/src/main/proto/dashboard_layout.proto
    android/data/proto/src/main/proto/paired_devices.proto
    android/data/proto/src/main/proto/custom_themes.proto
  </files>
  <action>
    Create the proto source directory structure at `android/data/proto/src/main/proto/`.

    **dashboard_layout.proto:**
    - `syntax = "proto3"`, `option java_package = "app.dqxn.android.data.proto"`, `option java_multiple_files = true`
    - `message DashboardStore`: `int32 schema_version = 1`, `repeated ProfileCanvas profiles = 2`, `string active_profile_id = 3`, `bool auto_switch_enabled = 4`
    - `message ProfileCanvas`: `string profile_id = 1`, `string display_name = 2`, `int32 sort_order = 3`, `bool auto_switch_enabled = 4`, `repeated SavedWidget widgets = 5`
    - `message SavedWidget`: `string id = 1`, `string type = 2`, `int32 grid_x = 3`, `int32 grid_y = 4`, `int32 width_units = 5`, `int32 height_units = 6`, `string background_style = 7`, `float opacity = 8`, `bool show_border = 9`, `bool has_glow_effect = 10`, `int32 corner_radius_percent = 11`, `int32 rim_size_percent = 12`, `optional string variant = 13`, `map<string, string> settings = 14`, `repeated string selected_data_source_ids = 15`, `int32 z_index = 16`

    **paired_devices.proto:**
    - Same java_package and java_multiple_files options
    - `message PairedDeviceStoreProto`: `repeated PairedDeviceMetadata devices = 1`
    - `message PairedDeviceMetadata`: `string definition_id = 1`, `string display_name = 2`, `string mac_address = 3`, `int64 last_connected = 4`, `int32 association_id = 5`

    **custom_themes.proto:**
    - Same options
    - `message CustomThemeStoreProto`: `repeated CustomTheme themes = 1`
    - `message CustomTheme`: `string theme_id = 1`, `string display_name = 2`, `bool is_dark = 3`, `string colors_json = 4`, `string gradients_json = 5`, `int64 created_at = 6`, `int64 modified_at = 7`

    Use `Proto` suffix on top-level store messages to avoid name clashes with domain types in `:data`.

    Verify: `./gradlew :data:proto:compileKotlin --console=plain` succeeds and generates classes under `build/generated/source/proto/`.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :data:proto:compileKotlin --console=plain 2>&1 | tail -5</automated>
    <manual>Check that generated Java/Kotlin files exist under data/proto/build/generated/</manual>
  </verify>
  <done>All 3 proto files compile. Generated classes available for `:data` module consumption in Plan 03.</done>
</task>

<task type="auto">
  <name>Task 2: Thermal management module — ThermalManager, FramePacer, RenderConfig, tests</name>
  <files>
    android/core/thermal/build.gradle.kts
    android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/ThermalLevel.kt
    android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/RenderConfig.kt
    android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/ThermalManager.kt
    android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/FramePacer.kt
    android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/FakeThermalManager.kt
    android/core/thermal/src/main/kotlin/app/dqxn/android/core/thermal/di/ThermalModule.kt
    android/core/thermal/src/test/kotlin/app/dqxn/android/core/thermal/ThermalManagerTest.kt
    android/core/thermal/src/test/kotlin/app/dqxn/android/core/thermal/FramePacerTest.kt
  </files>
  <action>
    **build.gradle.kts:** Add dependencies: `implementation(project(":sdk:observability"))`, `implementation(libs.kotlinx.coroutines.core)`, `implementation(libs.hilt.android)` (for @Inject). Add `id("dqxn.android.hilt")` plugin if it resolves KSP. If Hilt KSP is too heavy for this module, use `implementation(libs.hilt.android)` for annotations only and a manual `@Module` with `@InstallIn`.

    **ThermalLevel.kt:** Enum: `NORMAL`, `WARM`, `DEGRADED`, `CRITICAL`. Package: `app.dqxn.android.core.thermal`.

    **RenderConfig.kt:** `@Immutable data class RenderConfig(val targetFps: Float, val glowEnabled: Boolean, val useGradientFallback: Boolean)`. Use `compileOnly(libs.compose.runtime)` for `@Immutable` if module doesn't have Compose compiler -- otherwise use `@Stable`. Actually `:core:thermal` has no Compose plugin, so skip `@Immutable` annotation. Make it a plain data class. Consumers in Phase 7 will wrap it.

    **ThermalManager.kt:** `@Singleton class ThermalManager @Inject constructor(@ApplicationContext context: Context, logger: DqxnLogger)`. Private `_thermalLevel = MutableStateFlow(ThermalLevel.NORMAL)`. Public `thermalLevel: StateFlow<ThermalLevel>`. Public `renderConfig: StateFlow<RenderConfig>` derived via `.map { level -> ... }.stateIn(scope, SharingStarted.Eagerly, RenderConfig.DEFAULT)`. Mapping per NF13: NORMAL→(60f, true, false), WARM→(45f, true, false), DEGRADED→(30f, false, true), CRITICAL→(24f, false, true). `fun start()` registers `PowerManager.addThermalStatusListener()`. Map `THERMAL_STATUS_NONE/LIGHT`→NORMAL, `MODERATE`→WARM, `SEVERE`→DEGRADED, `EMERGENCY/SHUTDOWN`→CRITICAL. Also poll `getThermalHeadroom(10)` -- if headroom returns > 0 and < 0.3 but status is NORMAL, preemptively set WARM.

    Inject a `CoroutineScope` via `@ApplicationScope` (from `:sdk:common`). If `@ApplicationScope` isn't available as a qualifier, create a local scope in `start()`.

    **FramePacer.kt:** NOT a Hilt-managed singleton -- it takes a `Window` parameter at call site (Phase 7 provides the Window). `class FramePacer(private val logger: DqxnLogger)`. `fun applyFrameRate(window: Window, targetFps: Float)`: on API 34+ call `window.attributes.let { params -> params.preferredDisplayModeId = ... }` OR better: `window.setFrameRate(targetFps, ...)` -- NO, Window doesn't have setFrameRate. That's `Surface.setFrameRate()`. Use `window.decorView.viewTreeObserver` or the `Surface` from `window.decorView.holder`. Alternative: set `WindowManager.LayoutParams.preferredRefreshRate = targetFps`. This is the simplest approach. For API 31-33 fallback: use `Choreographer` frame callback with skip logic (count frames, skip rendering on N-1 out of N). Actually for Phase 5, just provide the `preferredRefreshRate` approach as a utility. Phase 7 integrates it with Compose rendering.

    **FakeThermalManager.kt:** Exposes `MutableStateFlow<ThermalLevel>` directly. Implements same interface or extends ThermalManager (if open). Better: extract `ThermalMonitor` interface with `thermalLevel: StateFlow<ThermalLevel>` and `renderConfig: StateFlow<RenderConfig>`. `ThermalManager` implements it. `FakeThermalManager` implements it with `MutableStateFlow`. `ThermalModule` binds `ThermalMonitor` to `ThermalManager`.

    **ThermalModule.kt:** `@Module @InstallIn(SingletonComponent::class) abstract class ThermalModule { @Binds abstract fun bindThermalMonitor(impl: ThermalManager): ThermalMonitor }`.

    **ThermalManagerTest.kt:** JUnit5 + MockK + Turbine + Truth.
    - Test NORMAL→WARM→DEGRADED→CRITICAL transitions via `FakeThermalManager` flow emissions
    - Test `renderConfig` derivation: each ThermalLevel produces correct fps/glow/gradient values
    - Test default state is NORMAL with 60fps
    - Use `StandardTestDispatcher` per project convention

    **FramePacerTest.kt:** Mock Window/WindowManager.LayoutParams. Test that `applyFrameRate(window, 30f)` sets `preferredRefreshRate = 30f`. Test API branching if applicable.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :core:thermal:testDebugUnitTest --console=plain 2>&1 | tail -10</automated>
  </verify>
  <done>`:core:thermal` module compiles with ThermalManager, FramePacer, RenderConfig, FakeThermalManager. ThermalMonitor interface extracted for testability. All thermal tests pass. RenderConfig maps NF13 tiers correctly (60/45/30/24 fps).</done>
</task>

</tasks>

<verification>
```bash
cd /Users/ohm/Workspace/dqxn/android
./gradlew :data:proto:compileKotlin :core:thermal:testDebugUnitTest --console=plain
```
Both tasks pass: proto generates classes, thermal tests green.
</verification>

<success_criteria>
1. `./gradlew :data:proto:compileKotlin` succeeds -- 3 proto files generate Kotlin/Java classes
2. `./gradlew :core:thermal:testDebugUnitTest` passes -- thermal state transitions and RenderConfig derivation verified
3. Proto-generated classes importable by `:data` module (verified in Plan 03)
4. FakeThermalManager usable for chaos injection testing
</success_criteria>

<output>
After completion, create `.planning/phases/05-core-infrastructure/05-01-SUMMARY.md`
</output>
