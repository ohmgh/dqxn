---
phase: 11-theme-ui-diagnostics-onboarding
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinator.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/di/DashboardModule.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/ProviderStatusBridgeTest.kt
autonomous: true
requirements:
  - F3.13

must_haves:
  truths:
    - "ProviderStatusProvider is implemented and installed in Hilt graph"
    - "Provider statuses include providerId, displayName, isConnected, lastUpdateTimestamp"
    - "Diagnostics module can inject ProviderStatusProvider without depending on :feature:dashboard"
  artifacts:
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinator.kt"
      provides: "ProviderStatusProvider implementation via WidgetBindingCoordinator"
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/di/DashboardModule.kt"
      provides: "Hilt binding for ProviderStatusProvider"
  key_links:
    - from: "DashboardModule.kt"
      to: "ProviderStatusProvider interface"
      via: "@Binds Hilt binding"
      pattern: "@Binds.*ProviderStatusProvider"
    - from: "ProviderStatusProvider"
      to: "DiagnosticsViewModel (Plan 11-07)"
      via: "constructor injection"
      pattern: "ProviderStatusProvider"
---

<objective>
Implement ProviderStatusProvider in `:feature:dashboard` and bind it in the Hilt graph so `:feature:diagnostics` can consume provider health data.

Purpose: The ProviderStatusProvider interface (defined in `:sdk:observability` Phase 3) is the bridge that lets diagnostics show provider health WITHOUT creating a `:feature:diagnostics` → `:feature:dashboard` dependency. Implementation lives in WidgetBindingCoordinator which already tracks provider states.

Output: ProviderStatusProvider bound in Hilt, testable via unit test.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-theme-ui-diagnostics-onboarding/11-RESEARCH.md
@android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/health/ProviderStatusProvider.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinator.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: ProviderStatusProvider implementation + Hilt binding</name>
  <files>
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinator.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/di/DashboardModule.kt
  </files>
  <action>
    1. Make `WidgetBindingCoordinator` implement `ProviderStatusProvider`:
       - Add `: ProviderStatusProvider` to class declaration
       - Implement `providerStatuses(): Flow<Map<String, ProviderStatus>>` that maps the coordinator's internal provider tracking state to `ProviderStatus` objects
       - The coordinator already tracks provider states (connection, errors, timestamps) internally. Map those to the ProviderStatus data class from `:sdk:observability`
       - If the coordinator doesn't have a suitable internal flow, create a `_providerStatuses: MutableStateFlow<Map<String, ProviderStatus>>` and update it when provider states change (on bind, on error, on data emission)
       - Each ProviderStatus should include: providerId (from DataProvider.providerId), displayName (from DataProviderSpec), isConnected (from binding state), lastUpdateTimestamp (from last emission), errorDescription (from last error if any)

    2. Add Hilt binding in `DashboardModule.kt`:
       ```kotlin
       @Binds
       abstract fun bindProviderStatusProvider(
           impl: WidgetBindingCoordinator
       ): ProviderStatusProvider
       ```

       Note: WidgetBindingCoordinator's scoping must match. If it's `@ViewModelScoped` or not scoped, you may need to adjust. If it's already `@Inject` constructor, verify the binding is compatible. If WidgetBindingCoordinator isn't directly bindable (e.g., it's created by another coordinator), create a thin `ProviderStatusBridge` class that delegates to the coordinator and is `@Singleton` or `@ViewModelScoped`.

    Read the actual WidgetBindingCoordinator source carefully to understand its internal state tracking before implementing. The implementation must derive statuses from existing data flows, not duplicate tracking.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:compileDebugKotlin --console=plain 2>&1 | tail -10</automated>
  </verify>
  <done>WidgetBindingCoordinator implements ProviderStatusProvider, Hilt binding resolves without MissingBinding</done>
</task>

<task type="auto">
  <name>Task 2: ProviderStatusProvider unit test</name>
  <files>
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/ProviderStatusBridgeTest.kt
  </files>
  <action>
    Create a unit test verifying the ProviderStatusProvider implementation:

    1. `providerStatuses emits empty map initially` — no providers bound → empty map
    2. `providerStatuses reflects bound provider` — after binding a provider, map contains its status with correct providerId and displayName
    3. `provider error updates status description` — after a provider error, the errorDescription field is populated
    4. `disconnected provider shows isConnected false` — provider that stops emitting shows isConnected=false in status

    Use MockK for dependencies. Use Turbine for flow testing with `StandardTestDispatcher`. Follow the established coordinator test patterns from Phase 7 (read existing coordinator tests for setup patterns — `runTest`, mock injection, etc.).

    The test file name should match the actual implementation class name. If the implementation is directly on WidgetBindingCoordinator, name it accordingly. If a bridge class was created, test the bridge.

    Use `@Tag("fast")` for test filtering.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.ProviderStatusBridgeTest" --console=plain 2>&1 | tail -20</automated>
  </verify>
  <done>ProviderStatusProvider implementation verified: empty initial state, bound provider reflects, error description populated, connection state tracked</done>
</task>

</tasks>

<verification>
cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.ProviderStatusBridgeTest" --console=plain
</verification>

<success_criteria>
- ProviderStatusProvider implemented in `:feature:dashboard` without cross-module dependency violations
- Hilt binding compiles (no MissingBinding at DI assembly)
- 4+ tests verify status derivation from internal coordinator state
</success_criteria>

<output>
After completion, create `.planning/phases/11-theme-ui-diagnostics-onboarding/11-04-SUMMARY.md`
</output>
