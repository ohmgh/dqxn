---
phase: 11-theme-ui-diagnostics-onboarding
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/session/SessionEvent.kt
  - android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/session/SessionEventEmitter.kt
  - android/feature/diagnostics/build.gradle.kts
  - android/feature/diagnostics/src/main/kotlin/app/dqxn/android/feature/diagnostics/SessionRecorder.kt
  - android/feature/diagnostics/src/main/kotlin/app/dqxn/android/feature/diagnostics/di/DiagnosticsModule.kt
  - android/feature/diagnostics/src/test/kotlin/app/dqxn/android/feature/diagnostics/SessionRecorderTest.kt
autonomous: true
requirements:
  - F13.3

must_haves:
  truths:
    - "SessionRecorder captures events only when recording is enabled"
    - "Ring buffer overflow evicts oldest events (max 10,000)"
    - "snapshot() returns an ImmutableList without blocking recording"
    - "SessionEventEmitter interface is in :sdk:observability so :feature:dashboard can call record() without depending on :feature:diagnostics"
  artifacts:
    - path: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/session/SessionEventEmitter.kt"
      provides: "Interface for recording session events — visible to all features"
    - path: "android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/session/SessionEvent.kt"
      provides: "SessionEvent data class and EventType enum — visible to all features"
    - path: "android/feature/diagnostics/src/main/kotlin/app/dqxn/android/feature/diagnostics/SessionRecorder.kt"
      provides: "Ring buffer session recorder implementing SessionEventEmitter"
    - path: "android/feature/diagnostics/src/main/kotlin/app/dqxn/android/feature/diagnostics/di/DiagnosticsModule.kt"
      provides: "Hilt binding: SessionRecorder → SessionEventEmitter"
    - path: "android/feature/diagnostics/src/test/kotlin/app/dqxn/android/feature/diagnostics/SessionRecorderTest.kt"
      provides: "Unit tests for ring buffer, toggle, overflow, snapshot"
  key_links:
    - from: "SessionEventEmitter.kt"
      to: ":feature:dashboard (Plan 11-04 wires call sites)"
      via: "Hilt @Singleton injection of SessionEventEmitter interface"
      pattern: "SessionEventEmitter"
    - from: "DiagnosticsModule.kt"
      to: "SessionRecorder → SessionEventEmitter"
      via: "@Binds Hilt binding in SingletonComponent"
      pattern: "@Binds.*SessionEventEmitter"
    - from: "SessionRecorder.kt"
      to: "DiagnosticsViewModel (Plan 11-07)"
      via: "Direct injection for snapshot/recording control"
      pattern: "SessionRecorder"
---

<objective>
Define SessionEventEmitter interface + SessionEvent types in `:sdk:observability`, set up `:feature:diagnostics` build configuration, and implement SessionRecorder — the ring-buffer event capture service for F13.3.

Purpose: The SessionEventEmitter interface MUST live in `:sdk:observability` so that `:feature:dashboard` can record tap/move/resize/navigate events without depending on `:feature:diagnostics`. SessionRecorder implements this interface in diagnostics and is bound via Hilt. This follows the same pattern as ProviderStatusProvider.

Output: SessionEventEmitter interface in `:sdk:observability`, SessionRecorder implementation in `:feature:diagnostics` with Hilt binding + tests.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-theme-ui-diagnostics-onboarding/11-RESEARCH.md
@.planning/ARCHITECTURE.md
@android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/health/ProviderStatusProvider.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: SessionEventEmitter interface + SessionEvent types in :sdk:observability + diagnostics build config</name>
  <files>
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/session/SessionEvent.kt
    android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/session/SessionEventEmitter.kt
    android/feature/diagnostics/build.gradle.kts
  </files>
  <action>
    1. Create `SessionEvent.kt` in package `app.dqxn.android.sdk.observability.session` (in `:sdk:observability`):
    ```kotlin
    @Immutable
    public data class SessionEvent(
        val timestamp: Long,
        val type: EventType,
        val details: String = "",
    )

    public enum class EventType {
        TAP, MOVE, RESIZE, NAVIGATE, EDIT_MODE_ENTER, EDIT_MODE_EXIT, THEME_CHANGE, WIDGET_ADD, WIDGET_REMOVE
    }
    ```

    Both types are `public` — consumed by `:feature:dashboard` (event emission) and `:feature:diagnostics` (recording + viewing).

    2. Create `SessionEventEmitter.kt` in package `app.dqxn.android.sdk.observability.session`:
    ```kotlin
    /**
     * Interface for recording session events. Lives in :sdk:observability so any feature module
     * can emit events without depending on :feature:diagnostics.
     *
     * Implementation: SessionRecorder in :feature:diagnostics, bound via Hilt.
     */
    public interface SessionEventEmitter {
        /** Record a session event. No-op if recording is not enabled. */
        public fun record(event: SessionEvent)
    }
    ```

    This follows the exact same pattern as ProviderStatusProvider: interface in `:sdk:observability`, implementation in a feature module, bound via Hilt.

    3. Update `feature/diagnostics/build.gradle.kts` to add required dependencies per ARCHITECTURE.md:
    ```kotlin
    plugins { id("dqxn.android.feature") }
    android { namespace = "app.dqxn.android.feature.diagnostics" }
    dependencies {
        implementation(project(":core:design"))
        implementation(project(":data"))
        implementation(project(":sdk:analytics"))

        testImplementation(libs.compose.ui.test.junit4)
        debugImplementation(libs.compose.ui.test.manifest)
    }
    ```

    Note: `:sdk:contracts`, `:sdk:common`, `:sdk:ui`, `:sdk:observability` are auto-wired by `dqxn.android.feature` convention plugin. SessionEventEmitter comes via `:sdk:observability` transitively.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :sdk:observability:compileDebugKotlin :feature:diagnostics:compileDebugKotlin --console=plain 2>&1 | tail -10</automated>
  </verify>
  <done>SessionEventEmitter + SessionEvent in `:sdk:observability`, `:feature:diagnostics` compiles with all dependency wiring correct</done>
</task>

<task type="auto">
  <name>Task 2: SessionRecorder implementation + Hilt binding + tests</name>
  <files>
    android/feature/diagnostics/src/main/kotlin/app/dqxn/android/feature/diagnostics/SessionRecorder.kt
    android/feature/diagnostics/src/main/kotlin/app/dqxn/android/feature/diagnostics/di/DiagnosticsModule.kt
    android/feature/diagnostics/src/test/kotlin/app/dqxn/android/feature/diagnostics/SessionRecorderTest.kt
  </files>
  <action>
    1. Implement `SessionRecorder` as `@Singleton` implementing `SessionEventEmitter`:
    ```kotlin
    @Singleton
    class SessionRecorder @Inject constructor() : SessionEventEmitter {
        companion object { const val MAX_EVENTS = 10_000 }
        private val buffer = ArrayDeque<SessionEvent>(MAX_EVENTS)
        private val lock = Any()
        private val _isRecording = MutableStateFlow(false)
        val isRecording: StateFlow<Boolean> = _isRecording.asStateFlow()

        override fun record(event: SessionEvent) {
            if (!_isRecording.value) return
            synchronized(lock) {
                if (buffer.size >= MAX_EVENTS) buffer.removeFirst()
                buffer.addLast(event)
            }
        }

        fun startRecording() { _isRecording.value = true }
        fun stopRecording() { _isRecording.value = false }
        fun snapshot(): ImmutableList<SessionEvent> = synchronized(lock) { buffer.toImmutableList() }
        fun clear() = synchronized(lock) { buffer.clear() }
    }
    ```

    2. Create `DiagnosticsModule.kt` in `app.dqxn.android.feature.diagnostics.di`:
    ```kotlin
    @Module
    @InstallIn(SingletonComponent::class)
    abstract class DiagnosticsModule {
        @Binds
        abstract fun bindSessionEventEmitter(impl: SessionRecorder): SessionEventEmitter
    }
    ```

    This binding makes `SessionEventEmitter` injectable anywhere in the app graph — including `:feature:dashboard`.

    3. Create `SessionRecorderTest.kt` with JUnit5:
    1. `record does nothing when not recording` — record 5 events, snapshot is empty
    2. `record captures events when recording` — start, record 3, snapshot has 3
    3. `ring buffer evicts oldest on overflow` — record MAX_EVENTS + 10, verify size == MAX_EVENTS and oldest events gone (check first event timestamp)
    4. `snapshot returns immutable copy` — record, snapshot, record more, first snapshot unchanged
    5. `stop recording prevents further capture` — start, record 2, stop, record 2 more, snapshot has 2
    6. `clear removes all events` — record, clear, snapshot empty, isRecording unchanged
    7. `isRecording flow reflects state` — use Turbine to verify initial false, start -> true, stop -> false
    8. `implements SessionEventEmitter interface` — verify `recorder is SessionEventEmitter` (structural test for the Hilt binding contract)

    Use `@Tag("fast")` on the test class for fast-test filtering.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:diagnostics:testDebugUnitTest --tests "*.SessionRecorderTest" --console=plain 2>&1 | tail -20</automated>
  </verify>
  <done>All 8 SessionRecorder tests pass: toggle gating, ring buffer overflow, snapshot immutability, clear, flow state, interface conformance. Hilt binding compiles.</done>
</task>

</tasks>

<verification>
cd /Users/ohm/Workspace/dqxn/android && ./gradlew :sdk:observability:compileDebugKotlin :feature:diagnostics:testDebugUnitTest --console=plain
</verification>

<success_criteria>
- SessionEventEmitter interface + SessionEvent types in `:sdk:observability` (visible to all features)
- `:feature:diagnostics` builds with correct dependency graph per ARCHITECTURE.md
- SessionRecorder implements SessionEventEmitter, ring buffer handles 10,000 events with overflow eviction
- Hilt @Binds binding in DiagnosticsModule makes SessionEventEmitter injectable app-wide
- Recording toggle gates capture; snapshot returns immutable copy
- 8+ tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-theme-ui-diagnostics-onboarding/11-02-SUMMARY.md`
</output>
