# Phase 12: CI Gates + Benchmarking - Research

**Researched:** 2026-02-25
**Domain:** Android performance measurement, Compose stability enforcement, CI gate automation
**Confidence:** MEDIUM-HIGH

## Summary

Phase 12 establishes the performance measurement infrastructure and CI enforcement gates for the DQXN dashboard. The work spans five areas: (1) Baseline Profile generation for AOT-compiled critical paths, (2) Macrobenchmark module for frame timing and startup measurements, (3) Compose compiler stability auditing with zero-unstable-class enforcement, (4) APK size gates, and (5) Pitest mutation testing setup (tracking only, not enforced). The existing `:baselineprofile` and `:benchmark` module stubs need to be fully configured with proper build.gradle.kts files, test classes, and dependencies.

A critical constraint: macrobenchmarks and baseline profile generation require a physical device or rooted emulator (userdebug/aosp image). The benchmarks themselves produce `benchmarkData.json` with frame timing percentiles (P50/P90/P95/P99) in `sampledMetrics.frameDurationCpuMs`, which CI scripts parse and compare against thresholds. Compose stability is enforced by parsing the `-classes.txt` report files generated by the Compose compiler. APK size is a simple post-`assembleRelease` file size check.

**Primary recommendation:** Structure this phase as 4-5 small, focused plans: (1) version catalog + `:baselineprofile` module setup, (2) `:benchmark` module with macrobenchmark tests, (3) Compose stability audit Gradle task + CI script, (4) APK size gate + Pitest tracking setup, (5) CI gate runner script tying everything together. Plans 1-2 require device execution but the plan code itself is fully automated. Plans 3-5 are pure JVM/Gradle work.

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| NF1 | Dashboard renders at 60fps with 12 active widgets on reference hardware (Snapdragon 6-series, 6GB RAM) | Macrobenchmark `FrameTimingMetric` P95 < 16.67ms gate; `:benchmark` module measures this with `MacrobenchmarkRule.measureRepeated()` |
| NF9 | Baseline Profiles generated for critical paths (dashboard load, widget picker, edit mode) | `:baselineprofile` module with `BaselineProfileRule.collect()` generates profiles; `androidx.baselineprofile` Gradle plugin includes them in release APK |
| NF10 | Macrobenchmarks in CI gating: P99 frame duration < 16ms, startup < 1.5s | `FrameTimingMetric` + `StartupTimingMetric` in `:benchmark` module; CI script parses `benchmarkData.json` and asserts thresholds |
| NF34 | APK size < 30MB base, < 50MB with all packs | Post-`assembleRelease` file size check; Gradle task or shell script measuring APK file size |
| NF35 | Incremental build time < 15s, clean build < 120s | Already validated in Phase 1 (38s clean build with stubs); re-verify with full codebase after Phase 8+ |
</phase_requirements>

## Standard Stack

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `androidx.benchmark:benchmark-macro-junit4` | 1.4.1 | Macrobenchmark test rule for frame timing and startup measurement | Official AndroidX library, outputs structured JSON with P50/P90/P95/P99 percentiles |
| `androidx.profileinstaller:profileinstaller` | 1.4.1 | Baseline Profile installation in target app | Required companion to baseline profile generation; enables ART profile compilation |
| `androidx.baselineprofile` (Gradle plugin) | 1.3.1 | Automates baseline profile generation and inclusion in release builds | Official AndroidX plugin, handles profile copying and variant configuration |
| `org.jetbrains.kotlinx.kover` | 0.9.7 | Code coverage measurement for coordinator coverage gate (>90%) | JetBrains-maintained, first-class Kotlin support, AGP-compatible, variant-aware |
| `info.solidsoft.pitest` | 1.19.0-rc.2 | Mutation testing framework (tracking only at V1) | Standard JVM mutation testing; `pitest-kotlin` plugin adds Kotlin-specific mutators |
| `pl.droidsonroids.pitest` | 0.2.25 | Android-specific Pitest Gradle plugin | Fork of standard plugin adding Android project support, mockable JAR on classpath |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `androidx.test.ext:junit` | latest | JUnit4 runner for instrumented tests | Benchmark and baseline profile tests are JUnit4 instrumented tests |
| `androidx.test.uiautomator:uiautomator` | 2.3.0 | UI interaction in benchmark tests | Required by `MacrobenchmarkScope` for `startActivityAndWait()`, `findObject()`, etc. |
| `pitest-kotlin` | latest | Kotlin-specific mutation operators for Pitest | Always — required for Kotlin bytecode mutation |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Kover | JaCoCo | JaCoCo works but Kover has better Kotlin integration and variant-aware task generation; Kover is the Kotlin-first choice |
| `pl.droidsonroids.pitest` | `info.solidsoft.pitest` | Standard plugin doesn't support Android library modules; the Android fork handles mockable JAR and variant tasks |
| vanniktech APK size plugin | Shell script `stat` | The plugin provides CSV output + `maxApkSize` threshold enforcement; shell script is simpler but less integrated. For a single-app project, a shell script comparing `stat -f%z` against a threshold is sufficient |
| `compose-report-to-html` | Custom parser script | The HTML tool is for developer visualization; CI needs a parseable script that counts unstable classes and fails on >0 |

**Version Catalog Additions:**

```toml
# versions
benchmark = "1.4.1"
profileinstaller = "1.4.1"
baselineprofile-plugin = "1.3.1"
uiautomator = "2.3.0"
kover = "0.9.7"
pitest = "1.22.0"
pitest-plugin = "1.19.0-rc.2"
pitest-android-plugin = "0.2.25"

# libraries
benchmark-macro-junit4 = { group = "androidx.benchmark", name = "benchmark-macro-junit4", version.ref = "benchmark" }
profileinstaller = { group = "androidx.profileinstaller", name = "profileinstaller", version.ref = "profileinstaller" }
uiautomator = { group = "androidx.test.uiautomator", name = "uiautomator", version.ref = "uiautomator" }

# plugins
baselineprofile = { id = "androidx.baselineprofile", version.ref = "baselineprofile-plugin" }
kover = { id = "org.jetbrains.kotlinx.kover", version.ref = "kover" }
```

## Architecture Patterns

### Module Structure

```
android/
├── baselineprofile/              # com.android.test module
│   ├── build.gradle.kts          # com.android.test + androidx.baselineprofile plugins
│   └── src/main/kotlin/          # BaselineProfileGenerator.kt
├── benchmark/                     # com.android.library → com.android.test module
│   ├── build.gradle.kts          # com.android.test plugin + benchmark-macro-junit4
│   └── src/main/kotlin/          # *Benchmark.kt test classes
├── app/
│   └── build.gradle.kts          # + androidx.baselineprofile plugin + profileinstaller dep
└── scripts/
    ├── ci-gates.sh               # Orchestrator: runs all gates, aggregates results
    ├── check-compose-stability.sh # Parses Compose compiler reports
    ├── check-apk-size.sh         # Measures APK size against threshold
    └── check-benchmark.sh        # Parses benchmarkData.json against thresholds
```

### Pattern 1: Baseline Profile Generation

**What:** `:baselineprofile` is a `com.android.test` module that generates AOT compilation profiles for critical code paths.

**When to use:** Release builds only. Profile generation requires a physical device or rooted emulator with `aosp` system image.

**Example:**

```kotlin
// baselineprofile/build.gradle.kts
plugins {
    id("com.android.test")
    id("androidx.baselineprofile")
}

android {
    namespace = "app.dqxn.android.baselineprofile"
    compileSdk = 36
    targetProjectPath = ":app"
    defaultConfig {
        minSdk = 31
        targetSdk = 36
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }
}

baselineProfile {
    useConnectedDevices = true
}

dependencies {
    implementation(libs.benchmark.macro.junit4)
}
```

```kotlin
// BaselineProfileGenerator.kt
@RunWith(AndroidJUnit4::class)
class BaselineProfileGenerator {
    @get:Rule
    val rule = BaselineProfileRule()

    @Test
    fun startup() = rule.collect(
        packageName = "app.dqxn.android",
    ) {
        pressHome()
        startActivityAndWait()
    }

    @Test
    fun dashboardInteraction() = rule.collect(
        packageName = "app.dqxn.android",
    ) {
        startActivityAndWait()
        // Widget picker, edit mode, profile switch
    }
}
```

### Pattern 2: Macrobenchmark Tests

**What:** `:benchmark` module measures frame timing and startup metrics using `MacrobenchmarkRule`.

**When to use:** CI pipeline on physical device or Firebase Test Lab.

**Example:**

```kotlin
// benchmark/build.gradle.kts
plugins {
    id("com.android.test")
}

android {
    namespace = "app.dqxn.android.benchmark"
    compileSdk = 36
    targetProjectPath = ":app"
    defaultConfig {
        minSdk = 31
        targetSdk = 36
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }
    // Benchmark variant for release-like performance
    buildTypes {
        create("benchmark") {
            isDebuggable = true
            signingConfig = signingConfigs.getByName("debug")
            matchingFallbacks += listOf("release")
        }
    }
}

dependencies {
    implementation(libs.benchmark.macro.junit4)
    implementation(libs.uiautomator)
}
```

```kotlin
// DashboardBenchmark.kt
@RunWith(AndroidJUnit4::class)
class DashboardBenchmark {
    @get:Rule
    val rule = MacrobenchmarkRule()

    @Test
    fun coldStartup() = rule.measureRepeated(
        packageName = "app.dqxn.android",
        metrics = listOf(StartupTimingMetric()),
        iterations = 5,
        startupMode = StartupMode.COLD,
        setupBlock = { pressHome() },
        measureBlock = { startActivityAndWait() },
    )

    @Test
    fun dashboardFrameTiming() = rule.measureRepeated(
        packageName = "app.dqxn.android",
        metrics = listOf(FrameTimingMetric()),
        iterations = 3,
        startupMode = StartupMode.WARM,
        setupBlock = {
            startActivityAndWait()
            // App loads with 12 widgets from demo pack
        },
        measureBlock = {
            // Wait for steady-state rendering with 12 widgets
            device.waitForIdle()
            Thread.sleep(5_000) // 5s soak
        },
    )
}
```

### Pattern 3: Compose Stability Audit

**What:** Parse Compose compiler `-classes.txt` reports to enforce zero unstable classes in app-owned modules.

**When to use:** Every build, as a CI gate. Run `./gradlew assembleRelease` with reports enabled, then parse.

**Key insight:** The Compose compiler already writes reports to `build/compose_compiler/` for every module that has `reportsDestination` set (which `AndroidComposeConventionPlugin` already does). The audit script parses these files.

**Example:**

```bash
#!/bin/bash
# check-compose-stability.sh
# Parse compose compiler reports and fail if unstable classes found in app-owned modules

MODULES=("app" "feature/dashboard" "feature/settings" "feature/diagnostics"
         "feature/onboarding" "sdk/ui" "core/design"
         "pack/essentials" "pack/themes" "pack/demo")
UNSTABLE_COUNT=0
NON_SKIPPABLE_DASHBOARD=0

for module in "${MODULES[@]}"; do
    CLASSES_FILE="$module/build/compose_compiler/*-classes.txt"
    if ls $CLASSES_FILE 1>/dev/null 2>&1; then
        # Count unstable classes (lines matching "unstable class")
        count=$(grep -c "unstable " $CLASSES_FILE 2>/dev/null || echo 0)
        if [ "$count" -gt 0 ]; then
            echo "FAIL: $module has $count unstable classes"
            UNSTABLE_COUNT=$((UNSTABLE_COUNT + count))
        fi
    fi
done

if [ "$UNSTABLE_COUNT" -gt 0 ]; then
    echo "GATE FAILED: $UNSTABLE_COUNT unstable classes found"
    exit 1
fi
```

### Pattern 4: Benchmark JSON Parsing for CI Gates

**What:** Parse `benchmarkData.json` output and compare percentile values against defined thresholds.

**Key data structure:** Frame timing metrics appear in `sampledMetrics`:

```json
{
  "sampledMetrics": {
    "frameDurationCpuMs": {
      "P50": 4.8,
      "P90": 6.8,
      "P95": 8.9,
      "P99": 15.3
    },
    "frameOverrunMs": {
      "P50": -9.2,
      "P90": -1.9,
      "P95": 266.9,
      "P99": 310.9
    }
  }
}
```

Startup metrics appear in `metrics`:

```json
{
  "metrics": {
    "timeToInitialDisplayMs": {
      "minimum": 347.8,
      "maximum": 520.1,
      "median": 410.3,
      "runs": [347.8, 410.3, 520.1]
    }
  }
}
```

### Anti-Patterns to Avoid

- **Running macrobenchmarks on emulators:** Emulator performance is not representative. Macrobenchmark library will warn/error. Use physical device or Firebase Test Lab.
- **Using `UnconfinedTestDispatcher` in benchmark context:** Benchmarks are JUnit4 instrumented tests, not coroutine tests. No dispatchers involved.
- **Hardcoding P50 thresholds too tight:** Frame timing has natural variance. Use P95/P99 for hard gates, P50 for trend monitoring with tolerance.
- **Enabling Compose compiler reports in debug builds:** Reports should use release builds for accurate stability analysis (debug builds may have different inlining).
- **Mutation testing as a blocking gate at V1:** Pitest infrastructure is heavy and slow. Track kill rates, don't enforce until post-launch.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Baseline profile generation | Manual profile rule files | `BaselineProfileRule` + `androidx.baselineprofile` plugin | Plugin handles profile compilation, merging, and inclusion in release APK automatically |
| Frame timing measurement | Custom `FrameMetrics` callback code | `FrameTimingMetric` in Macrobenchmark | Produces structured P50/P90/P95/P99 output in `benchmarkData.json`, handles warm-up, thermal throttle detection |
| Startup timing | Custom `reportFullyDrawn()` timing code | `StartupTimingMetric` in Macrobenchmark | Measures both `timeToInitialDisplayMs` and `timeToFullDisplayMs` with proper warm-up |
| Code coverage | Manual test counting | Kover `0.9.7` | Variant-aware, automatic task generation, HTML + XML reports, verification rules |
| APK size measurement with module breakdown | Custom `apkanalyzer` scripting | `stat -f%z` for simple threshold + consider Spotify Ruler for module-level breakdown | Simple threshold check is fine for CI gate; Ruler adds value for debugging regressions |

**Key insight:** The Macrobenchmark library and Baseline Profile plugin handle the hard parts (thermal throttle detection, proper warm-up, profile compilation, variant management). The CI gate scripts just need to parse the JSON output and compare against thresholds.

## Common Pitfalls

### Pitfall 1: `:benchmark` Module Type Mismatch

**What goes wrong:** The existing `:benchmark` stub uses `id("dqxn.android.library")` (which applies `com.android.library`). Macrobenchmark modules must use `com.android.test`.
**Why it happens:** Phase 1 created module stubs without knowing the final plugin configuration.
**How to avoid:** Replace the build.gradle.kts entirely. Use `id("com.android.test")` directly (not a convention plugin). Set `targetProjectPath = ":app"`.
**Warning signs:** Build error about missing `targetProjectPath` or `testInstrumentationRunner`.

### Pitfall 2: AGP 9 Baseline Profile Plugin Compatibility

**What goes wrong:** `androidx.baselineprofile:1.3.1` may have compatibility warnings with AGP 9.0.1 due to internal API changes (old `BaseExtension` types removed).
**Why it happens:** AGP 9 removed old DSL types. The baseline profile plugin's `maxAgpVersion` check may trigger warnings.
**How to avoid:** Use `baselineProfile { warnings { maxAgpVersion = false } }` to suppress the version warning if the plugin works correctly despite the warning. Test profile generation to verify actual compatibility. If 1.3.1 fails, try the alpha track (`1.5.0-alpha01` which explicitly bumped max AGP to 9.0.0-alpha01).
**Warning signs:** Warning message about AGP version exceeding plugin's tested maximum.

### Pitfall 3: Compose Compiler Reports Path

**What goes wrong:** The `reportsDestination` in `AndroidComposeConventionPlugin` is set to `layout.buildDirectory.dir("compose_compiler")`. The CI script must match this exact path pattern across all modules.
**Why it happens:** Different modules have different build directory layouts. The `*-classes.txt` filename includes the module name.
**How to avoid:** Use glob patterns in the CI script: `"$MODULE/build/compose_compiler/*-classes.txt"`. Verify the actual file name format after a release build.
**Warning signs:** Script reports "no files found" when classes.txt files actually exist at a slightly different path.

### Pitfall 4: Benchmark Requires Non-Debuggable APK

**What goes wrong:** Macrobenchmark reports errors if the target app is debuggable.
**Why it happens:** Debug builds have profiling overhead that corrupts frame timing measurements.
**How to avoid:** The `:benchmark` module needs a `benchmark` build type that matches the app's `release` build type (or `benchmarkRelease`). Set `isDebuggable = true` on the benchmark module only (the test APK, not the target), with `matchingFallbacks += listOf("release")` so it builds against the release variant of `:app`.
**Warning signs:** `IllegalStateException: Target app is debuggable` error when running benchmarks.

### Pitfall 5: `android.enableAdditionalTestOutput` Missing

**What goes wrong:** Benchmark JSON files are not copied to host machine's `build/outputs/` directory.
**Why it happens:** Gradle needs this flag to automatically pull benchmark results from device.
**How to avoid:** Add `android.enableAdditionalTestOutput=true` to `gradle.properties`.
**Warning signs:** No `benchmarkData.json` in build outputs after `connectedBenchmarkAndroidTest` runs.

### Pitfall 6: Thermal Throttling Noise in Benchmarks

**What goes wrong:** Benchmark results vary wildly between runs, especially P99.
**Why it happens:** Device thermal throttling during sustained benchmark runs reduces CPU frequency.
**How to avoid:** Macrobenchmark has built-in `thermalThrottleSleepSeconds` that pauses between iterations if thermal throttling is detected. For CI: run benchmarks 3 times, use median of medians. Accept P99 as advisory, gate on P95.
**Warning signs:** `thermalThrottleSleepSeconds > 0` in benchmark results; large variance between runs.

### Pitfall 7: Pitest on Android Modules

**What goes wrong:** Standard `info.solidsoft.pitest` plugin doesn't understand Android module structure.
**Why it happens:** Android modules use AGP, not the standard Java/Kotlin plugin. Classpath resolution differs.
**How to avoid:** Use `pl.droidsonroids.pitest` for Android modules. For pure JVM modules (`:codegen:*`, `:data:proto`), the standard plugin works. Target `:sdk:common` and `:sdk:contracts` as stated in architecture docs.
**Warning signs:** `NoClassDefFoundError` during mutation test execution.

### Pitfall 8: Coverage Gate Scope

**What goes wrong:** Kover reports 100% coverage by counting trivially tested modules alongside the target coordinators.
**Why it happens:** Project-wide coverage averaging dilutes the signal from critical modules.
**How to avoid:** Configure Kover verification rules scoped to `:feature:dashboard` only for the >90% line coverage gate. The gate is specifically for the 6 coordinators in `:feature:dashboard`.
**Warning signs:** High coverage numbers that mask under-tested coordinators.

## Code Examples

### Benchmark Build Configuration (`:benchmark`)

```kotlin
// benchmark/build.gradle.kts
plugins {
    id("com.android.test")
}

android {
    namespace = "app.dqxn.android.benchmark"
    compileSdk = 36
    targetProjectPath = ":app"

    defaultConfig {
        minSdk = 31
        targetSdk = 36
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        create("benchmark") {
            isDebuggable = true
            signingConfig = signingConfigs.getByName("debug")
            matchingFallbacks += listOf("release")
        }
    }
}

dependencies {
    implementation(libs.benchmark.macro.junit4)
    implementation(libs.uiautomator)
}
```

### Baseline Profile Build Configuration (`:baselineprofile`)

```kotlin
// baselineprofile/build.gradle.kts
plugins {
    id("com.android.test")
    id("androidx.baselineprofile")
}

android {
    namespace = "app.dqxn.android.baselineprofile"
    compileSdk = 36
    targetProjectPath = ":app"

    defaultConfig {
        minSdk = 31
        targetSdk = 36
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }
}

baselineProfile {
    useConnectedDevices = true
}

dependencies {
    implementation(libs.benchmark.macro.junit4)
}
```

### App Module Additions

```kotlin
// app/build.gradle.kts additions
plugins {
    // ... existing
    id("androidx.baselineprofile")
}

dependencies {
    // ... existing
    implementation(libs.profileinstaller)
    baselineProfile(project(":baselineprofile"))
}
```

### Startup Benchmark

```kotlin
@RunWith(AndroidJUnit4::class)
class StartupBenchmark {
    @get:Rule val rule = MacrobenchmarkRule()

    @Test
    fun coldStartup() = rule.measureRepeated(
        packageName = "app.dqxn.android",
        metrics = listOf(StartupTimingMetric()),
        iterations = 5,
        startupMode = StartupMode.COLD,
        setupBlock = { pressHome() },
        measureBlock = { startActivityAndWait() },
    )
}
```

### Frame Timing Benchmark (12 Widgets)

```kotlin
@RunWith(AndroidJUnit4::class)
class DashboardFrameBenchmark {
    @get:Rule val rule = MacrobenchmarkRule()

    @Test
    fun steadyState12Widgets() = rule.measureRepeated(
        packageName = "app.dqxn.android",
        metrics = listOf(FrameTimingMetric()),
        iterations = 3,
        startupMode = StartupMode.WARM,
        setupBlock = {
            startActivityAndWait()
            // Allow data binding to complete
            device.waitForIdle()
        },
        measureBlock = {
            // 5-second steady-state measurement with 12 active widgets
            // Demo pack provides deterministic data via DemoTimeProvider + DemoSpeedProvider
            Thread.sleep(5_000)
        },
    )

    @Test
    fun editModeCycle() = rule.measureRepeated(
        packageName = "app.dqxn.android",
        metrics = listOf(FrameTimingMetric()),
        iterations = 3,
        startupMode = StartupMode.WARM,
        setupBlock = { startActivityAndWait() },
        measureBlock = {
            // Enter edit mode, interact, exit
            val editToggle = device.findObject(By.res("app.dqxn.android:id/edit_mode_toggle"))
                ?: device.findObject(By.desc("Edit mode"))
            editToggle?.click()
            device.waitForIdle()
            Thread.sleep(2_000)
            editToggle?.click()
            device.waitForIdle()
        },
    )
}
```

### CI Gate Script (Benchmark Threshold Check)

```bash
#!/bin/bash
# check-benchmark.sh — Parse benchmarkData.json and check thresholds

set -euo pipefail

JSON_FILE="${1:?Usage: check-benchmark.sh <benchmarkData.json>}"

# Thresholds from architecture doc
P50_THRESHOLD=8.0
P95_THRESHOLD=12.0
P99_THRESHOLD=16.0
STARTUP_THRESHOLD=1500.0  # ms
JANK_RATE_THRESHOLD=2.0   # percent

# Extract frame timing percentiles using Python (available on CI)
python3 -c "
import json, sys
with open('$JSON_FILE') as f:
    data = json.load(f)
failures = []
for bench in data['benchmarks']:
    name = bench['name']
    # Check startup
    if 'timeToInitialDisplayMs' in bench.get('metrics', {}):
        median = bench['metrics']['timeToInitialDisplayMs']['median']
        if median > $STARTUP_THRESHOLD:
            failures.append(f'FAIL: {name} startup median={median:.1f}ms > ${STARTUP_THRESHOLD}ms')
    # Check frame timing
    sampled = bench.get('sampledMetrics', {})
    if 'frameDurationCpuMs' in sampled:
        ft = sampled['frameDurationCpuMs']
        if ft.get('P50', 0) > $P50_THRESHOLD:
            failures.append(f'FAIL: {name} P50={ft[\"P50\"]:.1f}ms > ${P50_THRESHOLD}ms')
        if ft.get('P95', 0) > $P95_THRESHOLD:
            failures.append(f'FAIL: {name} P95={ft[\"P95\"]:.1f}ms > ${P95_THRESHOLD}ms')
        if ft.get('P99', 0) > $P99_THRESHOLD:
            failures.append(f'FAIL: {name} P99={ft[\"P99\"]:.1f}ms > ${P99_THRESHOLD}ms')
if failures:
    for f in failures:
        print(f)
    sys.exit(1)
else:
    print('All benchmark gates passed')
"
```

### Kover Configuration for Coordinator Coverage

```kotlin
// feature/dashboard/build.gradle.kts additions
plugins {
    // ... existing
    id("org.jetbrains.kotlinx.kover")
}

kover {
    reports {
        verify {
            rule("coordinator-coverage") {
                bound {
                    minValue = 90
                    metric = MetricType.LINE
                    aggregation = AggregationType.COVERED_PERCENTAGE
                }
            }
        }
    }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual baseline profile rules | `BaselineProfileRule` + Gradle plugin | AGP 8.0+ (2023) | Automated profile generation, merging, variant management |
| Espresso-based frame counting | `FrameTimingMetric` macrobenchmark | Benchmark 1.1+ (2022) | Structured percentile output, Perfetto trace integration |
| JaCoCo for Kotlin coverage | Kover 0.9.x | 2024+ | First-class Kotlin support, variant-aware tasks |
| Manual Compose stability auditing | Compose compiler reports + CI parsing | 2024+ | Automated unstable class detection |
| `frameOverrunMs` not available | Available on API 31+ | Android 12 (2021) | Shows actual frame deadline overrun, more meaningful than raw duration for jank |

**Deprecated/outdated:**
- `AndroidBenchmarkRunner`: Use `AndroidJUnitRunner` for macrobenchmarks (the runner is for microbenchmarks only)
- `BaselineProfileRule` in old `androidx.benchmark:benchmark-junit4`: Moved to `benchmark-macro-junit4`
- Manual `-P` flags for Compose compiler reports: Use `ComposeCompilerGradlePluginExtension.reportsDestination` directly (already configured in `AndroidComposeConventionPlugin`)

## Open Questions

1. **AGP 9 + `androidx.baselineprofile:1.3.1` compatibility**
   - What we know: Plugin source bumped max AGP to 9.0.0-alpha01. AGP 9.0.1 is the production release.
   - What's unclear: Whether 1.3.1 works cleanly with AGP 9.0.1 or requires `warnings { maxAgpVersion = false }` suppression, or whether `1.5.0-alpha01` is needed.
   - Recommendation: Try 1.3.1 first. If it fails, fall back to 1.5.0-alpha01. Either way, test baseline profile generation early in plan execution.
   - Confidence: MEDIUM

2. **12-widget benchmark data source**
   - What we know: `:pack:demo` exists and provides `DemoTimeProvider`/`DemoSpeedProvider`. Phase 8 provides essentials pack with 13 widgets.
   - What's unclear: Whether the demo pack can be configured to drive all 12 widgets simultaneously in a benchmark context (no user interaction to add widgets).
   - Recommendation: Use agentic `widget-add` commands in the benchmark `setupBlock` to add 12 widgets programmatically, or pre-configure a debug preset via agentic `preset-load` command. Alternatively, use a dedicated benchmark build variant with a hard-coded 12-widget layout in DataStore.
   - Confidence: MEDIUM

3. **`benchmarkData.json` `sampledMetrics` structure verification**
   - What we know: `FrameTimingMetric` outputs P50/P90/P95/P99 for `frameDurationCpuMs`. The sample JSON file from Google shows only `metrics` (not `sampledMetrics`) because it uses `StartupTimingMetric`.
   - What's unclear: The exact JSON key structure for `sampledMetrics` when `FrameTimingMetric` is used. The research shows the format in documentation but the actual file structure should be verified during execution.
   - Recommendation: Run a test benchmark first, inspect the JSON output, then finalize the CI parsing script.
   - Confidence: MEDIUM

4. **Pitest + Kotlin 2.3 + JDK 25 compatibility**
   - What we know: `pitest-kotlin` exists. `pl.droidsonroids.pitest:0.2.25` supports Android modules.
   - What's unclear: Whether Pitest works with Kotlin 2.3 bytecode and JDK 25. Pitest manipulates bytecode directly.
   - Recommendation: Since Pitest is tracking-only (not a blocking gate), set it up on a best-effort basis. If it fails with JDK 25, note the incompatibility in STATE.md and defer.
   - Confidence: LOW

5. **`com.android.test` module under AGP 9**
   - What we know: The existing `:baselineprofile` stub already uses `id("com.android.test")` which is correct. The `:benchmark` stub uses `id("dqxn.android.library")` which needs to change.
   - What's unclear: Whether `com.android.test` module configuration has changed in AGP 9 (new DSL types). The baselineprofile stub already compiles, which is a good sign.
   - Recommendation: Keep the `com.android.test` plugin for both modules. Test compilation before adding test classes.
   - Confidence: HIGH

## Validation Architecture

### Test Framework

| Property | Value |
|----------|-------|
| Framework | JUnit4 (instrumented benchmarks) + JUnit5 (CI gate script tests) |
| Config file | benchmark/build.gradle.kts (instrumented), scripts/ (CI gates) |
| Quick run command | `./gradlew :benchmark:connectedBenchmarkAndroidTest --console=plain` |
| Full suite command | `./gradlew :app:generateBaselineProfile :benchmark:connectedBenchmarkAndroidTest --console=plain` + CI gate scripts |
| Estimated runtime | ~5min (benchmark on device) + ~2min (compose stability build) + ~10s (APK size + script checks) |

### Phase Requirements to Test Map

| Req ID | Behavior | Test Type | Automated Command | File Exists? |
|--------|----------|-----------|-------------------|-------------|
| NF1 | 60fps with 12 widgets | macrobenchmark | `./gradlew :benchmark:connectedBenchmarkAndroidTest` + `check-benchmark.sh` | No - Wave 0 gap |
| NF9 | Baseline profiles generated | integration | `./gradlew :app:generateBaselineProfile` + verify file in APK | No - Wave 0 gap |
| NF10 | P99 < 16ms, startup < 1.5s | macrobenchmark + CI script | `check-benchmark.sh` parses benchmarkData.json | No - Wave 0 gap |
| NF34 | APK < 30MB base | build + script | `./gradlew assembleRelease` + `check-apk-size.sh` | No - Wave 0 gap |
| NF35 | Build time < 120s clean | build timing | `time ./gradlew assembleDebug --console=plain` (already validated Phase 1) | Partial - revalidation |

### Nyquist Sampling Rate

- **Minimum sample interval:** After every committed task, run: `./gradlew assembleDebug --console=plain` (verify build still works)
- **Full suite trigger:** Before merging final task of any plan wave, run full benchmark suite on device
- **Phase-complete gate:** All CI gate scripts green, benchmark results within thresholds
- **Estimated feedback latency per task:** ~30s (assembleDebug) to ~5min (full benchmark run)

### Wave 0 Gaps (must be created before implementation)

- [ ] `benchmark/src/main/kotlin/.../StartupBenchmark.kt` - covers NF10 startup
- [ ] `benchmark/src/main/kotlin/.../DashboardFrameBenchmark.kt` - covers NF1, NF10 frame timing
- [ ] `baselineprofile/src/main/kotlin/.../BaselineProfileGenerator.kt` - covers NF9
- [ ] `scripts/check-benchmark.sh` - covers NF1, NF10 threshold assertion
- [ ] `scripts/check-compose-stability.sh` - covers Compose stability gate
- [ ] `scripts/check-apk-size.sh` - covers NF34

Note: The macrobenchmark and baseline profile tests require a connected device to execute. This is an automated instrumented test (not a manual test per CLAUDE.md policy). If no device is available during plan execution, the test code is written and compilation-verified; execution deferred with a run prompt.

## Sources

### Primary (HIGH confidence)
- [AndroidX Benchmark Releases](https://developer.android.com/jetpack/androidx/releases/benchmark) - benchmark-macro-junit4 1.4.1 stable, FrameTimingMetric API
- [Create Baseline Profiles](https://developer.android.com/topic/performance/baselineprofiles/create-baselineprofile) - BaselineProfileRule setup, plugin configuration
- [Benchmark in CI](https://developer.android.com/topic/performance/benchmarking/benchmarking-in-ci) - JSON output format, CI pipeline setup
- [Capture Macrobenchmark Metrics](https://developer.android.com/topic/performance/benchmarking/macrobenchmark-metrics) - FrameTimingMetric P50/P90/P95/P99, StartupTimingMetric
- [Compose Stability Diagnostics](https://developer.android.com/develop/ui/compose/performance/stability/diagnose) - Compose compiler reports format
- [Interpreting Compose Compiler Metrics](https://android.googlesource.com/platform/frameworks/support/+/93a27bf544adcea26384f6612da46fef0275f631/compose/compiler/design/compiler-metrics.md) - Report file structure

### Secondary (MEDIUM confidence)
- [Kover Gradle Plugin docs](https://kotlin.github.io/kotlinx-kover/gradle-plugin/) - Kover 0.9.7 API, verification rules
- [Maven: androidx.baselineprofile](https://mvnrepository.com/artifact/androidx.baselineprofile/androidx.baselineprofile.gradle.plugin) - version 1.3.1 confirmed as latest stable
- [Pitest Kotlin plugin](https://github.com/pitest/pitest-kotlin) - Kotlin mutation operators
- [Android Pitest plugin](https://github.com/koral--/gradle-pitest-plugin) - pl.droidsonroids.pitest 0.2.25
- [NordVPN Compose stability CI](https://nordsecurity.com/blog/improving-nordvpn-android-compose-compiler) - CI pipeline integration pattern

### Tertiary (LOW confidence)
- [AGP 9 baseline profile compatibility](https://developer.android.com/build/releases/agp-9-0-0-release-notes) - AGP 9 release notes mention no baseline profile breaking changes, but plugin version compatibility not explicitly confirmed for 9.0.1
- Pitest + Kotlin 2.3 + JDK 25 compatibility - no sources found confirming this combination works

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - all libraries are official AndroidX or well-established (Kover, Pitest). Versions verified on Maven.
- Architecture: MEDIUM-HIGH - macrobenchmark and baseline profile patterns well documented. The 12-widget benchmark setup needs runtime validation.
- Pitfalls: HIGH - common failure modes well documented in Android docs and community. AGP 9 compatibility is the main uncertainty.

**Research date:** 2026-02-25
**Valid until:** 2026-03-25 (30 days - stable ecosystem, versions unlikely to change)
