---
phase: 06-deployable-app-agentic-framework
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - android/app/src/debug/AndroidManifest.xml
  - android/app/src/debug/kotlin/app/dqxn/android/debug/AgenticContentProvider.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/DebugModule.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/PingHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ListCommandsHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/DumpHealthHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/DumpLayoutHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/DumpSemanticsHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/QuerySemanticsHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/DiagnoseCrashHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/DiagnosePerformanceHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ListDiagnosticsHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/GetMetricsHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ListWidgetsHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ListProvidersHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ListThemesHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/TriggerAnomalyHandler.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/CaptureSnapshotHandler.kt
  - android/app/src/test/kotlin/app/dqxn/android/debug/AgenticContentProviderTest.kt
  - android/app/src/test/kotlin/app/dqxn/android/debug/handlers/PingHandlerTest.kt
  - android/app/src/test/kotlin/app/dqxn/android/debug/handlers/DumpHealthHandlerTest.kt
autonomous: true
requirements: [F13.2, F13.4, F13.5, F13.11, NF21]

must_haves:
  truths:
    - "AgenticContentProvider dispatches ADB content call commands to handlers"
    - "All 16 diagnostic handlers registered and routable via list-commands"
    - "ping returns {status:ok} as E2E startup probe"
    - "dump-semantics returns tree with dashboard_grid test tag (or empty if no owner)"
    - "trigger-anomaly creates a diagnostic snapshot file"
    - "AgenticContentProvider is registered only in debug manifest (NF21)"
    - "Response-file protocol used for all responses (no inline JSON in Bundle)"
  artifacts:
    - path: "android/app/src/debug/kotlin/app/dqxn/android/debug/AgenticContentProvider.kt"
      provides: "ContentProvider transport with @EntryPoint Hilt access"
      contains: "class AgenticContentProvider"
    - path: "android/app/src/debug/kotlin/app/dqxn/android/debug/DebugModule.kt"
      provides: "Debug-only Hilt bindings including SemanticsOwnerHolder"
      contains: "@InstallIn(SingletonComponent::class)"
    - path: "android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/PingHandler.kt"
      provides: "ping command returning status ok"
      contains: "@AgenticCommand"
    - path: "android/app/src/debug/AndroidManifest.xml"
      provides: "ContentProvider registration for debug builds only"
      contains: "AgenticContentProvider"
  key_links:
    - from: "android/app/src/debug/.../AgenticContentProvider.kt"
      to: "android/core/agentic/src/main/.../AgenticCommandRouter.kt"
      via: "@EntryPoint Hilt access in call() method"
      pattern: "EntryPointAccessors.fromApplication"
    - from: "android/app/src/debug/.../handlers/PingHandler.kt"
      to: "android/core/agentic/src/main/.../CommandHandler.kt"
      via: "implements CommandHandler interface"
      pattern: "CommandHandler"
    - from: "android/app/src/debug/AndroidManifest.xml"
      to: "android/app/src/debug/.../AgenticContentProvider.kt"
      via: "provider registration"
      pattern: "AgenticContentProvider"
---

<objective>
Build the AgenticContentProvider transport and all 16 Phase 6 diagnostic command handlers. This is the agentic debug framework — every subsequent phase can use `adb shell content call` for autonomous debugging.

Purpose: Enables ADB-driven structured diagnostics, semantics tree inspection, and state dumps. From Phase 6 onward, the agent can deploy to device, query state, diagnose issues, and verify fixes without human intervention.

Output: 16 working diagnostic handlers routable via ContentProvider, with response-file protocol, cold-start race handling, and debug-only manifest registration.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-deployable-app-agentic-framework/06-RESEARCH.md
@.planning/phases/06-deployable-app-agentic-framework/06-01-SUMMARY.md
@.planning/phases/06-deployable-app-agentic-framework/06-02-SUMMARY.md
@android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/CommandHandler.kt
@android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/AgenticCommandRouter.kt
@android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/health/WidgetHealthMonitor.kt
@android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/metrics/MetricsCollector.kt
@android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/crash/CrashEvidenceWriter.kt
@android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/diagnostic/DiagnosticSnapshotCapture.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: AgenticContentProvider transport + DebugModule + debug manifest</name>
  <files>
    android/app/src/debug/AndroidManifest.xml
    android/app/src/debug/kotlin/app/dqxn/android/debug/AgenticContentProvider.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/DebugModule.kt
  </files>
  <action>
    Create `src/debug/AndroidManifest.xml`:
    - `<provider android:name=".debug.AgenticContentProvider" android:authorities="${applicationId}.debug.agentic" android:exported="false" />`
    - `android:exported="false"` — ADB shell bypasses this check, other apps blocked (Research Pitfall 5)

    Create `AgenticContentProvider.kt` — Package: `app.dqxn.android.debug`
    - Extends `ContentProvider`
    - `@EntryPoint @InstallIn(SingletonComponent::class) interface AgenticEntryPoint` with:
      - `fun commandRouter(): AgenticCommandRouter`
    - `override fun call(method: String, arg: String?, extras: Bundle?): Bundle`:
      - Access Hilt via `EntryPointAccessors.fromApplication(context!!.applicationContext, AgenticEntryPoint::class.java)`
      - Wrap in try-catch for `IllegalStateException` (cold-start race — app not yet initialized): return error JSON with "App initializing, retry after ping"
      - Parse params from `arg` string as JSON key-value pairs using kotlinx.serialization
      - Generate traceId: `"agentic-${SystemClock.elapsedRealtimeNanos()}"`
      - Execute: `runBlocking(Dispatchers.Default) { withTimeout(8_000) { entryPoint.commandRouter().route(method, CommandParams(parsedParams, traceId)) } }`
      - Write response JSON to temp file in cacheDir: `File.createTempFile("agentic_", ".json", context!!.cacheDir)`
      - Return `bundleOf("filePath" to file.absolutePath)` — response-file protocol
      - Catch `TimeoutCancellationException` -> error JSON with "Command timed out after 8s"
    - `override fun query(uri: Uri, ...): Cursor?`:
      - Lock-free direct read paths for deadlock-safe escape hatches
      - Parse first path segment: "health" -> build MatrixCursor with cached health data, "anr" -> ANR state
      - Return null for unknown paths
    - `override fun onCreate(): Boolean`:
      - Clean up previous session response files: `context?.cacheDir?.listFiles { f -> f.name.startsWith("agentic_") }?.forEach { it.delete() }`
      - Return `true`
    - Stubs: `insert()` returns null, `update()` returns 0, `delete()` returns 0, `getType()` returns null
    - **CRITICAL:** `runBlocking` is allowed here per CLAUDE.md exception for debug agentic code. Use `Dispatchers.Default`, never `Dispatchers.Main`.

    Create `DebugModule.kt` — Package: `app.dqxn.android.debug`
    - `@Module @InstallIn(SingletonComponent::class) object DebugModule`
    - `@Provides @Singleton fun provideSemanticsOwnerHolder(): SemanticsOwnerHolder = SemanticsOwnerHolder()`
    - This provides SemanticsOwnerHolder only in debug builds — release builds don't have this binding.
    - NOTE: KSP will process `@AgenticCommand` annotations on handler classes and generate `AgenticHiltModule` with `@Binds @IntoSet` for each handler -> `CommandHandler`. The `@AgenticCommand` KSP processor runs on debug source set because handlers are in `src/debug/`. Configure KSP to process debug sources by adding `kspDebug(project(":codegen:agentic"))` in `app/build.gradle.kts` (update build.gradle.kts if not already done in Plan 02).
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :app:compileDebugKotlin --console=plain 2>&1 | tail -10</automated>
    <sampling_rate>run after task commits</sampling_rate>
  </verify>
  <done>AgenticContentProvider compiles with @EntryPoint Hilt access, response-file protocol, cold-start race handling, and 8s timeout. Debug manifest registers provider. DebugModule provides SemanticsOwnerHolder in debug builds only.</done>
</task>

<task type="auto">
  <name>Task 2: All 16 diagnostic command handlers + handler tests</name>
  <files>
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/PingHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ListCommandsHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/DumpHealthHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/DumpLayoutHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/DumpSemanticsHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/QuerySemanticsHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/DiagnoseCrashHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/DiagnosePerformanceHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ListDiagnosticsHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/GetMetricsHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ListWidgetsHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ListProvidersHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/ListThemesHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/TriggerAnomalyHandler.kt
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/CaptureSnapshotHandler.kt
    android/app/src/test/kotlin/app/dqxn/android/debug/handlers/PingHandlerTest.kt
    android/app/src/test/kotlin/app/dqxn/android/debug/handlers/DumpHealthHandlerTest.kt
  </files>
  <action>
    Each handler: `@AgenticCommand(name = "...", description = "...", category = "...")` annotated class implementing `CommandHandler`. Package: `app.dqxn.android.debug.handlers`. All `internal`.

    NOTE: The `@AgenticCommand` annotation has `@Retention(SOURCE)` — it's consumed by KSP at compile time, not available at runtime. The KSP processor generates `AgenticHiltModule` with `@Binds @IntoSet` entries for each handler.

    **Handler inventory (16 handlers):**

    1. `PingHandler` — name: "ping", category: "system"
       - `@Inject constructor()`
       - Returns `Success("""{"status":"ok","timestamp":${System.currentTimeMillis()}}""")` — E2E startup probe

    2. `ListCommandsHandler` — name: "list-commands", category: "system"
       - `@Inject constructor(private val handlers: Set<@JvmSuppressWildcards CommandHandler>)`
       - Returns JSON array of `{name, description, category, params}` for all registered handlers
       - Uses `buildJsonArray` from kotlinx.serialization

    3. `DumpHealthHandler` — name: "dump-health", category: "diagnostics"
       - `@Inject constructor(private val healthMonitor: WidgetHealthMonitor)`
       - Returns widget health snapshot (empty in Phase 6, populates when widgets land)

    4. `DumpLayoutHandler` — name: "dump-layout", category: "diagnostics"
       - `@Inject constructor()` — Phase 6 returns `{"profiles":[],"activeProfile":null}` placeholder
       - Real LayoutRepository injection added in Phase 7 when `:data` repositories are wired

    5. `DumpSemanticsHandler` — name: "dump-semantics", category: "ui"
       - `@Inject constructor(private val semanticsHolder: SemanticsOwnerHolder)`
       - Returns full semantics tree snapshot as JSON, or `{"nodes":[],"message":"No semantics owner registered"}` if absent

    6. `QuerySemanticsHandler` — name: "query-semantics", category: "ui"
       - `@Inject constructor(private val semanticsHolder: SemanticsOwnerHolder)`
       - Accepts params: `testTag`, `text`, `contentDescription`, `hasAction`
       - Returns filtered nodes matching the query

    7. `DiagnoseCrashHandler` — name: "diagnose-crash", category: "diagnostics"
       - `@Inject constructor(private val crashEvidenceWriter: CrashEvidenceWriter)`
       - Returns last crash evidence from SharedPreferences

    8. `DiagnosePerformanceHandler` — name: "diagnose-performance", category: "diagnostics"
       - `@Inject constructor(private val metricsCollector: MetricsCollector)`
       - Returns performance metrics snapshot (frame histogram, jank stats)

    9. `ListDiagnosticsHandler` — name: "list-diagnostics", category: "diagnostics"
       - `@Inject constructor(private val diagnosticCapture: DiagnosticSnapshotCapture)`
       - Accepts optional `since` param (epoch ms) for filtering
       - Lists diagnostic snapshot files with metadata

    10. `GetMetricsHandler` — name: "get-metrics", category: "diagnostics"
        - `@Inject constructor(private val metricsCollector: MetricsCollector)`
        - Returns frame timing histograms and per-widget draw times

    11. `ListWidgetsHandler` — name: "list-widgets", category: "registry"
        - `@Inject constructor(private val widgets: Set<@JvmSuppressWildcards WidgetRenderer>)`
        - Returns JSON array of registered widget typeIds (empty in Phase 6)

    12. `ListProvidersHandler` — name: "list-providers", category: "registry"
        - `@Inject constructor(private val providers: Set<@JvmSuppressWildcards DataProvider<*>>)`
        - Returns JSON array of registered provider IDs (empty in Phase 6)

    13. `ListThemesHandler` — name: "list-themes", category: "registry"
        - `@Inject constructor(private val themes: Set<@JvmSuppressWildcards ThemeProvider>)`
        - Returns JSON array of registered theme IDs (empty in Phase 6)

    14. `TriggerAnomalyHandler` — name: "trigger-anomaly", category: "testing"
        - `@Inject constructor(private val diagnosticCapture: DiagnosticSnapshotCapture)`
        - Fires a diagnostic snapshot capture with `reason = "agentic-trigger"`
        - Returns `{"triggered":true,"reason":"agentic-trigger"}`

    15. `CaptureSnapshotHandler` — name: "capture-snapshot", category: "testing"
        - `@Inject constructor(private val diagnosticCapture: DiagnosticSnapshotCapture)`
        - Fires snapshot capture with custom reason from params
        - Returns file path of created snapshot

    **Dependency wiring note:** Handlers inject observability types (WidgetHealthMonitor, MetricsCollector, CrashEvidenceWriter, DiagnosticSnapshotCapture) that are `@Singleton` in their respective modules. These are available because `:app` depends on `:sdk:observability`. The DebugModule from Task 1 provides `SemanticsOwnerHolder`. Handlers injecting `Set<WidgetRenderer>` etc. get the empty `@Multibinds` sets from `AppModule`.

    **If any observability type is not yet provided by a Hilt module** (e.g., CrashEvidenceWriter, DiagnosticSnapshotCapture may not have Hilt modules from Phase 3), add `@Provides @Singleton` bindings in `DebugModule` to construct them with required dependencies. Check Phase 3 code to determine which types have existing Hilt providers and which need manual wiring.

    **Tests (in src/test/ — these run against debug build type):**

    Create `PingHandlerTest.kt`:
    - JUnit5 @Tag("fast")
    - Test: execute returns Success with status ok
    - Test: response contains timestamp field

    Create `DumpHealthHandlerTest.kt`:
    - JUnit5 @Tag("fast")
    - Test: returns valid JSON when no widgets present (empty health)
    - Test: handler category is "diagnostics"
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :app:compileDebugKotlin :app:testDebugUnitTest --console=plain 2>&1 | tail -15</automated>
    <sampling_rate>run after task commits</sampling_rate>
  </verify>
  <done>All 16 diagnostic handlers compile, annotated with @AgenticCommand, implementing CommandHandler. KSP generates AgenticHiltModule binding all handlers into Set<CommandHandler>. PingHandler and DumpHealthHandler have passing unit tests. Debug manifest registers AgenticContentProvider.</done>
</task>

<task type="auto">
  <name>Task 3: AgenticContentProvider unit tests</name>
  <files>
    android/app/src/test/kotlin/app/dqxn/android/debug/AgenticContentProviderTest.kt
  </files>
  <action>
    Create `AgenticContentProviderTest.kt`:
    - JUnit5 @Tag("fast")
    - Use MockK to mock `AgenticCommandRouter` and `Context`
    - Cannot easily unit-test a real ContentProvider without Robolectric, so test the behavioral logic extracted into helper methods or test via the router's integration:

    **Cold-start race test:**
    - Test: When `EntryPointAccessors.fromApplication` throws `IllegalStateException` (Hilt not initialized), `call()` returns a Bundle with a response file containing error JSON `{"status":"error","message":"App initializing, retry after ping","code":"COLD_START"}`
    - Approach: Create a test-visible `internal fun handleCall(method: String, arg: String?, router: AgenticCommandRouter?, context: Context): Bundle` that encapsulates the logic. The real `call()` delegates to it. In tests, pass `null` router to simulate cold-start. Alternatively, use Robolectric if available in test classpath.

    **8s timeout test:**
    - Test: When handler suspends indefinitely (never returns), `call()` returns error JSON with `"Command timed out after 8s"` and code `"TIMEOUT"`
    - Approach: Create a `StallHandler` that suspends on a `CompletableDeferred.await()`. Pass it through a real `AgenticCommandRouter` with the stall handler registered. Call `handleCall()` and assert timeout error.
    - Use `runBlocking` in the test (allowed in tests per CLAUDE.md) with a shorter timeout override or use `withTimeout` in the provider logic which is already 8s.

    **Response-file protocol test:**
    - Test: Successful command response is written to a temp file in cacheDir, and the returned Bundle contains `"filePath"` key pointing to a readable file with the expected JSON content
    - Test: File content matches the router's output exactly (no truncation, no Bundle size limit)
    - Use a temp directory as mock cacheDir

    **Cleanup test:**
    - Test: `onCreate()` deletes previous session files matching `agentic_*.json` pattern from cacheDir

    NOTE: If Robolectric is not in the test classpath, extract the core dispatch logic into an `internal` function that can be unit-tested without Android framework. The extracted function should take `router`, `cacheDir`, `method`, `arg` as parameters and return `Bundle`. This makes all four test scenarios straightforward.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :app:testDebugUnitTest --tests "*.AgenticContentProviderTest" --console=plain 2>&1 | tail -10</automated>
    <sampling_rate>run after task commits</sampling_rate>
  </verify>
  <done>AgenticContentProviderTest passes: cold-start race returns COLD_START error, 8s timeout returns TIMEOUT error, response-file protocol writes JSON to cacheDir file and returns path in Bundle, onCreate cleanup removes stale files.</done>
</task>

</tasks>

<verification>
1. `./gradlew :app:compileDebugKotlin --console=plain` succeeds with KSP processing all 16 @AgenticCommand handlers
2. `./gradlew :app:testDebugUnitTest --console=plain` passes handler tests
3. AgenticContentProvider uses response-file protocol (file path in Bundle, not inline JSON)
4. All handlers in `src/debug/` source set (NF21 — agentic restricted to debug builds)
5. `@EntryPoint` pattern used for Hilt access in ContentProvider (not `@AndroidEntryPoint`)
</verification>

<success_criteria>
- 16 diagnostic handlers registered and routable via AgenticCommandRouter
- AgenticContentProvider handles cold-start race, 8s timeout, concurrent calls
- Response-file protocol eliminates Binder size limits
- All handler code in debug source set — zero agentic code in release APK
- PingHandler and DumpHealthHandler tests validate handler contract
</success_criteria>

<output>
After completion, create `.planning/phases/06-deployable-app-agentic-framework/06-03-SUMMARY.md`
</output>
