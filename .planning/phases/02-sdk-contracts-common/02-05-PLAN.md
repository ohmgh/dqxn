---
phase: 02-sdk-contracts-common
plan: 05
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/TestWidgetRenderer.kt
  - android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/TestDataProvider.kt
  - android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/TestWidgetScope.kt
  - android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/Factories.kt
  - android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/WidgetRendererContractTest.kt
  - android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/WidgetRendererPropertyTest.kt
  - android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/DataProviderContractTest.kt
  - android/sdk/contracts/src/test/kotlin/app/dqxn/android/sdk/contracts/testing/TestWidgetRendererContractTest.kt
  - android/sdk/contracts/src/test/kotlin/app/dqxn/android/sdk/contracts/testing/TestDataProviderContractTest.kt
autonomous: true
requirements: [F2.1, F2.2, F2.19, F2.20, F3.1, F3.2]

must_haves:
  truths:
    - "WidgetRendererContractTest abstract class provides 14 inherited assertions (JUnit4)"
    - "WidgetRendererPropertyTest abstract class provides jqwik property-based settings survival test (JUnit5)"
    - "DataProviderContractTest abstract class provides 12 inherited assertions (JUnit5)"
    - "TestWidgetRendererContractTest and TestDataProviderContractTest execute in Phase 2 — validates abstract bases run, not just compile"
    - "TestDataProvider supports mid-stream ProviderFault injection"
    - "testFixtures JAR is consumable by downstream modules"
  artifacts:
    - path: "android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/WidgetRendererContractTest.kt"
      provides: "14-assertion abstract test base for all widget renderers"
      contains: "abstract class WidgetRendererContractTest"
    - path: "android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/DataProviderContractTest.kt"
      provides: "12-assertion abstract test base for all data providers"
      contains: "abstract class DataProviderContractTest"
    - path: "android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/TestDataProvider.kt"
      provides: "Configurable fake provider with fault injection"
      contains: "class TestDataProvider"
    - path: "android/sdk/contracts/src/test/kotlin/app/dqxn/android/sdk/contracts/testing/TestWidgetRendererContractTest.kt"
      provides: "Concrete contract test validating abstract base runs"
      contains: "class TestWidgetRendererContractTest"
    - path: "android/sdk/contracts/src/test/kotlin/app/dqxn/android/sdk/contracts/testing/TestDataProviderContractTest.kt"
      provides: "Concrete contract test validating abstract base runs"
      contains: "class TestDataProviderContractTest"
  key_links:
    - from: "TestWidgetRendererContractTest.kt"
      to: "WidgetRendererContractTest.kt"
      via: "extends abstract test base"
      pattern: "class TestWidgetRendererContractTest : WidgetRendererContractTest"
    - from: "TestDataProviderContractTest.kt"
      to: "DataProviderContractTest.kt"
      via: "extends abstract test base"
      pattern: "class TestDataProviderContractTest : DataProviderContractTest"
---

<objective>
Build the testFixtures infrastructure for `:sdk:contracts` — abstract contract test bases, test stubs, factories — and validate them by running concrete subclasses in Phase 2. Every pack widget/provider in Phase 8+ will extend these bases.

Purpose: Contract tests are the architecture's enforcement mechanism. If the abstract bases don't run, we discover breakage 6 phases too late. Executing concrete subclasses now catches testFixtures JAR packaging issues, JUnit4/JUnit5 engine coexistence problems, and jqwik property test integration immediately.
Output: testFixtures JAR with contract test bases + concrete validation tests passing.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-sdk-contracts-common/02-RESEARCH.md
@.planning/migration/phase-02.md
@.planning/phases/02-sdk-contracts-common/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create testFixtures — test stubs, factories, contract test bases</name>
  <files>
    android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/TestWidgetRenderer.kt
    android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/TestDataProvider.kt
    android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/TestWidgetScope.kt
    android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/Factories.kt
    android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/WidgetRendererContractTest.kt
    android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/WidgetRendererPropertyTest.kt
    android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/DataProviderContractTest.kt
  </files>
  <action>
    **TestWidgetRenderer.kt (package: app.dqxn.android.sdk.contracts.testing):**
    Minimal stub implementing `WidgetRenderer`:
    ```kotlin
    class TestWidgetRenderer(
      override val typeId: String = "test:widget",
      override val displayName: String = "Test Widget",
      override val description: String = "A test widget for contract validation",
      override val compatibleSnapshots: Set<KClass<out DataSnapshot>> = emptySet(),
      override val settingsSchema: List<SettingDefinition<*>> = emptyList(),
      override val aspectRatio: Float? = null,
      override val supportsTap: Boolean = false,
      override val priority: Int = 0,
      override val requiredAnyEntitlement: Set<String>? = null,
    ) : WidgetRenderer {
      override fun getDefaults(context: WidgetContext): WidgetDefaults =
        WidgetDefaults(widthUnits = 6, heightUnits = 6, aspectRatio = aspectRatio, settings = emptyMap())

      @Composable
      override fun Render(isEditMode: Boolean, style: WidgetStyle, settings: ImmutableMap<String, Any>, modifier: Modifier) {
        // Minimal: just a Box. Uses compose-runtime annotations.
      }

      override fun accessibilityDescription(data: WidgetData): String =
        if (data.hasData()) "Test widget with data" else "Test widget: no data"

      override fun onTap(widgetId: String, settings: ImmutableMap<String, Any>): Boolean = false
    }
    ```

    **TestDataProvider.kt:**
    Configurable fake that applies `ProviderFault` transformations:
    ```kotlin
    class TestDataProvider<T : DataSnapshot>(
      override val sourceId: String = "test:provider",
      override val displayName: String = "Test Provider",
      override val description: String = "A test provider",
      override val dataType: String = DataTypes.SPEED,
      override val priority: ProviderPriority = ProviderPriority.SIMULATED,
      override val snapshotType: KClass<T>,
      override val schema: DataSchema = DataSchema(emptyList(), 3000L),
      override val setupSchema: List<SetupPageDefinition> = emptyList(),
      override val subscriberTimeout: Duration = 5.seconds,
      override val firstEmissionTimeout: Duration = 5.seconds,
      override val requiredAnyEntitlement: Set<String>? = null,
      private val baseFlow: Flow<T>,
    ) : DataProvider<T> {
      private val _fault = MutableStateFlow<ProviderFault?>(null)
      override val isAvailable: Boolean = true
      override val connectionState: Flow<Boolean> = flowOf(true)
      override val connectionErrorDescription: Flow<String?> = flowOf(null)

      fun injectFault(fault: ProviderFault?) { _fault.value = fault }

      override fun provideState(): Flow<T> = baseFlow.transformLatest { snapshot ->
        when (val fault = _fault.value) {
          null -> emit(snapshot)
          is ProviderFault.Kill -> { /* stop emitting */ return@transformLatest }
          is ProviderFault.Delay -> { delay(fault.delayMs); emit(snapshot) }
          is ProviderFault.Error -> throw fault.exception
          is ProviderFault.ErrorOnNext -> { _fault.value = null; throw fault.exception }
          is ProviderFault.Corrupt -> { @Suppress("UNCHECKED_CAST"); emit(fault.transform(snapshot) as T) }
          is ProviderFault.Flap -> { emit(snapshot); delay(fault.onMillis); /* pause for offMillis handled by caller */ }
          is ProviderFault.Stall -> { /* never emit */ awaitCancellation() }
        }
      }
    }
    ```

    **TestWidgetScope.kt:**
    Test-only `CoroutineScope` wrapping `TestScope`:
    ```kotlin
    class TestWidgetScope(val testScope: TestScope = TestScope()) : CoroutineScope by testScope
    ```

    **Factories.kt:**
    Helper factory functions:
    - `fun testWidgetData(vararg snapshots: Pair<KClass<out DataSnapshot>, DataSnapshot>): WidgetData`
    - `fun testWidgetStyle(): WidgetStyle = WidgetStyle.Default`
    - `fun testWidgetContext(): WidgetContext = WidgetContext.DEFAULT`

    **WidgetRendererContractTest.kt (JUnit4 abstract — for ComposeContentTestRule compatibility):**

    **IMPORTANT:** This is a JUnit4 test (for `ComposeContentTestRule`). Uses `@RunWith(RobolectricTestRunner::class)` for Compose testing on JVM.

    Abstract methods for pack tests to implement:
    - `abstract fun createRenderer(): WidgetRenderer`
    - `abstract fun createTestWidgetData(): WidgetData`

    14 inherited test methods (per phase-02.md contract test spec):
    1. `typeId follows packId-colon-name format` — `assertThat(renderer.typeId).matches("[a-z]+:[a-z][a-z0-9-]+")`
    2. `render does not throw with WidgetData Empty` — compose test rule, set content with Empty, no exception
    3. `render does not throw with WidgetData Unavailable` — compose test rule with Unavailable sentinel
    4. `accessibility description is non-empty for empty data` — `accessibilityDescription(WidgetData.Empty).isNotBlank()`
    5. `accessibility description changes with real data` — `accessibilityDescription(Empty) != accessibilityDescription(testData)`
    6. `compatibleSnapshots entries are DataSnapshot subtypes` — each KClass is assignable to DataSnapshot
    7. `settingsSchema keys are unique` — `schema.map { it.key }.distinct().size == schema.size`
    8. `settingsSchema defaults valid for type constraints` — IntSetting default in min..max, EnumSetting default in options, etc.
    9. SKIP in WidgetRendererContractTest — jqwik property test lives in WidgetRendererPropertyTest (separate JUnit5 class)
    10. `getDefaults returns positive dimensions` — `widthUnits > 0 && heightUnits > 0`
    11. `getDefaults respects aspect ratio if declared` — if `aspectRatio != null`, verify width/height ratio approximately matches
    12. `gating defaults to free when requiredAnyEntitlement is null` — `isAccessible { false } == true` when null
    13. `displayName is non-blank` — `displayName.isNotBlank()`
    14. `description is non-blank` — `description.isNotBlank()`

    NOTE: Test #9 (jqwik render survives arbitrary settings) is NOT in this class because jqwik requires JUnit5. It's in the separate `WidgetRendererPropertyTest` below.

    For the Compose render tests (#2, #3), use:
    ```kotlin
    @get:Rule val composeTestRule = createComposeRule()

    @Test fun `render does not throw with Empty`() {
      composeTestRule.setContent {
        renderer.Render(isEditMode = false, style = testWidgetStyle(), settings = persistentMapOf(), modifier = Modifier)
      }
      // No assertion needed beyond no-exception
    }
    ```

    If `ComposeContentTestRule` has compatibility issues with testFixtures + AGP 9.0.1 (per research pitfall #4), fall back to making tests #2 and #3 non-Compose: just call `accessibilityDescription()` to prove the renderer is instantiable. Document the fallback in the SUMMARY.

    **WidgetRendererPropertyTest.kt (JUnit5/jqwik abstract):**
    Abstract methods: `abstract fun createRenderer(): WidgetRenderer`

    Single property test (#9 from contract spec):
    ```kotlin
    @Property(tries = 50)
    fun `render survives arbitrary settings`(@ForAll("settingsMaps") settings: Map<String, Any>) {
      // Verify renderer doesn't throw when given random settings
      val renderer = createRenderer()
      val immutableSettings = settings.toPersistentMap()
      // Can't compose in jqwik, but verify accessibilityDescription doesn't throw
      renderer.accessibilityDescription(WidgetData.Empty)
    }

    @Provide
    fun settingsMaps(): Arbitrary<Map<String, Any>> =
      Arbitraries.maps(
        Arbitraries.strings().alpha().ofMinLength(1).ofMaxLength(10),
        Arbitraries.oneOf(
          Arbitraries.integers().map { it as Any },
          Arbitraries.of(true, false).map { it as Any },
          Arbitraries.strings().ofMaxLength(20).map { it as Any },
          Arbitraries.floats().map { it as Any },
        )
      ).ofMinSize(0).ofMaxSize(10)
    ```

    **DataProviderContractTest.kt (JUnit5 abstract):**
    Abstract methods:
    - `abstract fun createProvider(): DataProvider<*>`
    - `abstract fun createTestScope(): TestScope` (or use TestWidgetScope)

    12 inherited test methods:
    1. `emits within firstEmissionTimeout` — `runTest { withTimeout(provider.firstEmissionTimeout) { provideState().first() } }`
    2. `emitted type matches declared snapshotType` — `provideState().first()::class == snapshotType`
    3. `emitted snapshot has non-zero timestamp` — `snapshot.timestamp > 0`
    4. `respects cancellation without leaking` — cancel collector, advanceUntilIdle, verify scheduler idle
    5. `snapshotType is a valid DataSnapshot subtype` — not `DataSnapshot::class` itself
    6. `connectionState emits at least one value` — `connectionState.first()` completes
    7. `connectionErrorDescription null when connected` — if `connectionState.first() == true`, then `connectionErrorDescription.first() == null`
    8. `setupSchema definitions have unique IDs` — `setupSchema.flatMap { it.definitions }.map { it.id }.distinct()`
    9. `subscriberTimeout is positive` — `> Duration.ZERO`
    10. `firstEmissionTimeout is positive` — `> Duration.ZERO`
    11. `gating defaults correctly` — same as WidgetRenderer gating test
    12. `multiple concurrent collectors receive same data` — two collectors, both receive emissions

    Use `StandardTestDispatcher` + `runTest` per CLAUDE.md. NEVER `UnconfinedTestDispatcher`.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :sdk:contracts:compileDebugKotlin :sdk:contracts:compileTestFixturesDebugKotlin --console=plain 2>&1 | tail -10</automated>
    <manual>Verify testFixtures source set compiles alongside main source</manual>
  </verify>
  <done>testFixtures created: WidgetRendererContractTest (14 assertions, JUnit4), WidgetRendererPropertyTest (jqwik, JUnit5), DataProviderContractTest (12 assertions, JUnit5), TestWidgetRenderer, TestDataProvider (with ProviderFault injection), TestWidgetScope, Factories. All testFixtures compile.</done>
</task>

<task type="auto">
  <name>Task 2: Create concrete contract tests + verify testFixtures JAR consumption</name>
  <files>
    android/sdk/contracts/src/test/kotlin/app/dqxn/android/sdk/contracts/testing/TestWidgetRendererContractTest.kt
    android/sdk/contracts/src/test/kotlin/app/dqxn/android/sdk/contracts/testing/TestDataProviderContractTest.kt
  </files>
  <action>
    **TestWidgetRendererContractTest.kt (in src/test/, NOT testFixtures):**
    Concrete subclass that exercises the abstract base with `TestWidgetRenderer`:
    ```kotlin
    @RunWith(RobolectricTestRunner::class)
    class TestWidgetRendererContractTest : WidgetRendererContractTest() {
      override fun createRenderer(): WidgetRenderer = TestWidgetRenderer()
      override fun createTestWidgetData(): WidgetData = testWidgetData()
    }
    ```
    This proves the abstract test base actually runs. If ANY of the 14 inherited tests fail, it means the contract test infrastructure is broken — found now, not in Phase 8.

    Also create the property test concrete:
    ```kotlin
    class TestWidgetRendererPropertyTest : WidgetRendererPropertyTest() {
      override fun createRenderer(): WidgetRenderer = TestWidgetRenderer()
    }
    ```

    **TestDataProviderContractTest.kt (in src/test/):**
    Concrete subclass using `TestDataProvider`:
    ```kotlin
    class TestDataProviderContractTest : DataProviderContractTest() {
      override fun createProvider(): DataProvider<*> {
        val flow = flow {
          while (currentCoroutineContext().isActive) {
            emit(UnitSnapshot(timestamp = System.currentTimeMillis()))
            delay(100)
          }
        }
        return TestDataProvider(
          snapshotType = UnitSnapshot::class,
          baseFlow = flow,
        )
      }
    }
    ```
    This proves the provider contract test base works end-to-end: emission, cancellation, timeout, concurrency.

    **After tests pass, verify testFixtures JAR:**
    The concrete tests import from testFixtures within the same module (`:sdk:contracts` test depends on `:sdk:contracts` testFixtures automatically). The critical verification for cross-module consumption is checking that the testFixtures JAR artifact exists:
    `./gradlew :sdk:contracts:testFixturesDebugJar --console=plain` (or similar — verify task name)

    If JAR artifact verification fails, note the issue in SUMMARY but don't block — Phase 8 will be the real consumer. The concrete tests running IS the primary validation.

    **Final regression:** Run the full test suite:
    `./gradlew :sdk:common:testDebugUnitTest :sdk:contracts:testDebugUnitTest --console=plain`
    Verify ALL tests pass (common + contracts). Check test XML output for both JUnit5 Jupiter engine, jqwik engine, and JUnit4 vintage engine entries.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :sdk:common:testDebugUnitTest :sdk:contracts:testDebugUnitTest --console=plain 2>&1 | tail -30</automated>
    <manual>Verify test output XML contains Jupiter, jqwik, and vintage engine entries. Verify all 14 WidgetRendererContractTest assertions pass. Verify all 12 DataProviderContractTest assertions pass.</manual>
  </verify>
  <done>Concrete contract tests execute successfully: TestWidgetRendererContractTest (14 inherited + property test), TestDataProviderContractTest (12 inherited). testFixtures JAR produced. Full regression: all :sdk:common and :sdk:contracts tests pass. Three JUnit engines (Jupiter, jqwik, Vintage) confirmed in XML output.</done>
</task>

</tasks>

<verification>
1. `./gradlew :sdk:common:testDebugUnitTest :sdk:contracts:testDebugUnitTest --console=plain` — all tests pass
2. Test XML at `build/test-results/testDebugUnitTest/` contains JUnit5 Jupiter, jqwik, and JUnit4 Vintage entries
3. `./gradlew :sdk:contracts:assembleDebug --console=plain` — AAR produced
4. `./gradlew spotlessCheck --console=plain` — formatting clean
5. `./gradlew :sdk:common:assembleDebug :sdk:contracts:assembleDebug --console=plain` — both modules build
</verification>

<success_criteria>
- testFixtures: WidgetRendererContractTest (14 assertions), WidgetRendererPropertyTest (jqwik), DataProviderContractTest (12 assertions), TestWidgetRenderer, TestDataProvider (fault injection), TestWidgetScope, Factories
- Concrete tests: TestWidgetRendererContractTest, TestWidgetRendererPropertyTest, TestDataProviderContractTest all pass
- Three JUnit engines coexist: Jupiter (JUnit5), jqwik, Vintage (JUnit4)
- testFixtures JAR artifact produced
- Full regression: ALL sdk:common + sdk:contracts tests green
- Phase 2 success criteria #10 (abstract classes produce JAR), #11 (concrete tests execute), #13 (test XML present) satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-sdk-contracts-common/02-05-SUMMARY.md`
</output>
