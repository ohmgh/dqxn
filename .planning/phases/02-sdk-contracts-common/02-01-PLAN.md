---
phase: 02-sdk-contracts-common
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - android/sdk/common/build.gradle.kts
  - android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/di/Qualifiers.kt
  - android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/di/DispatcherModule.kt
  - android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/result/AppResult.kt
  - android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/result/AppError.kt
  - android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/result/PermissionKind.kt
  - android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/statemachine/ConnectionStateMachine.kt
  - android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/statemachine/ConnectionMachineState.kt
  - android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/statemachine/ConnectionEvent.kt
  - android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/flow/FlowExtensions.kt
  - android/sdk/common/src/test/kotlin/app/dqxn/android/sdk/common/result/AppResultTest.kt
  - android/sdk/common/src/test/kotlin/app/dqxn/android/sdk/common/statemachine/ConnectionStateMachineTest.kt
autonomous: true
requirements: [F3.6]

must_haves:
  truths:
    - "AppResult sealed interface provides Ok/Err with map, flatMap, onSuccess, onFailure, getOrNull, getOrElse, errorOrNull"
    - "AppError hierarchy covers Network, Bluetooth, Permission, Device, Database, Pack, Unknown — no OBU-specific variants"
    - "ConnectionStateMachine transitions through 6 states with retry counter, exponential backoff, max 3 retries"
    - "Dispatcher qualifiers (@IoDispatcher, @DefaultDispatcher, @MainDispatcher) and DispatcherModule provide coroutine dispatchers via Hilt"
  artifacts:
    - path: "android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/result/AppResult.kt"
      provides: "Sealed result type with extension functions"
      contains: "sealed interface AppResult"
    - path: "android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/statemachine/ConnectionStateMachine.kt"
      provides: "State machine with retry logic"
      contains: "class ConnectionStateMachine"
    - path: "android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/di/DispatcherModule.kt"
      provides: "Hilt module for coroutine dispatchers"
      contains: "@InstallIn(SingletonComponent::class)"
    - path: "android/sdk/common/src/test/kotlin/app/dqxn/android/sdk/common/result/AppResultTest.kt"
      provides: "AppResult unit tests"
      contains: "class AppResultTest"
    - path: "android/sdk/common/src/test/kotlin/app/dqxn/android/sdk/common/statemachine/ConnectionStateMachineTest.kt"
      provides: "ConnectionStateMachine tests including jqwik property tests"
      contains: "class ConnectionStateMachineTest"
  key_links:
    - from: "android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/statemachine/ConnectionStateMachine.kt"
      to: "ConnectionMachineState + ConnectionEvent"
      via: "sealed interface references"
      pattern: "ConnectionMachineState|ConnectionEvent"
    - from: "android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/result/AppResult.kt"
      to: "AppError"
      via: "Err variant wraps AppError"
      pattern: "data class Err.*AppError"
---

<objective>
Implement `:sdk:common` module — the foundational types consumed transitively by every module via `:sdk:contracts`. Includes dispatcher DI, result types, connection state machine, and flow utilities.

Purpose: `:sdk:contracts` depends on `api(project(":sdk:common"))` — nothing in contracts compiles until common types exist. This is the first module with real code in the project.
Output: Compiling `:sdk:common` with passing test suite (AppResult + ConnectionStateMachine + jqwik properties).
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-sdk-contracts-common/02-RESEARCH.md
@.planning/migration/phase-02.md
@.planning/ARCHITECTURE.md
@android/sdk/common/build.gradle.kts
@android/build-logic/convention/src/main/kotlin/AndroidTestConventionPlugin.kt
@android/build-logic/convention/src/main/kotlin/AndroidLibraryConventionPlugin.kt
@android/build-logic/convention/src/main/kotlin/AndroidHiltConventionPlugin.kt
@android/gradle/libs.versions.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement sdk:common types — dispatchers, AppResult, AppError, ConnectionStateMachine, flow utils</name>
  <files>
    android/sdk/common/build.gradle.kts
    android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/di/Qualifiers.kt
    android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/di/DispatcherModule.kt
    android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/result/AppResult.kt
    android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/result/AppError.kt
    android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/result/PermissionKind.kt
    android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/statemachine/ConnectionStateMachine.kt
    android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/statemachine/ConnectionMachineState.kt
    android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/statemachine/ConnectionEvent.kt
    android/sdk/common/src/main/kotlin/app/dqxn/android/sdk/common/flow/FlowExtensions.kt
  </files>
  <action>
    **build.gradle.kts:** The stub already has `dqxn.android.library`, `dqxn.android.hilt`, `dqxn.android.test`. Add dependencies:
    - `implementation(libs.kotlinx.coroutines.core)`
    - `implementation(libs.kotlinx.coroutines.android)`
    No other changes needed — test deps come from `dqxn.android.test`.

    **Qualifiers.kt (package: app.dqxn.android.sdk.common.di):**
    - `@Qualifier @Retention(RUNTIME) annotation class IoDispatcher`
    - `@Qualifier @Retention(RUNTIME) annotation class DefaultDispatcher`
    - `@Qualifier @Retention(RUNTIME) annotation class MainDispatcher`
    - `@Qualifier @Retention(RUNTIME) annotation class ApplicationScope`
    Uses `javax.inject.Qualifier` (from Hilt transitive).

    **DispatcherModule.kt:**
    - `@Module @InstallIn(SingletonComponent::class) object DispatcherModule`
    - `@Provides @IoDispatcher fun providesIoDispatcher(): CoroutineDispatcher = Dispatchers.IO`
    - `@Provides @DefaultDispatcher fun providesDefaultDispatcher(): CoroutineDispatcher = Dispatchers.Default`
    - `@Provides @MainDispatcher fun providesMainDispatcher(): CoroutineDispatcher = Dispatchers.Main`
    - `@Provides @ApplicationScope fun providesApplicationScope(...): CoroutineScope = CoroutineScope(SupervisorJob() + defaultDispatcher)`
    Do NOT create a `DQXNDispatchers` interface — it was dropped per phase-02.md.

    **AppError.kt (package: app.dqxn.android.sdk.common.result):**
    - `sealed interface AppError` with `val message: String?`
    - Variants: `data class Network(override val message: String? = null, val cause: Throwable? = null)`,
      `data class Bluetooth(override val message: String? = null)`,
      `data class Permission(val kind: PermissionKind, override val message: String? = null)`,
      `data class Device(override val message: String? = null)`,
      `data class Database(override val message: String? = null, val cause: Throwable? = null)`,
      `data class Pack(val packId: String, val code: String, override val message: String? = null)`,
      `data class Unknown(override val message: String? = null, val cause: Throwable? = null)`
    - NO OBU-specific variants (`Obu`, `SdkAuth` — dropped per phase-02.md)
    - `Pack` variant is the extensibility mechanism for pack-originated errors crossing the SDK boundary.

    **PermissionKind.kt:**
    - `enum class PermissionKind { LOCATION, BLUETOOTH, CAMERA, MICROPHONE, NOTIFICATION, STORAGE }`
    - NO `ObuDataAccess` — dropped.

    **AppResult.kt:**
    - `sealed interface AppResult<out T>` with `data class Ok<out T>(val value: T)` and `data class Err(val error: AppError)`
    - Properties: `isSuccess`, `isFailure`, `getOrNull()`, `errorOrNull()`
    - Extension functions: `map`, `flatMap`, `onSuccess`, `onFailure`, `getOrElse(T)`, `getOrElse((AppError) -> T)`
    - Exact signatures per 02-RESEARCH.md code examples.

    **ConnectionMachineState.kt (package: app.dqxn.android.sdk.common.statemachine):**
    - `sealed interface ConnectionMachineState`
    - 6 states: `data object Idle`, `data object Searching`, `data class DeviceDiscovered(val deviceId: String, val deviceName: String)`,
      `data object Connecting`, `data object Connected`, `data class Error(val error: AppError)`

    **ConnectionEvent.kt:**
    - `sealed interface ConnectionEvent`
    - 7 events: `data object StartSearch`, `data class DeviceFound(val deviceId: String, val deviceName: String)`,
      `data object Connect`, `data object ConnectionSuccess`, `data class ConnectionFailed(val error: AppError)`,
      `data object Disconnect`, `data object SearchTimeout`

    **ConnectionStateMachine.kt:**
    - Class with `_state: MutableStateFlow<ConnectionMachineState>`, `state: StateFlow<ConnectionMachineState>`
    - Internal `retryCount: Int = 0`, `maxRetries: Int = 3`
    - `fun transition(event: ConnectionEvent): ConnectionMachineState` — computes new state, updates flow
    - Exhaustive `when` on (current state, event) pairs. Invalid transitions return current state (no-op).
    - Key transitions: `ConnectionFailed` increments retryCount, if retryCount >= maxRetries → `Idle` (reset), else → `Error`.
      `ConnectionSuccess` resets retryCount to 0. `SearchTimeout` from `Searching` → `Error`.
    - `fun reset()` — retryCount = 0, state = Idle
    - `val retryDelay: Long get()` — exponential backoff: `1000L * (1 shl (retryCount - 1).coerceAtLeast(0))` (1s, 2s, 4s)

    **FlowExtensions.kt (package: app.dqxn.android.sdk.common.flow):**
    - `fun <T> Flow<T>.throttleLatest(periodMillis: Long): Flow<T>` — emission throttling using `conflate` + `onEach { delay(periodMillis) }`
    - `fun <T> Flow<T>.catchAndLog(tag: String, fallback: T): Flow<T>` — placeholder that catches and emits fallback (full logging integration comes Phase 3)
    - Keep minimal — only utilities needed by multiple consumers.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :sdk:common:compileDebugKotlin --console=plain 2>&1 | tail -5</automated>
    <manual>Verify no compilation errors, all types resolve</manual>
  </verify>
  <done>`:sdk:common` compiles with all types: 3 dispatcher qualifiers, DispatcherModule, AppResult with 7 extension functions, AppError with 7 variants, PermissionKind enum, ConnectionStateMachine with 6 states/7 events/retry logic, FlowExtensions</done>
</task>

<task type="auto">
  <name>Task 2: Write sdk:common tests — AppResult, ConnectionStateMachine (ported + exhaustive + jqwik)</name>
  <files>
    android/sdk/common/src/test/kotlin/app/dqxn/android/sdk/common/result/AppResultTest.kt
    android/sdk/common/src/test/kotlin/app/dqxn/android/sdk/common/statemachine/ConnectionStateMachineTest.kt
  </files>
  <action>
    **AppResultTest.kt (JUnit5):**
    Port 9 existing tests from old codebase conceptual tests + add expanded coverage:
    1. `Ok value retrieval` — `Ok(42).getOrNull() == 42`
    2. `Err value is null` — `Err(AppError.Network()).getOrNull() == null`
    3. `map transforms Ok` — `Ok(2).map { it * 3 } == Ok(6)`
    4. `map passes through Err` — `Err(err).map { fail() }` stays Err
    5. `flatMap chains Ok` — `Ok(2).flatMap { Ok(it + 1) } == Ok(3)`
    6. `flatMap short-circuits Err` — `Err(err).flatMap { fail() }` stays Err
    7. `getOrElse returns value for Ok` — `Ok(1).getOrElse(99) == 1`
    8. `getOrElse returns default for Err` — `Err(err).getOrElse(99) == 99`
    9. `getOrElse lambda receives error` — `Err(err).getOrElse { it.message } == message`
    10. `onSuccess invoked for Ok, not Err` — verify side effect
    11. `onFailure invoked for Err, not Ok` — verify side effect
    12. `isSuccess and isFailure properties`
    13. `errorOrNull returns error for Err, null for Ok`
    14. `onSuccess returns original result` — chaining
    15. `onFailure returns original result` — chaining
    Use `@Tag("fast")` on the class.

    **ConnectionStateMachineTest.kt (JUnit5 + jqwik):**
    Use `@Nested` classes for organization.

    **Ported tests (8):**
    - Idle + StartSearch → Searching
    - Searching + DeviceFound → DeviceDiscovered
    - DeviceDiscovered + Connect → Connecting
    - Connecting + ConnectionSuccess → Connected
    - Connecting + ConnectionFailed → Error (first failure, retryCount incremented)
    - Connected + Disconnect → Idle
    - Searching + Disconnect → Idle
    - Error + StartSearch → Searching (retry path)

    **Exhaustive transition matrix (42 cells — 6 states x 7 events):**
    Create a `@ParameterizedTest @MethodSource("transitionMatrix")` that tests every (state, event) pair. Valid transitions produce expected new state. Invalid transitions return current state (no-op). This is the critical test — ensures no undefined behavior.

    Format: `data class TransitionCase(val from: ConnectionMachineState, val event: ConnectionEvent, val expected: ConnectionMachineState)`. Use `@JvmStatic fun transitionMatrix(): List<TransitionCase>` source method listing all 42 cases.

    **New behavior tests:**
    - SearchTimeout from Searching → Error("Search timeout")
    - ConnectionFailed increments retry counter
    - After 3 ConnectionFailed from Connecting → goes to Idle (max retries exhausted, retryCount reset)
    - ConnectionSuccess resets retry counter to 0
    - reset() always returns to Idle with retryCount = 0

    **jqwik property tests (5):** Use `@Property` annotation.
    1. `no event sequence reaches an illegal state` — generate random List<ConnectionEvent> (max 100), apply all transitions, final state is always a valid ConnectionMachineState subtype
    2. `all event sequences from Idle terminate` — from Idle, random events eventually reach Connected, Idle, or Error (may need bounded-length property)
    3. `retry counter never exceeds maxRetries` — generate sequences including ConnectionFailed events, assert retryCount <= 3 at all times
    4. `state machine is deterministic` — same event sequence from same initial state → same final state
    5. `reset always returns to Idle` — from any reachable state, reset() → Idle

    Use custom `@Provide` methods to generate `ConnectionEvent` arbitraries:
    ```kotlin
    @Provide
    fun events(): Arbitrary<ConnectionEvent> = Arbitraries.of(
        ConnectionEvent.StartSearch, ConnectionEvent.Connect,
        ConnectionEvent.ConnectionSuccess, ConnectionEvent.Disconnect,
        ConnectionEvent.SearchTimeout
    ).flatMap { event ->
        if (event is ConnectionEvent.StartSearch) Arbitraries.just(event)
        else Arbitraries.just(event)
    }
    ```
    For DeviceFound and ConnectionFailed, use `Arbitraries.of(...)` with fixed test values.

    Use `@Tag("fast")` on the class. Use Turbine for StateFlow assertions where appropriate.
    Use `StandardTestDispatcher` + `runTest` for any coroutine tests.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :sdk:common:testDebugUnitTest --console=plain 2>&1 | tail -20</automated>
    <manual>Check test XML output exists at build/test-results/ and includes jqwik-executed tests (net.jqwik entries)</manual>
  </verify>
  <done>All `:sdk:common` tests pass: AppResult (15 tests), ConnectionStateMachine ported (8), exhaustive matrix (42 parameterized), new behavior (5), jqwik properties (5). Test XML output present confirming JUnit5 + jqwik engines both executed.</done>
</task>

</tasks>

<verification>
1. `./gradlew :sdk:common:assembleDebug --console=plain` — Android library artifact produced
2. `./gradlew :sdk:common:testDebugUnitTest --console=plain` — all tests pass
3. Verify `build/test-results/testDebugUnitTest/` contains XML with both JUnit5 and jqwik test entries
4. `./gradlew spotlessCheck --console=plain` — formatting passes
</verification>

<success_criteria>
- `:sdk:common` compiles as Android library with Hilt
- All 75+ test assertions pass (AppResult + ConnectionStateMachine + jqwik properties)
- No OBU-specific error types (`Obu`, `SdkAuth`, `ObuDataAccess`) present
- Dispatcher qualifiers + module ready for DI injection
- JUnit5 XML output confirms both Jupiter and jqwik engines executed
</success_criteria>

<output>
After completion, create `.planning/phases/02-sdk-contracts-common/02-01-SUMMARY.md`
</output>
