---
phase: 08-essentials-pack
plan: 10
type: execute
wave: 1
depends_on: []
files_modified:
  - android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarLocationDataProvider.kt
  - android/pack/essentials/src/test/kotlin/app/dqxn/android/pack/essentials/providers/SolarTimezoneDataProviderTest.kt
  - android/pack/essentials/src/test/kotlin/app/dqxn/android/pack/essentials/providers/SolarLocationDataProviderTest.kt
autonomous: true
gap_closure: true
requirements: [F5.1, F5.2, F5.3, F5.4, F5.5, F5.6, F5.7, F5.8, F5.9, F5.10, F5.11, NF14, NF40, NF-I2, NF-P1]

must_haves:
  truths:
    - "SolarTimezoneDataProviderTest extends DataProviderContractTest and all 12 contract assertions pass"
    - "SolarLocationDataProviderTest extends DataProviderContractTest and all 12 contract assertions pass"
    - "Existing provider-specific tests for both solar providers still pass"
    - "All 9 typed data providers now pass DataProviderContractTest (7 previous + 2 solar)"
  artifacts:
    - path: "android/pack/essentials/src/test/kotlin/app/dqxn/android/pack/essentials/providers/SolarTimezoneDataProviderTest.kt"
      provides: "Contract + provider-specific tests for SolarTimezoneDataProvider"
      contains: "DataProviderContractTest"
    - path: "android/pack/essentials/src/test/kotlin/app/dqxn/android/pack/essentials/providers/SolarLocationDataProviderTest.kt"
      provides: "Contract + provider-specific tests for SolarLocationDataProvider"
      contains: "DataProviderContractTest"
    - path: "android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarLocationDataProvider.kt"
      provides: "SolarLocationDataProvider with injectable FusedLocationProviderClient"
      contains: "fusedClient: FusedLocationProviderClient"
  key_links:
    - from: "SolarTimezoneDataProviderTest"
      to: "DataProviderContractTest"
      via: "class inheritance"
      pattern: "class SolarTimezoneDataProviderTest : DataProviderContractTest"
    - from: "SolarLocationDataProviderTest"
      to: "DataProviderContractTest"
      via: "class inheritance"
      pattern: "class SolarLocationDataProviderTest : DataProviderContractTest"
    - from: "SolarLocationDataProvider constructor"
      to: "FusedLocationProviderClient"
      via: "constructor injection"
      pattern: "fusedClient: FusedLocationProviderClient"
---

<objective>
Close SC1 partial gap: make SolarTimezoneDataProviderTest and SolarLocationDataProviderTest extend DataProviderContractTest, adding the 12 inherited contract assertions to both solar providers.

Purpose: SC1 requires all 9 typed data providers to pass DataProviderContractTest. Currently 7/9 pass. The two solar providers have standalone tests but miss 12 contract-level assertions covering emission timing, type correctness, timestamp validity, cancellation safety, connection state, setup schema, timeouts, gating, and concurrency.

Output: Both test files extend DataProviderContractTest. SolarLocationDataProvider accepts injectable FusedLocationProviderClient. All existing tests preserved.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-essentials-pack/08-VERIFICATION.md

# Key reference files
@android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/DataProviderContractTest.kt
@android/pack/essentials/src/test/kotlin/app/dqxn/android/pack/essentials/providers/GpsSpeedProviderTest.kt
@android/pack/essentials/src/test/kotlin/app/dqxn/android/pack/essentials/providers/BatteryProviderTest.kt
@android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarTimezoneDataProvider.kt
@android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarLocationDataProvider.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix SolarTimezoneDataProviderTest to extend DataProviderContractTest + inject FusedLocationProviderClient into SolarLocationDataProvider</name>
  <files>
    android/pack/essentials/src/test/kotlin/app/dqxn/android/pack/essentials/providers/SolarTimezoneDataProviderTest.kt
    android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarLocationDataProvider.kt
  </files>
  <action>
**Part A — SolarTimezoneDataProviderTest:**

Modify `SolarTimezoneDataProviderTest` to extend `DataProviderContractTest()`. This is the straightforward case.

1. Add import: `import app.dqxn.android.sdk.contracts.testing.DataProviderContractTest` and `import app.dqxn.android.sdk.contracts.provider.DataProvider`.
2. Change class declaration to: `class SolarTimezoneDataProviderTest : DataProviderContractTest()`.
3. Change the existing `private fun createProvider()` to `override fun createProvider(): DataProvider<*>`. It must be public (inherited from DataProviderContractTest).
4. The mock context with `registerReceiver` capturing must be initialized eagerly (as it already is) — the parent `@BeforeEach` calls `createProvider()` which needs the mock ready. Follow the same `.also{}` eager init pattern as `GpsSpeedProviderTest.locationManager`.
5. Keep all 8 existing provider-specific tests exactly as they are.
6. The `registerReceiver` mock must actually deliver the receiver callback. Currently it just returns `mockk()`. For the contract test to work, it must:
   - Still capture the receiver in `receiverSlot`
   - The `provideState()` flow's `onStart { emit(getTimezoneCoordinates()) }` ensures first emission happens synchronously before the BroadcastReceiver fires, so contract test #1 (emits within firstEmissionTimeout) will pass.
   - `firstEmissionTimeout` is 5.seconds — plenty of room.

The critical insight: `SolarTimezoneDataProvider.provideState()` does `.onStart { emit(getTimezoneCoordinates()) }` which emits immediately on collection, BEFORE any BroadcastReceiver event. This means the contract tests (first emission, type match, timestamp > 0, cancellation, concurrency) all work without needing the BroadcastReceiver to fire. The mock just needs to not crash on `registerReceiver`/`unregisterReceiver`.

**Part B — Inject FusedLocationProviderClient into SolarLocationDataProvider:**

Modify `SolarLocationDataProvider.kt` to accept `FusedLocationProviderClient` as a constructor parameter instead of creating it lazily.

1. Change the constructor signature to:
   ```kotlin
   @Singleton
   public class SolarLocationDataProvider @Inject constructor(
     @param:ApplicationContext private val context: Context,
     private val fusedClient: FusedLocationProviderClient,
   ) : DataProvider<SolarSnapshot>
   ```
2. Remove the lazy `private val fusedClient` property (lines 95-97).
3. Remove the `import com.google.android.gms.location.LocationServices` import (no longer needed).
4. Everything else stays the same — `provideState()` already uses `fusedClient` directly.

The Hilt injection works because:
- `FusedLocationProviderClient` is provided by the KSP-generated Hilt module or needs a `@Provides` in the pack's module. Check: since `SolarLocationDataProvider` is `@Singleton` with `@Inject constructor`, Hilt will try to inject `FusedLocationProviderClient`. We need a `@Provides` function.
- Add a `@Provides @Singleton` function in a companion or a new small module. The simplest approach: add a `@Provides` function to the existing KSP-generated module... but KSP only generates `@Binds` for `DataProvider`. So add a small `@Module @InstallIn(SingletonComponent::class)` object in the providers package (e.g., `SolarLocationModule.kt`) OR add it to the test only.

Actually, wait — the KSP-generated module handles `@Binds @IntoSet` for `DataProvider<*>`. For `FusedLocationProviderClient` to be injectable, we need a `@Provides`. The cleanest approach for pack isolation: add a `@Module` object in the pack that provides `FusedLocationProviderClient` from `LocationServices.getFusedLocationProviderClient(context)`. Create `android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarLocationModule.kt`:

```kotlin
package app.dqxn.android.pack.essentials.providers

import android.content.Context
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationServices
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
public object SolarLocationModule {
  @Provides
  @Singleton
  public fun provideFusedLocationProviderClient(
    @ApplicationContext context: Context,
  ): FusedLocationProviderClient =
    LocationServices.getFusedLocationProviderClient(context)
}
```

Note: `@ApplicationContext` (not `@param:ApplicationContext`) on `@Provides` function params per Phase 06 decision.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :pack:essentials:compileDebugKotlin --console=plain 2>&amp;1 | tail -5</automated>
    <manual>Compilation succeeds for the production code changes</manual>
  </verify>
  <done>
    - SolarTimezoneDataProviderTest extends DataProviderContractTest with public override createProvider()
    - SolarLocationDataProvider accepts FusedLocationProviderClient as constructor parameter
    - SolarLocationModule provides FusedLocationProviderClient via Hilt
    - Production code compiles
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix SolarLocationDataProviderTest to extend DataProviderContractTest + run all tests</name>
  <files>
    android/pack/essentials/src/test/kotlin/app/dqxn/android/pack/essentials/providers/SolarLocationDataProviderTest.kt
  </files>
  <action>
Modify `SolarLocationDataProviderTest` to extend `DataProviderContractTest()`. This requires mocking `FusedLocationProviderClient` to auto-fire a `LocationCallback` with a valid location on `requestLocationUpdates`.

**Pattern reference:** Follow `GpsSpeedProviderTest` where `locationManager` mock is eagerly initialized with `.also{}` and auto-fires a location in the `requestLocationUpdates` answer block. The `FusedLocationProviderClient` equivalent:

1. Add imports:
   ```kotlin
   import app.dqxn.android.sdk.contracts.testing.DataProviderContractTest
   import app.dqxn.android.sdk.contracts.provider.DataProvider
   import com.google.android.gms.location.FusedLocationProviderClient
   import com.google.android.gms.location.LocationCallback
   import com.google.android.gms.location.LocationResult
   import android.location.Location
   import io.mockk.slot
   ```

2. Change class declaration to: `class SolarLocationDataProviderTest : DataProviderContractTest()`.

3. Create eagerly initialized mocks (must fire before parent `@BeforeEach`):
   ```kotlin
   private val callbackSlot = slot<LocationCallback>()

   private val mockLocation: Location = mockk(relaxed = true) {
     every { latitude } returns 51.5074  // London
     every { longitude } returns -0.1278
   }

   private val fusedClient: FusedLocationProviderClient = mockk<FusedLocationProviderClient>(relaxed = true).also { client ->
     every {
       client.requestLocationUpdates(any(), capture(callbackSlot), any<Looper>())
     } answers {
       val callback = callbackSlot.captured
       val result = mockk<LocationResult>(relaxed = true) {
         every { lastLocation } returns mockLocation
       }
       callback.onLocationResult(result)
       mockk(relaxed = true)  // Returns Task<Void>
     }
   }
   ```

   Add `import android.os.Looper` if not already present.

4. Change `createProvider()` to:
   ```kotlin
   override fun createProvider(): DataProvider<*> =
     SolarLocationDataProvider(context = mockContext, fusedClient = fusedClient)
   ```

5. Keep all 7 existing provider-specific tests. They use `createProvider()` which now returns the updated constructor form.

**Key concern — contract test #1 (emits within firstEmissionTimeout):** `SolarLocationDataProvider.provideState()` uses `callbackFlow` with `fusedClient.requestLocationUpdates(...)`. The mock auto-fires `onLocationResult` synchronously in the `answers` block, which calls `trySend(SolarSnapshot(...))`. This delivers the first emission immediately. `firstEmissionTimeout` is 5.minutes — more than enough.

**Key concern — contract test #4 (cancellation):** The `callbackFlow`'s `awaitClose { fusedClient.removeLocationUpdates(callback) }` handles cancellation. The mock is relaxed, so `removeLocationUpdates` is a no-op.

**Key concern — contract test #12 (concurrent collectors):** Two concurrent `provideState()` calls each create their own `callbackFlow` + `requestLocationUpdates`. Both fire synchronously. Both emit. Both `take(1)` complete.

After implementation, run the full test suite:
```bash
cd android && ./gradlew :pack:essentials:testDebugUnitTest --console=plain
```

Verify that both test classes show 12 inherited + N provider-specific tests passing. The expected test counts:
- SolarTimezoneDataProviderTest: 12 contract + 8 specific = 20 tests
- SolarLocationDataProviderTest: 12 contract + 7 specific = 19 tests
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :pack:essentials:testDebugUnitTest --tests "*.SolarTimezoneDataProviderTest" --tests "*.SolarLocationDataProviderTest" --console=plain 2>&amp;1 | tail -20</automated>
  </verify>
  <done>
    - SolarLocationDataProviderTest extends DataProviderContractTest with mocked FusedLocationProviderClient
    - All 12 contract tests pass for SolarTimezoneDataProvider
    - All 12 contract tests pass for SolarLocationDataProvider
    - All existing provider-specific tests still pass for both providers
    - Full :pack:essentials test suite passes
  </done>
</task>

</tasks>

<verification>
1. `./gradlew :pack:essentials:testDebugUnitTest --console=plain` — full pack test suite green
2. `./gradlew :pack:essentials:testDebugUnitTest --tests "*.SolarTimezoneDataProviderTest"` — 20 tests (12 contract + 8 specific)
3. `./gradlew :pack:essentials:testDebugUnitTest --tests "*.SolarLocationDataProviderTest"` — 19 tests (12 contract + 7 specific)
4. `./gradlew :pack:essentials:compileDebugKotlin --console=plain` — production code compiles with injected FusedLocationProviderClient
5. `./gradlew test --console=plain` — full project regression (existing 400+ tests still pass)
</verification>

<success_criteria>
- SC1 status changes from PARTIAL to VERIFIED: all 9 typed data providers pass DataProviderContractTest
- SolarTimezoneDataProviderTest extends DataProviderContractTest, `createProvider()` is public override
- SolarLocationDataProviderTest extends DataProviderContractTest, `createProvider()` is public override
- SolarLocationDataProvider constructor accepts injectable FusedLocationProviderClient
- SolarLocationModule provides FusedLocationProviderClient via Hilt @Provides
- All existing provider-specific tests preserved and passing
- No regression in other pack tests
</success_criteria>

<output>
After completion, create `.planning/phases/08-essentials-pack/08-10-SUMMARY.md`
</output>
