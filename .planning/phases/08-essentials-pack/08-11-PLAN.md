---
phase: 08-essentials-pack
plan: 11
type: execute
wave: 1
depends_on: []
files_modified:
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/command/DashboardCommandBus.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/DashboardViewModel.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/DashboardViewModelTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/command/DashboardCommandBusTest.kt
  - android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/AddWidgetHandler.kt
  - android/app/src/test/kotlin/app/dqxn/android/debug/handlers/AddWidgetHandlerTest.kt
autonomous: true
gap_closure: true
requirements:
  - F5.1
  - F5.2
  - F5.3
  - F5.4
  - F5.5
  - F5.6
  - F5.7
  - F5.8
  - F5.9
  - F5.10
  - F5.11
  - NF14
  - NF40
  - NF-I2
  - NF-P1

must_haves:
  truths:
    - "AddWidgetHandler dispatches DashboardCommand.AddWidget through DashboardCommandBus to LayoutCoordinator, placing the widget on the canvas"
    - "DashboardCommandBus relays commands from singleton-scoped callers into the ViewModel's sequential command channel"
    - "dump-health returns ACTIVE status for widgets added via add-widget agentic command"
  artifacts:
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/command/DashboardCommandBus.kt"
      provides: "Singleton-scoped command relay between AgenticContentProvider and DashboardViewModel"
      exports: ["DashboardCommandBus"]
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/command/DashboardCommandBusTest.kt"
      provides: "Unit tests for emit/collect, multiple subscribers, buffer overflow"
    - path: "android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/AddWidgetHandler.kt"
      provides: "Agentic add-widget handler that constructs DashboardWidgetInstance and dispatches via bus"
  key_links:
    - from: "AddWidgetHandler"
      to: "DashboardCommandBus"
      via: "@Inject constructor + suspend dispatch()"
      pattern: "commandBus\\.dispatch"
    - from: "DashboardViewModel init"
      to: "DashboardCommandBus.commands"
      via: "viewModelScope.launch { commandBus.commands.collect }"
      pattern: "commandBus\\.commands\\.collect"
    - from: "DashboardCommandBus.dispatch"
      to: "DashboardViewModel.routeCommand"
      via: "SharedFlow -> commandChannel.send -> routeCommand"
---

<objective>
Wire AddWidgetHandler to dispatch DashboardCommand.AddWidget through a singleton-scoped DashboardCommandBus, bridging the AgenticContentProvider (SingletonComponent) to DashboardViewModel (ViewModelRetainedComponent). This closes SC3 from 08-VERIFICATION.md: on-device `add-widget` + `dump-health` shows ACTIVE widgets.

Purpose: Without this bridge, the `add-widget` agentic command only validates typeId but never places widgets on the canvas. The structural problem is that `AddWidgetHandler` runs in SingletonComponent scope while `DashboardViewModel` lives in ViewModelRetainedComponent -- no direct injection path exists. The bus provides a decoupled relay.

Output: DashboardCommandBus class, updated AddWidgetHandler with canvas placement, updated DashboardViewModel with bus collection, and tests for all three.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-essentials-pack/08-VERIFICATION.md
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/DashboardViewModel.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/command/DashboardCommand.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/di/DashboardModule.kt
@android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/DashboardViewModelTest.kt
@android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/AddWidgetHandler.kt
@android/app/src/test/kotlin/app/dqxn/android/debug/handlers/AddWidgetHandlerTest.kt
@android/data/src/main/kotlin/app/dqxn/android/data/layout/DashboardWidgetInstance.kt
@android/data/src/main/kotlin/app/dqxn/android/data/layout/GridTypes.kt
@android/sdk/contracts/src/main/kotlin/app/dqxn/android/sdk/contracts/widget/WidgetSpec.kt
@android/sdk/contracts/src/main/kotlin/app/dqxn/android/sdk/contracts/widget/WidgetDefaults.kt
@android/sdk/contracts/src/main/kotlin/app/dqxn/android/sdk/contracts/widget/WidgetStyle.kt
@android/sdk/contracts/src/main/kotlin/app/dqxn/android/sdk/contracts/widget/WidgetContext.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DashboardCommandBus and wire into DashboardViewModel</name>
  <files>
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/command/DashboardCommandBus.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/DashboardViewModel.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/command/DashboardCommandBusTest.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/DashboardViewModelTest.kt
  </files>
  <action>
**1. Create `DashboardCommandBus.kt`:**

Path: `android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/command/DashboardCommandBus.kt`
Package: `app.dqxn.android.feature.dashboard.command`

```kotlin
@Singleton
public class DashboardCommandBus @Inject constructor() {
    private val _commands = MutableSharedFlow<DashboardCommand>(
        extraBufferCapacity = 64,
        onBufferOverflow = BufferOverflow.DROP_OLDEST,
    )
    public val commands: SharedFlow<DashboardCommand> = _commands.asSharedFlow()

    public suspend fun dispatch(command: DashboardCommand) {
        _commands.emit(command)
    }
}
```

Imports: `javax.inject.Inject`, `javax.inject.Singleton`, `kotlinx.coroutines.channels.BufferOverflow`, `kotlinx.coroutines.flow.MutableSharedFlow`, `kotlinx.coroutines.flow.SharedFlow`, `kotlinx.coroutines.flow.asSharedFlow`.

The class is `@Singleton` so it lives in SingletonComponent, reachable by both AddWidgetHandler and DashboardViewModel. `MutableSharedFlow` with `extraBufferCapacity = 64` and `DROP_OLDEST` ensures non-blocking emission even if the ViewModel is temporarily not collecting. No `replay` -- commands should not be replayed to late collectors.

**2. Wire into DashboardViewModel:**

Add `DashboardCommandBus` as a constructor parameter (param 16, after `errorReporter`, before `): ViewModel()`):

```kotlin
private val commandBus: DashboardCommandBus,
```

In the `init` block, AFTER the existing `viewModelScope.launch { for (command in commandChannel) ... }` block (the sequential command processing loop ending around line 110) and BEFORE the `// Auto-bind new widgets when layout changes` comment (line 112), add:

```kotlin
    // Relay external commands from singleton-scoped bus into sequential channel
    viewModelScope.launch {
        commandBus.commands.collect { command ->
            commandChannel.send(command)
        }
    }
```

This funnels bus commands through the existing sequential `commandChannel` processing loop, preserving ordering guarantees and the try/catch error handling. Commands from the bus are interleaved with commands from `dispatch()` -- both enter the same channel.

**3. Create `DashboardCommandBusTest.kt`:**

Path: `android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/command/DashboardCommandBusTest.kt`
Package: `app.dqxn.android.feature.dashboard.command`

Test class with `@Tag("fast")`, JUnit5, using `StandardTestDispatcher` and `runTest`:

- **`emitted command is received by collector`**: Launch a collector on `bus.commands`, emit `DashboardCommand.EnterEditMode`, assert collector receives it. Use Turbine `bus.commands.test { }`.

- **`multiple collectors receive the same command`**: Launch two Turbine test blocks on `bus.commands`, emit one command, both receive it. (Or use two collectors in separate coroutines and assert both collect.)

- **`commands are not replayed to late subscribers`**: Emit a command, THEN start a new collector. Assert the new collector does NOT receive the already-emitted command (use Turbine `expectNoEvents()` or `ensureAllEventsConsumed()`).

- **`buffer overflow drops oldest without blocking`**: Emit 65 commands (one more than buffer capacity of 64) without any collector. Then start a collector and emit one final command -- collector receives the final command. (This tests that emission doesn't suspend/block even when no one is collecting and buffer overflows.)

Use `app.dqxn.android.feature.dashboard.command.DashboardCommand` for test commands. Use `DashboardCommand.EnterEditMode` and `DashboardCommand.ExitEditMode` as simple test commands (no arguments needed).

**4. Update `DashboardViewModelTest.kt`:**

Add `DashboardCommandBus` to the `createViewModel()` helper. Since `DashboardCommandBus` has no dependencies (empty `@Inject constructor`), instantiate a real instance -- no mocking needed:

In `createViewModel(mocks)`:
```kotlin
commandBus = DashboardCommandBus(),
```

Add `DashboardCommandBus` to the `Mocks` data class, or pass it separately. Since it's a concrete no-arg class, simplest approach is to create it inline in `createViewModel`.

Add one new test:

- **`command dispatched through bus routes to coordinator`**: Create a ViewModel with a `DashboardCommandBus` instance. Call `commandBus.dispatch(DashboardCommand.EnterEditMode)` (suspend -- wrap in `launch`). `advanceUntilIdle()`. Verify `editModeCoordinator.enterEditMode()` was called. This proves the bus->channel->routeCommand pipeline works.

**CRITICAL:** The `DashboardViewModel` constructor now has 16 params. The test's `createViewModel` must add `commandBus` to match. Update both the call site and the `Mocks` data class if the bus is stored there, OR just create it inline. The latter is simpler since the bus is stateless and cheap.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.DashboardCommandBusTest" --tests "*.DashboardViewModelTest" --console=plain 2>&1 | tail -30</automated>
  </verify>
  <done>
    DashboardCommandBus exists as @Singleton with MutableSharedFlow relay. DashboardViewModel collects from bus and funnels into commandChannel. DashboardCommandBusTest has 4 tests (emit/collect, multi-subscriber, no-replay, buffer-overflow). DashboardViewModelTest has new test proving bus commands route to coordinators. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update AddWidgetHandler to construct DashboardWidgetInstance and dispatch via bus</name>
  <files>
    android/app/src/debug/kotlin/app/dqxn/android/debug/handlers/AddWidgetHandler.kt
    android/app/src/test/kotlin/app/dqxn/android/debug/handlers/AddWidgetHandlerTest.kt
  </files>
  <action>
**1. Update `AddWidgetHandler.kt`:**

Add `DashboardCommandBus` as a constructor parameter:

```kotlin
internal class AddWidgetHandler
@Inject
constructor(
    private val widgets: Set<@JvmSuppressWildcards WidgetRenderer>,
    private val commandBus: DashboardCommandBus,
) : CommandHandler {
```

`DashboardCommandBus` is `@Singleton` and `AddWidgetHandler` is bound in SingletonComponent (via KSP-generated AgenticHiltModule), so Dagger can inject it.

In `execute()`, after `val widgetId = ...` line and before building the JSON response, add:

```kotlin
    // Construct widget instance with renderer defaults
    val defaults = renderer.getDefaults(WidgetContext.DEFAULT)
    val instance = DashboardWidgetInstance(
        instanceId = widgetId,
        typeId = renderer.typeId,
        position = GridPosition(col = 0, row = 0),
        size = GridSize(widthUnits = defaults.widthUnits, heightUnits = defaults.heightUnits),
        style = WidgetStyle.Default,
        settings = persistentMapOf(),
        dataSourceBindings = persistentMapOf(),
        zIndex = 0,
    )

    // Dispatch to dashboard via singleton command bus
    commandBus.dispatch(
        DashboardCommand.AddWidget(widget = instance, traceId = commandId),
    )
```

New imports needed:
- `app.dqxn.android.data.layout.DashboardWidgetInstance`
- `app.dqxn.android.data.layout.GridPosition`
- `app.dqxn.android.data.layout.GridSize`
- `app.dqxn.android.sdk.contracts.widget.WidgetContext`
- `app.dqxn.android.sdk.contracts.widget.WidgetStyle`
- `app.dqxn.android.feature.dashboard.command.DashboardCommand`
- `app.dqxn.android.feature.dashboard.command.DashboardCommandBus`
- `kotlinx.collections.immutable.persistentMapOf`

The existing JSON response stays as-is -- the caller (adb agentic command) gets the widgetId back immediately while the command asynchronously flows through the bus to the ViewModel.

**2. Update `AddWidgetHandlerTest.kt`:**

The handler now requires `DashboardCommandBus` in its constructor. Create a real `DashboardCommandBus()` instance (no mock needed -- it's a concrete class with no deps).

Update `AddWidgetHandler` construction in the test:
```kotlin
private val commandBus = DashboardCommandBus()
private val handler = AddWidgetHandler(fakeWidgets, commandBus)
```

Add a Turbine collector test:

- **`successful add dispatches AddWidget command to bus`**: Start a Turbine test on `commandBus.commands`. Execute `handler.execute(params with typeId "essentials:clock", "cmd-1")`. Assert the bus emits a `DashboardCommand.AddWidget` where:
  - `widget.typeId == "essentials:clock"`
  - `widget.instanceId` starts with `"widget-"`
  - `widget.position == GridPosition(col = 0, row = 0)`
  - `widget.size == GridSize(widthUnits = 4, heightUnits = 4)` (matching StubRenderer defaults)
  - `widget.style == WidgetStyle.Default`
  - `traceId == "cmd-1"` (the commandId parameter)

- **`error cases do not dispatch to bus`**: Execute with unknown typeId. Assert `commandBus.commands` does NOT emit (use Turbine `expectNoEvents()` or verify flow is empty). Same for missing typeId.

All existing tests should continue passing since the JSON response shape is unchanged. The only functional change is that a command is now dispatched before the JSON is returned.

**Import additions for test file:**
- `app.dqxn.android.feature.dashboard.command.DashboardCommandBus`
- `app.dqxn.android.feature.dashboard.command.DashboardCommand`
- `app.dqxn.android.data.layout.GridPosition`
- `app.dqxn.android.data.layout.GridSize`
- `app.dqxn.android.sdk.contracts.widget.WidgetStyle`
- `app.turbine.test` (Turbine)
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :app:testDebugUnitTest --tests "*.AddWidgetHandlerTest" --console=plain 2>&1 | tail -30</automated>
  </verify>
  <done>
    AddWidgetHandler constructs DashboardWidgetInstance from renderer defaults and dispatches DashboardCommand.AddWidget via DashboardCommandBus. Existing validation tests pass. New tests verify bus dispatch on success and no dispatch on error. The `add-widget` agentic command now places widgets on the canvas when DashboardViewModel is active.
  </done>
</task>

</tasks>

<verification>
**Compile check:**
```bash
cd android && ./gradlew :feature:dashboard:compileDebugKotlin :app:compileDebugKotlin --console=plain
```

**Full test suite:**
```bash
cd android && ./gradlew :feature:dashboard:testDebugUnitTest :app:testDebugUnitTest --console=plain
```

**Regression gate (Phase 2-8 tests):**
```bash
cd android && ./gradlew test --console=plain
```

**On-device (if available):**
```bash
cd android && ./gradlew :app:installDebug && \
  adb shell content call --uri content://app.dqxn.android.debug.agentic --method add-widget --arg '{"typeId":"essentials:clock-digital"}' && \
  sleep 2 && \
  adb shell content call --uri content://app.dqxn.android.debug.agentic --method dump-health
```
Expected: dump-health shows 1 widget with ACTIVE status.
</verification>

<success_criteria>
1. `DashboardCommandBus` exists as `@Singleton` with `MutableSharedFlow<DashboardCommand>`
2. `DashboardViewModel` collects from `DashboardCommandBus.commands` and sends into `commandChannel`
3. `AddWidgetHandler` constructs `DashboardWidgetInstance` using renderer defaults and dispatches via bus
4. `DashboardCommandBusTest` passes (4 tests: emit/collect, multi-subscriber, no-replay, buffer-overflow)
5. `DashboardViewModelTest` passes including new bus relay test
6. `AddWidgetHandlerTest` passes including new dispatch verification tests
7. All existing Phase 2-8 tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/08-essentials-pack/08-11-SUMMARY.md`
</output>
