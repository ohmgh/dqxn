---
phase: 08-essentials-pack
plan: 04
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarCalculator.kt
  - android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/IanaTimezoneCoordinates.kt
  - android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarTimezoneDataProvider.kt
  - android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarLocationDataProvider.kt
  - android/pack/essentials/src/test/kotlin/app/dqxn/android/pack/essentials/providers/SolarCalculatorTest.kt
  - android/pack/essentials/src/test/kotlin/app/dqxn/android/pack/essentials/providers/SolarTimezoneDataProviderTest.kt
  - android/pack/essentials/src/test/kotlin/app/dqxn/android/pack/essentials/providers/SolarLocationDataProviderTest.kt
autonomous: true
requirements:
  - F5.9

must_haves:
  truths:
    - "SolarCalculator computes sunrise/sunset within 2 minutes of NOAA reference data"
    - "SolarTimezoneDataProvider emits solar times using timezone-derived coordinates without GPS"
    - "SolarLocationDataProvider emits solar times using passive GPS location"
    - "IanaTimezoneCoordinates resolves timezone aliases before lookup"
  artifacts:
    - path: "android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarCalculator.kt"
      provides: "Meeus/NOAA solar position algorithm"
      contains: "toJulianDay"
    - path: "android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/IanaTimezoneCoordinates.kt"
      provides: "312-entry IANA timezone to lat/lon lookup"
      contains: "getCanonicalID"
    - path: "android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarTimezoneDataProvider.kt"
      provides: "No-permission solar data provider"
      contains: "@DashboardDataProvider"
  key_links:
    - from: "android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarTimezoneDataProvider.kt"
      to: "SolarCalculator"
      via: "uses calculator for sunrise/sunset"
      pattern: "SolarCalculator"
    - from: "android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarLocationDataProvider.kt"
      to: "FusedLocationProviderClient"
      via: "passive GPS for coordinates"
      pattern: "PASSIVE"
---

<objective>
Implement the solar calculation subsystem: SolarCalculator algorithm, IanaTimezoneCoordinates data table, and both solar data providers.

Purpose: Solar is the riskiest port in Phase 8 — the Meeus/NOAA algorithm has precision requirements that affect theme auto-switch timing. Two providers serve different use cases: SolarTimezoneDataProvider works without GPS (no permissions), SolarLocationDataProvider uses passive GPS for higher accuracy. This plan isolates the risk.

Output: SolarCalculator (pure Kotlin algorithm), IanaTimezoneCoordinates (312-entry table), 2 solar providers with precision-validated tests.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-essentials-pack/08-RESEARCH.md
@.planning/phases/08-essentials-pack/08-01-SUMMARY.md
@android/sdk/contracts/src/testFixtures/kotlin/app/dqxn/android/sdk/contracts/testing/DataProviderContractTest.kt
@.planning/oldcodebase/packs.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Port SolarCalculator, IanaTimezoneCoordinates, and implement solar providers</name>
  <files>
    android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarCalculator.kt
    android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/IanaTimezoneCoordinates.kt
    android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarTimezoneDataProvider.kt
    android/pack/essentials/src/main/kotlin/app/dqxn/android/pack/essentials/providers/SolarLocationDataProvider.kt
  </files>
  <action>
    **SolarCalculator** — port from old codebase (`../dqxn.old/android/`). Read the actual old source file.
    - Package: `app.dqxn.android.pack.essentials.providers`
    - Pure Kotlin object, no Android dependencies
    - Core functions: `toJulianDay(year, month, day)`, `solarDeclination(julianCenturies)`, `equationOfTime(julianCenturies)`, `sunriseMinutesUTC(jd, latitude, longitude)`, `sunsetMinutesUTC(jd, latitude, longitude)`, `solarNoonMinutesUTC(jd, longitude)`
    - `fun calculate(latitude: Double, longitude: Double, date: LocalDate, zoneId: ZoneId): SolarResult` returning `SolarResult(sunriseEpochMillis, sunsetEpochMillis, solarNoonEpochMillis, isDaytime)`
    - Handle polar edge cases: when latitude > ~66.5 and date is near solstice, sunrise/sunset may not exist. Return `Long.MIN_VALUE` for missing events. `isDaytime` still computable from solar noon.
    - `minutesToLocalTime(minutes: Double, date: LocalDate, zone: ZoneId): Long` — convert UTC minutes-of-day to epoch millis. Guard against negative values and values >= 1440.
    - Port VERBATIM — do not rewrite the algorithm. Precision matters for theme auto-switch.

    **IanaTimezoneCoordinates** — port from old codebase:
    - Object with `fun getCoordinates(timezoneId: String): Pair<Double, Double>?` returning (latitude, longitude) or null
    - 312-entry map from IANA zone1970.tab data
    - Before lookup, resolve aliases via `android.icu.util.TimeZone.getCanonicalID(timezoneId)` — handles "Asia/Saigon" → "Asia/Ho_Chi_Minh", "US/Eastern" → "America/New_York", etc.
    - If `getCanonicalID` returns null or same string (no alias), use original
    - Port the data table verbatim from old codebase. Spot-check: "Asia/Singapore" → (1.2833, 103.8333), "America/New_York" → (40.7128, -74.0060)

    **SolarTimezoneDataProvider** — port from old:
    - `@DashboardDataProvider(localId = "solar-timezone", displayName = "Solar (Timezone)", description = "Sunrise and sunset times based on timezone location")`
    - Priority `DEVICE_SENSOR`, no permissions needed
    - `provideState()`: `flow` that emits `SolarSnapshot` based on `IanaTimezoneCoordinates.getCoordinates(TimeZone.getDefault().id)` + `SolarCalculator.calculate()`
    - Recalculate on timezone change (register `BroadcastReceiver` for `ACTION_TIMEZONE_CHANGED`)
    - Also recalculate at midnight (schedule next recalc via `delay()` until midnight)
    - sourceMode = "timezone"
    - If timezone has no coordinates entry, emit fallback (0,0 equatorial — always has sunrise/sunset)

    **SolarLocationDataProvider** — port from old:
    - `@DashboardDataProvider(localId = "solar-location", displayName = "Solar (Location)", description = "Sunrise and sunset times based on GPS location")`
    - Priority `HARDWARE`, requires `ACCESS_COARSE_LOCATION`
    - `@Inject constructor(@param:ApplicationContext context: Context)` — uses `FusedLocationProviderClient` with `PASSIVE` priority (piggybacks on other apps' GPS requests)
    - `provideState()`: `callbackFlow` with `LocationCallback` from play-services-location
    - `LocationRequest` with `PRIORITY_PASSIVE`, interval 30 minutes (solar doesn't need frequent updates)
    - On each location update, recalculate via `SolarCalculator.calculate()`
    - sourceMode = "location"
    - setupSchema: `RuntimePermission(permissions = listOf(ACCESS_COARSE_LOCATION))`
    - `awaitClose { fusedClient.removeLocationUpdates(callback) }`
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :pack:essentials:compileDebugKotlin --console=plain 2>&1 | tail -5</automated>
  </verify>
  <done>SolarCalculator, IanaTimezoneCoordinates, and both solar providers compile. SolarCalculator is ported verbatim with polar edge case guards. IanaTimezoneCoordinates resolves aliases via ICU. SolarLocationDataProvider uses FusedLocation PASSIVE priority.</done>
</task>

<task type="auto">
  <name>Task 2: Solar precision tests and provider contract tests</name>
  <files>
    android/pack/essentials/src/test/kotlin/app/dqxn/android/pack/essentials/providers/SolarCalculatorTest.kt
    android/pack/essentials/src/test/kotlin/app/dqxn/android/pack/essentials/providers/SolarTimezoneDataProviderTest.kt
    android/pack/essentials/src/test/kotlin/app/dqxn/android/pack/essentials/providers/SolarLocationDataProviderTest.kt
  </files>
  <action>
    **SolarCalculatorTest** (JUnit5, pure algorithm — no mocks needed):
    - **NOAA reference data validation** — these are the load-bearing tests:
      - London (51.5074°N, -0.1278°W), Summer Solstice 2025 (June 21): sunrise ~04:43, sunset ~21:21 UTC. Assert within 2 minutes.
      - London, Winter Solstice 2025 (Dec 21): sunrise ~08:03, sunset ~15:51 UTC. Assert within 2 minutes.
      - Singapore (1.3521°N, 103.8198°E), Equinox 2025 (March 20): sunrise ~23:01 UTC (07:01 SGT), sunset ~11:11 UTC (19:11 SGT). Assert within 2 minutes.
      - Equatorial location (0°, 0°): always has sunrise and sunset. Verify both are non-MIN_VALUE.
    - `toJulianDay` validation: 2000-01-01 → 2451545.0 (J2000.0 epoch). Verify exact.
    - `minutesToLocalTime` edge cases: 0 minutes (midnight), 1439 minutes (23:59), fractional minutes, negative (should clamp to 0)
    - Polar edge case: Tromso (69.65°N), June 21 — midnight sun, sunrise may be MIN_VALUE. Verify no crash, `isDaytime = true`.
    - Polar edge case: Tromso, December 21 — polar night. Verify no crash.

    **SolarTimezoneDataProviderTest** — extends `DataProviderContractTest`:
    - Mock `IanaTimezoneCoordinates` to return known coordinates
    - Override `createProvider()` with injectable dependencies
    - Provider-specific: verify `sourceMode = "timezone"` in emitted snapshot
    - Verify recalculation on timezone change broadcast

    **SolarLocationDataProviderTest** — extends `DataProviderContractTest`:
    - Mock `FusedLocationProviderClient`, capture `LocationCallback`, simulate location update
    - Provider-specific: verify `sourceMode = "location"` in emitted snapshot
    - Verify `PRIORITY_PASSIVE` in LocationRequest
    - Verify `awaitClose` removes location updates
    - setupSchema contains RuntimePermission for ACCESS_COARSE_LOCATION
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :pack:essentials:testDebugUnitTest --tests "*.SolarCalculator*" --tests "*.Solar*DataProvider*" --console=plain 2>&1 | tail -15</automated>
  </verify>
  <done>SolarCalculator within 2 minutes of NOAA reference for 3 locations across 4 dates. Julian day exact at J2000.0. Polar edge cases don't crash. Both solar providers pass contract tests. Timezone provider recalculates on zone change. Location provider uses PASSIVE priority.</done>
</task>

</tasks>

<verification>
1. `./gradlew :pack:essentials:testDebugUnitTest --tests "*.Solar*" --console=plain` — all solar tests pass
2. SolarCalculator precision: within 2 minutes of NOAA reference data
3. No crashes at polar edge cases (midnight sun, polar night)
4. Both providers pass DataProviderContractTest
5. IanaTimezoneCoordinates resolves known aliases
</verification>

<success_criteria>
- SolarCalculator produces sunrise/sunset within 2 minutes of NOAA reference for London and Singapore
- Polar edge cases (Tromso) handled without crash
- toJulianDay(2000-01-01) returns exactly 2451545.0
- Both solar providers pass 12 DataProviderContractTest assertions
- SolarTimezoneDataProvider works without any permissions
- SolarLocationDataProvider uses PASSIVE priority GPS
</success_criteria>

<output>
After completion, create `.planning/phases/08-essentials-pack/08-04-SUMMARY.md`
</output>
