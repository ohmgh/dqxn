---
phase: 13-e2e-integration-launch-polish
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - android/app/src/androidTest/kotlin/app/dqxn/android/e2e/AgenticTestClient.kt
  - android/app/src/androidTest/kotlin/app/dqxn/android/e2e/ChaosCorrelationE2ETest.kt
  - android/app/src/androidTest/kotlin/app/dqxn/android/e2e/MultiPackE2ETest.kt
  - android/app/src/test/kotlin/app/dqxn/android/app/integration/MultiPackHiltTest.kt
autonomous: true
requirements:
  - NF24
  - NF25
  - NF26

must_haves:
  truths:
    - "Deterministic chaos seed=42 produces correlated diagnostics via agentic protocol"
    - "All 3 packs (essentials + themes + demo) load without Hilt binding conflicts"
    - "Set<WidgetRenderer>, Set<DataProvider<*>>, Set<ThemeProvider>, Set<DashboardPackManifest> contain expected counts"
    - "App functions with all local sensor data (NF24/25/26 -- no internet dependency for core dashboard)"
  artifacts:
    - path: "android/app/src/androidTest/kotlin/app/dqxn/android/e2e/ChaosCorrelationE2ETest.kt"
      provides: "Deterministic chaos CI gate test"
    - path: "android/app/src/test/kotlin/app/dqxn/android/app/integration/MultiPackHiltTest.kt"
      provides: "Hilt binding validation for all 3 packs"
  key_links:
    - from: "ChaosCorrelationE2ETest"
      to: "ChaosEngine"
      via: "agentic chaos-start command with seed=42"
      pattern: "chaos-start.*seed.*42"
    - from: "MultiPackHiltTest"
      to: "Set<WidgetRenderer>"
      via: "Hilt injection"
      pattern: "Set<WidgetRenderer>|Set<DataProvider|Set<ThemeProvider>"
---

<objective>
Deterministic chaos CI gate and multi-pack Hilt binding validation.

Purpose: SC2 requires deterministic chaos (seed=42) producing correlated diagnostics. SC3 requires essentials + themes + demo loaded simultaneously without conflicts. Compilation alone isn't sufficient for SC3 -- need explicit binding count validation to catch missing/duplicate registrations.

Output: ChaosCorrelationE2ETest (instrumented), MultiPackHiltTest (Hilt integration), MultiPackE2ETest (instrumented).
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-e2e-integration-launch-polish/13-RESEARCH.md
@android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/ChaosEngine.kt
@android/core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/chaos/ChaosProviderInterceptor.kt
@android/app/build.gradle.kts
</context>

<tasks>

<task type="auto">
  <name>Task 1: MultiPackHiltTest â€” Hilt binding validation for all 3 packs</name>
  <files>
    android/app/src/test/kotlin/app/dqxn/android/app/integration/MultiPackHiltTest.kt
  </files>
  <action>
    1. **MultiPackHiltTest** (JUnit4 + `@HiltAndroidTest` + Robolectric):
       - This is a Hilt integration test that verifies all multibinding sets resolve correctly when all 3 packs are on the classpath.
       - `@HiltAndroidTest` + `@RunWith(RobolectricTestRunner::class)` for JVM-based Hilt validation.
       - `@get:Rule val hiltRule = HiltAndroidRule(this)`
       - `@Inject lateinit var widgetRenderers: Set<@JvmSuppressWildcards WidgetRenderer>`
       - `@Inject lateinit var dataProviders: Set<@JvmSuppressWildcards DataProvider<*>>`
       - `@Inject lateinit var themeProviders: Set<@JvmSuppressWildcards ThemeProvider>`
       - `@Inject lateinit var packManifests: Set<@JvmSuppressWildcards DashboardPackManifest>`
       - Tests:
         - `widgetRenderers is not empty` -- verify >= 13 (essentials pack widget count)
         - `dataProviders is not empty` -- verify >= 9 (essentials) + 8 (demo) = 17+ providers
         - `themeProviders is not empty` -- verify >= 2 (essentials + themes pack providers)
         - `packManifests has all 3 packs` -- assert manifests contain packIds "essentials", "themes", "demo"
         - No duplicate typeIds: `widgetRenderers.map { it.typeId }.let { assertThat(it).containsNoDuplicates() }`
         - No duplicate providerIds: `dataProviders.map { it.spec.providerId }.let { assertThat(it).containsNoDuplicates() }`
       - NOTE: If Robolectric + Hilt test cannot inject multibindings (depends on dagger-hilt test support library), use `@HiltAndroidTest` with `HiltTestApplication` via `@Config(application = HiltTestApplication::class)`.
       - Add `testImplementation(libs.hilt.android.testing)` and `kspTest(libs.hilt.compiler)` to `:app` build.gradle.kts if not already present.
  </action>
  <verify>
    <automated>cd android && ./gradlew :app:testDebugUnitTest --tests "*.MultiPackHiltTest" --console=plain 2>&1 | tail -10</automated>
  </verify>
  <done>MultiPackHiltTest validates all 3 packs contribute to Hilt multibinding sets with correct counts, no duplicate typeIds, no duplicate providerIds.</done>
</task>

<task type="auto">
  <name>Task 2: ChaosCorrelationE2ETest + MultiPackE2ETest (instrumented)</name>
  <files>
    android/app/src/androidTest/kotlin/app/dqxn/android/e2e/ChaosCorrelationE2ETest.kt
    android/app/src/androidTest/kotlin/app/dqxn/android/e2e/MultiPackE2ETest.kt
  </files>
  <action>
    1. **ChaosCorrelationE2ETest** (JUnit4 instrumented test):
       - Uses `AgenticTestClient` from Plan 13-04. If Plan 13-04 hasn't executed yet (wave dependency), include a minimal inline `AgenticTestClient` helper that can be replaced. Since this plan is Wave 1 and 13-04 is Wave 2, we need a self-contained version here.
       - Define a local `AgenticTestClient` class if the shared one from 13-04 doesn't exist yet (duplicate will be reconciled when 13-04 lands -- or move to shared location).
       - Actually, since both plans write to `app/src/androidTest/`, and this plan is Wave 1 while 13-04 is Wave 2: create `AgenticTestClient.kt` HERE in this plan so 13-04 can just USE it. Adjust Plan 04's dependency or have it reference the already-created file.
       - **AgenticTestClient**: Same implementation as specified in Plan 13-04 Task 1 (send, assertWidgetRendered, awaitCondition). Create it here since this is Wave 1.
       - **Test: deterministic chaos correlation** (`@Test fun chaosCorrelationSeed42()`):
         - Wait for app ready: `client.send("ping")`
         - Start chaos: `client.send("chaos-start", mapOf("seed" to 42, "profile" to "standard"))`
         - Wait for faults to inject (poll `list-diagnostics` for non-empty results): `Thread.sleep(3000)` or better, `client.awaitCondition("list-diagnostics", "data.snapshots", /* non-empty */, timeoutMs = 10000)`
         - Query diagnostics: `val diagnostics = client.send("list-diagnostics")`
         - Assert diagnostics are not empty (chaos produced at least 1 diagnostic snapshot)
         - Stop chaos: `client.send("chaos-stop")`
         - Verify correlation: diagnostic snapshots should reference fault types from the chaos profile
       - This validates the chaos -> detect -> correlate pipeline works E2E.

    2. **MultiPackE2ETest** (JUnit4 instrumented test):
       - **Test: all packs loaded on device** (`@Test fun allPacksLoadedE2E()`):
         - `client.send("ping")`
         - `val state = client.send("dump-state")`
         - Verify state includes widget renderer count >= 13, provider count >= 17, theme count >= 24
         - Or: `client.send("list-commands")` -> verify chaos commands exist (proves demo/agentic packs loaded)
       - **Test: widget from each pack renders** (`@Test fun widgetFromEachPackRenders()`):
         - Add a widget from essentials: `client.send("add-widget", mapOf("typeId" to "essentials:clock-digital"))`
         - `client.assertWidgetRendered("...")` -- check it rendered
         - Health check: `client.awaitCondition("dump-health", ..., "ACTIVE")`
       - **Test: offline functionality (NF24/NF25/NF26)** (`@Test fun offlineFunctionality()`):
         - Enable airplane mode: `device.executeShellCommand("cmd connectivity airplane-mode enable")`
         - Wait briefly, then `client.send("ping")` -- app still responds (all local)
         - `client.send("dump-health")` -- providers that don't need internet still work (time, battery, orientation)
         - Disable airplane mode: `device.executeShellCommand("cmd connectivity airplane-mode disable")`
         - This proves NF24 (fully functional offline), NF25 (BLE no internet), NF26 (internet only for entitlements/weather)

    NOTE: These are instrumented tests -- they compile for verification, actual execution requires a device/emulator. That's fine per project policy ("connected device != manual test").
  </action>
  <verify>
    <automated>cd android && ./gradlew :app:compileDebugAndroidTestKotlin --console=plain 2>&1 | tail -5</automated>
  </verify>
  <done>ChaosCorrelationE2ETest verifies seed=42 chaos produces correlated diagnostics. MultiPackE2ETest verifies all 3 packs load on device with correct binding counts. AgenticTestClient infrastructure created for all E2E tests. Tests compile; device execution deferred to CI.</done>
</task>

</tasks>

<verification>
- `cd android && ./gradlew :app:testDebugUnitTest --tests "*.MultiPackHiltTest" --console=plain` -- Hilt binding test passes
- `cd android && ./gradlew :app:compileDebugAndroidTestKotlin --console=plain` -- E2E tests compile
- On device (when available): `cd android && ./gradlew :app:connectedDebugAndroidTest --tests "*.ChaosCorrelationE2ETest" --tests "*.MultiPackE2ETest" --console=plain`
</verification>

<success_criteria>
- MultiPackHiltTest verifies 3 packs contribute to all multibinding sets with no duplicates
- ChaosCorrelationE2ETest verifies deterministic chaos produces correlated diagnostics
- MultiPackE2ETest verifies all packs load and widgets from each pack render
- AgenticTestClient created and usable by subsequent E2E tests
- All compilable tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-e2e-integration-launch-polish/13-05-SUMMARY.md`
</output>
