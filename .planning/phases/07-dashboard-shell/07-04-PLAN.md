---
phase: 07-dashboard-shell
plan: 04
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinator.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetDataBinder.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetRegistryImpl.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/DataProviderRegistryImpl.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/StorageMonitor.kt
  - android/sdk/ui/src/main/kotlin/app/dqxn/android/sdk/ui/UnknownWidgetPlaceholder.kt
  - android/sdk/ui/src/main/kotlin/app/dqxn/android/sdk/ui/LocalWidgetPreviewUnits.kt
  - android/feature/dashboard/src/testFixtures/kotlin/app/dqxn/android/feature/dashboard/test/FakeWidgetDataBinder.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinatorTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetDataBinderTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetRegistryImplTest.kt
autonomous: true
requirements:
  - F2.4
  - F2.5
  - F2.13
  - F2.14
  - F2.19
  - F3.7
  - F3.9
  - F3.10
  - F3.11
  - F3.14
  - F3.15
  - F10.7
  - NF1
  - NF4
  - NF5
  - NF8
  - NF15
  - NF16
  - NF17
  - NF18
  - NF19
  - NF41
  - NF42

must_haves:
  truths:
    - "WidgetBindingCoordinator binds providers to widgets with SupervisorJob isolation"
    - "One widget crash does not cancel other widget bindings"
    - "Provider fallback: when assigned provider unavailable, binder falls back to next priority"
    - "Data staleness detection marks widget as stale when threshold exceeded"
    - "Exponential backoff retry: 1s, 2s, 4s with max 3 attempts"
    - "Thermal throttling reduces data emission rate under thermal pressure"
    - "WidgetRegistryImpl indexes widget renderers by typeId from Hilt Set"
    - "DataProviderRegistryImpl provides entitlement-filtered and unfiltered views"
  artifacts:
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinator.kt"
      provides: "Per-widget data binding lifecycle management"
      contains: "class WidgetBindingCoordinator"
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetDataBinder.kt"
      provides: "IoC provider-to-widget binding with merge+scan"
      contains: "class WidgetDataBinder"
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetRegistryImpl.kt"
      provides: "Widget renderer lookup by typeId"
      contains: "class WidgetRegistryImpl"
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/DataProviderRegistryImpl.kt"
      provides: "Provider lookup with entitlement filtering"
      contains: "class DataProviderRegistryImpl"
  key_links:
    - from: "WidgetBindingCoordinator"
      to: "WidgetDataBinder"
      via: "delegates actual binding to binder, manages jobs"
      pattern: "binder.*WidgetDataBinder"
    - from: "WidgetDataBinder"
      to: "DataProviderRegistryImpl"
      via: "resolves providers by data type with priority ordering"
      pattern: "providerRegistry.*DataProviderRegistry"
    - from: "WidgetBindingCoordinator"
      to: "SafeModeManager"
      via: "reports widget crashes for safe mode counting"
      pattern: "safeModeManager.*SafeModeManager"
---

<objective>
WidgetBindingCoordinator, WidgetDataBinder with SupervisorJob isolation, registry implementations, and StorageMonitor.

Purpose: The data binding pipeline is the runtime core -- it connects providers to widgets, handles failures gracefully, and enforces performance constraints. This is separated from the grid composable to enable thorough unit testing of binding, retry, fallback, and staleness logic.

Output: Complete widget data binding pipeline with SupervisorJob isolation, exponential backoff retry, provider fallback, thermal throttling, and registry implementations.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-dashboard-shell/07-RESEARCH.md
@.planning/arch/state-management.md
@.planning/migration/phase-07.md
@.planning/phases/07-dashboard-shell/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: WidgetBindingCoordinator + WidgetDataBinder + registries + StorageMonitor</name>
  <files>
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinator.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetDataBinder.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetRegistryImpl.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/DataProviderRegistryImpl.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/StorageMonitor.kt
    android/sdk/ui/src/main/kotlin/app/dqxn/android/sdk/ui/UnknownWidgetPlaceholder.kt
    android/sdk/ui/src/main/kotlin/app/dqxn/android/sdk/ui/LocalWidgetPreviewUnits.kt
    android/feature/dashboard/src/testFixtures/kotlin/app/dqxn/android/feature/dashboard/test/FakeWidgetDataBinder.kt
  </files>
  <action>
**WidgetBindingCoordinator.kt:** Package `app.dqxn.android.feature.dashboard.coordinator`. `@Inject constructor` with `binder: WidgetDataBinder`, `safeModeManager: SafeModeManager`, `entitlementManager: EntitlementManager`, `metricsCollector: MetricsCollector`, `logger: DqxnLogger`, `@param:IoDispatcher ioDispatcher: CoroutineDispatcher`, `@param:DefaultDispatcher defaultDispatcher: CoroutineDispatcher`.

Core state:
- `private val bindingSupervisor = SupervisorJob()` — parent for ALL binding jobs. One crash does NOT cancel siblings (NF19).
- `private val bindings = ConcurrentHashMap<String, Job>()` — per-widget binding jobs
- `private val _widgetData = ConcurrentHashMap<String, MutableStateFlow<WidgetData>>()` — per-widget data flows
- `private val _widgetStatuses = ConcurrentHashMap<String, MutableStateFlow<WidgetStatusCache>>()` — per-widget status

Methods:
- `initialize(scope: CoroutineScope)` — sets up bindingScope as `scope + bindingSupervisor`
- `bind(widget: DashboardWidgetInstance)` — cancels existing binding for widget, creates new job under bindingScope with `CoroutineExceptionHandler`. Handler: increments error count, if <=3 → retry with exponential backoff (1s, 2s, 4s per NF16), if >3 → mark as ProviderError with retriesExhausted. Reports crash to SafeModeManager for cross-widget counting.
- `unbind(widgetId: String)` — cancels job, removes from maps
- `rebind(widgetId: String, newProviderTypeId: String)` — change data source for a widget
- `widgetData(widgetId: String): StateFlow<WidgetData>` — returns per-widget flow. Creates empty flow if missing.
- `widgetStatus(widgetId: String): StateFlow<WidgetStatusCache>` — returns per-widget status flow
- `allStatuses(): Map<String, WidgetStatusCache>` — snapshot for diagnostics
- `pauseAll()` / `resumeAll()` — pause/resume all bindings for CPU-heavy overlays (F1.14). Cancels all jobs on pause, rebinds on resume.
- `reportCrash(widgetId: String, typeId: String)` — public method for external crash reporting (called by DashboardViewModel on WidgetCrash command). Delegates to `safeModeManager.reportCrash(widgetId, typeId)`.
- `activeBindings(): Map<String, Job>` — for test introspection

Status priority (F2.5, F3.14, F3.15): `EntitlementRevoked > ProviderMissing > SetupRequired > ConnectionError > DataTimeout > Disconnected > DataStale > Ready`. Computed in `updateStatus()` method. Each status maps to user-facing string resource IDs (F3.15 progressive error disclosure).

Entitlement reactivity (NF18): observe `entitlementManager.entitlementChanges` → re-evaluate all widgets' entitlement status.

**WidgetDataBinder.kt:** Package `app.dqxn.android.feature.dashboard.binding`. `@Inject constructor` with `providerRegistry: DataProviderRegistry`, `interceptors: Set<DataProviderInterceptor>`, `thermalMonitor: ThermalMonitor`, `logger: DqxnLogger`.

`fun bind(widget: DashboardWidgetInstance, renderConfig: StateFlow<RenderConfig>): Flow<WidgetData>` — per architecture doc:
1. For each compatible snapshot type, resolve provider via `resolveProvider(snapshotType)` with priority: user-selected > HARDWARE > DEVICE_SENSOR > NETWORK > SIMULATED (F3.10 provider fallback).
2. Apply `DataProviderInterceptor` chain (for chaos injection).
3. Throttle each provider flow by `1000L / renderConfig.value.targetFps` for thermal-aware emission (F10.7).
4. `merge()` all provider flows, `scan()` accumulate into `WidgetData` with `withSlot()`.
5. Use `WhileSubscribed(subscriberTimeout)` with per-provider timeout: 1s for clock, 5s default, 30s for GPS (F3.9, NF5).

Data staleness (F3.11): per-slot watchdog. Each snapshot type's `DataSchema.stalenessThresholdMs` checked. When exceeded, update status to DataStale.

`resolveProvider(snapshotType, userSelectedProviderId)` — priority chain. If user-selected unavailable, fallback to next by `ProviderPriority`. Notify user via transient indicator (status update).

**WidgetRegistryImpl.kt:** Package `app.dqxn.android.feature.dashboard.binding`. `@Singleton @Inject constructor` with `renderers: Set<@JvmSuppressWildcards WidgetRenderer>`. Implements `WidgetRegistry` from `:sdk:contracts`. Indexes renderers by `typeId` into `ImmutableMap`. `findByTypeId(typeId): WidgetRenderer?` — returns null for unknown types (F2.13 triggers placeholder).

**DataProviderRegistryImpl.kt:** Package `app.dqxn.android.feature.dashboard.binding`. `@Singleton @Inject constructor` with `providers: Set<@JvmSuppressWildcards DataProvider<*>>`, `entitlementManager: EntitlementManager`. Implements `DataProviderRegistry` from `:sdk:contracts`. Two views: `allProviders()` (unfiltered), `availableProviders()` (entitlement-filtered via `Gated.isAccessible`). Index by `dataType` for fast lookup.

**StorageMonitor.kt:** Package `app.dqxn.android.feature.dashboard.binding`. `@Singleton @Inject constructor` with `@param:ApplicationContext context: Context`. `val isLow: StateFlow<Boolean>` — checks `StatFs(context.dataDir.absolutePath).availableBytes < 50 * 1024 * 1024` (NF41 50MB threshold). Polled every 60 seconds via `flow { while(true) { emit(check()); delay(60_000) } }.stateIn(...)`.

**UnknownWidgetPlaceholder.kt:** In `:sdk:ui`. Package `app.dqxn.android.sdk.ui`. `@Composable fun UnknownWidgetPlaceholder(typeId: String, modifier: Modifier = Modifier)`. Renders "Unknown widget: {typeId}" with warning icon. Used when `WidgetRegistry.findByTypeId()` returns null (F2.13). Simple composable — Column with Icon + Text.

**LocalWidgetPreviewUnits.kt:** In `:sdk:ui`. Package `app.dqxn.android.sdk.ui`. `val LocalWidgetPreviewUnits = compositionLocalOf<GridSize?> { null }`. CompositionLocal providing target dimensions during resize gesture. Widgets read this for content-aware relayout (e.g., Speedometer arc angle, InfoCardLayout mode switching). Pure data definition — no logic.

**FakeWidgetDataBinder.kt:** In testFixtures. Implements `WidgetDataBinder` interface (extract interface from class if needed). Returns configurable `MutableStateFlow<WidgetData>` per widget for test control.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:compileDebugKotlin :sdk:ui:compileDebugKotlin --console=plain 2>&1 | tail -5</automated>
  </verify>
  <done>WidgetBindingCoordinator manages per-widget binding jobs with SupervisorJob isolation. WidgetDataBinder implements merge+scan binding with thermal throttling. Registries index renderers and providers. StorageMonitor checks low storage. UnknownWidgetPlaceholder and LocalWidgetPreviewUnits defined in :sdk:ui.</done>
</task>

<task type="auto">
  <name>Task 2: WidgetBindingCoordinator tests + WidgetDataBinder tests + registry tests</name>
  <files>
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinatorTest.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetDataBinderTest.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetRegistryImplTest.kt
  </files>
  <action>
**WidgetBindingCoordinatorTest.kt:** JUnit5 + `@Tag("fast")` + MockK + Turbine + `StandardTestDispatcher`. Tests:
- `bind creates job and emits widget data` — use TestDataProvider from :sdk:contracts testFixtures
- `unbind cancels job and removes data flow`
- `SupervisorJob isolation: one provider crash does not cancel sibling bindings` — bind 2 widgets, crash provider of widget A, verify widget B still receiving data (NF19)
- `exponential backoff retry: 1s, 2s, 4s` — inject ProviderFault.Error via TestDataProvider, verify retry timing with testScheduler.advanceTimeBy
- `max 3 retries then ProviderError status` — verify status transitions
- `successful emission resets error count`
- `widget crash reported to SafeModeManager`
- `pauseAll cancels all bindings, resumeAll rebinds` (F1.14)
- `entitlement revocation updates widget status` (NF18)
- `status priority ordering correct` — EntitlementRevoked > ProviderMissing > ... > Ready

**WidgetDataBinderTest.kt:** JUnit5 + `@Tag("fast")` + Turbine. Tests:
- `bind with single provider emits WidgetData with correct slot`
- `bind with multiple providers merges via scan` — 2 providers, verify both slots populated
- `merge+scan: one stuck provider does not block other slots` — provider A emits, provider B stalls, verify data has slot A
- `provider fallback: user-selected unavailable falls back to next priority` (F3.10)
- `data staleness: threshold exceeded marks slot as stale` (F3.11)
- `thermal throttling: DEGRADED config reduces emission rate` (F10.7) — use FakeThermalManager, set DEGRADED, verify fewer emissions per second
- `WhileSubscribed timeout: provider stops after last subscriber detaches` (NF5)
- `interceptor chain applied to provider flows`

**WidgetRegistryImplTest.kt:** JUnit5 + `@Tag("fast")`. Tests:
- `findByTypeId returns renderer when present`
- `findByTypeId returns null for unknown type` (F2.13)
- `empty set produces empty registry`
- `duplicate typeId last-write-wins with warning log`
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --console=plain --tests "*.WidgetBindingCoordinatorTest" --tests "*.WidgetDataBinderTest" --tests "*.WidgetRegistryImplTest" 2>&1 | tail -10</automated>
  </verify>
  <done>WidgetBindingCoordinator tests verify SupervisorJob isolation, retry, pause/resume, entitlement. WidgetDataBinder tests verify merge+scan, fallback, staleness, thermal throttling. Registry tests verify typeId lookup.</done>
</task>

</tasks>

<verification>
- `./gradlew :feature:dashboard:compileDebugKotlin --console=plain` succeeds
- `./gradlew :feature:dashboard:testDebugUnitTest --console=plain` passes all binding and registry tests
- SupervisorJob isolation: one crash does not kill siblings
- Exponential backoff: 1s, 2s, 4s with max 3 retries
- Provider fallback priority: user-selected > HARDWARE > DEVICE_SENSOR > NETWORK > SIMULATED
- Data staleness detection with per-type thresholds
- Thermal throttling reduces emission rate
</verification>

<success_criteria>
- WidgetBindingCoordinator manages binding lifecycle with SupervisorJob isolation (NF19)
- Provider fallback works with priority ordering (F3.10)
- Data staleness detection per DataSchema thresholds (F3.11)
- Exponential backoff retry 1s/2s/4s with 3 max attempts (NF16)
- Thermal throttling reduces emissions under pressure (F10.7)
- WidgetRegistryImpl and DataProviderRegistryImpl index and filter correctly
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-dashboard-shell/07-04-SUMMARY.md`
</output>
