---
phase: 07-dashboard-shell
plan: 12
type: execute
wave: 1
depends_on: []
files_modified:
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetDataBinder.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinator.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetDataBinderTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinatorTest.kt
autonomous: true
requirements: [F3.11, F10.7]
gap_closure: true

must_haves:
  truths:
    - "WidgetDataBinder has a per-slot staleness watchdog that marks DataStale when DataSchema.stalenessThresholdMs exceeded"
    - "WidgetDataBinder.throttle uses injectable timeProvider, not System.currentTimeMillis()"
    - "Staleness detection test proves DataStale status emitted after threshold"
    - "Thermal throttle test proves emission rate reduced under DEGRADED config"
  artifacts:
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetDataBinder.kt"
      provides: "Staleness watchdog + injectable time"
      contains: "timeProvider|stalenessThresholdMs|DataStale"
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetDataBinderTest.kt"
      provides: "Staleness + throttle tests"
      contains: "staleness|throttle"
  key_links:
    - from: "WidgetDataBinder staleness watchdog"
      to: "DataSchema.stalenessThresholdMs"
      via: "per-slot timer checking last emission timestamp"
      pattern: "stalenessThresholdMs"
    - from: "WidgetDataBinder.throttle"
      to: "timeProvider"
      via: "injectable time source replacing System.currentTimeMillis()"
      pattern: "timeProvider"
---

<objective>
Implement data staleness detection (F3.11) and fix untestable System.currentTimeMillis() in throttle.

Purpose: Two issues from steelman review:
1. F3.11 (data staleness) is marked SATISFIED in verification but NOT IMPLEMENTED — WidgetDataBinder has no staleness watchdog despite the plan specifying "per-slot watchdog. Each snapshot type's DataSchema.stalenessThresholdMs checked."
2. throttle() uses System.currentTimeMillis() which makes it untestable with TestCoroutineScheduler.

The existing WidgetHealthMonitor in :sdk:observability has a `timeProvider: () -> Long` pattern that we should follow.

Output: Staleness watchdog in WidgetDataBinder, injectable timeProvider for throttle, tests for both.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetDataBinder.kt
@android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetDataBinderTest.kt
@android/sdk/contracts/src/main/kotlin/app/dqxn/android/sdk/contracts/provider/DataSchema.kt
@android/sdk/observability/src/main/kotlin/app/dqxn/android/sdk/observability/health/WidgetHealthMonitor.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinator.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add injectable timeProvider and staleness watchdog to WidgetDataBinder</name>
  <files>
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetDataBinder.kt
  </files>
  <action>
**Part A: Injectable timeProvider**

Add `timeProvider: () -> Long = { System.currentTimeMillis() }` to the WidgetDataBinder constructor. Replace the `System.currentTimeMillis()` call in `throttle()` (line 180) with `timeProvider()`.

This is NOT a Hilt-injected dependency — it's a plain function parameter with a default. Tests pass a fake clock; production uses the default. Same pattern as WidgetHealthMonitor.

**Part B: Staleness watchdog**

The staleness detection belongs in the `bind()` method's flow pipeline. After the `scan()` accumulation, add a staleness check per snapshot slot.

Approach: Track last emission timestamp per slot. After each emission through the merge+scan pipeline, schedule a delayed check for each slot's staleness threshold. If no new emission arrives before the threshold, emit a staleness signal.

Implementation option (simpler, no extra coroutines):

The `bind()` return type is `Flow<WidgetData>`. The staleness signal should be emitted as a status update, not as a WidgetData emission. But WidgetDataBinder doesn't own the status flows — WidgetBindingCoordinator does.

Better approach: Return staleness information alongside the WidgetData. Add a callback or use the existing status update mechanism.

Actually, looking at the architecture more carefully: WidgetBindingCoordinator owns `_widgetStatuses`. The staleness check should happen IN the coordinator, not the binder. The coordinator already has `statusFlow` per widget. The approach:

1. In WidgetBindingCoordinator.startBinding(), after launching the binding job that collects from `binder.bind(...)`, launch a SECOND coroutine as a staleness watchdog for this widget.
2. The watchdog tracks the timestamp of the last successful emission via the dataFlow. Each time data arrives, record `timeProvider()`. Periodically check if `now - lastEmission > stalenessThresholdMs`. If so, set status to DataStale.
3. Use the provider's `DataSchema.stalenessThresholdMs` as the threshold.

WAIT — this means the production code change should be in WidgetBindingCoordinator, not WidgetDataBinder. But the plan's `files_modified` says WidgetDataBinder. Let me reconsider.

The PLAN specifies WidgetDataBinder. The simplest approach: add a staleness-aware wrapper in the flow returned by `bind()`. The binder can emit a marker or the coordinator can wrap the flow.

Simplest correct approach for WidgetDataBinder:

Add a new method or modify `bind()` to accept a `stalenessCallback: (KClass<out DataSnapshot>) -> Unit` that's called when a slot goes stale. The binder tracks timestamps per slot and launches a watchdog coroutine per slot.

Actually, EVEN SIMPLER: Since the binder already produces a `Flow<WidgetData>`, add a `transformLatest` that emits a "stale" sentinel if no emission arrives within the threshold. The caller (WidgetBindingCoordinator) handles the sentinel.

SIMPLEST approach that matches the plan's original intent:

In `WidgetDataBinder.bind()`, for each provider flow, after throttling, add a `timeout`-like operator that emits a stale marker if no new value arrives within `provider.schema.stalenessThresholdMs`. Use `transformLatest`:

```kotlin
// After throttle, add staleness detection
.transformLatest { snapshot ->
    emit(snapshotType to snapshot)
    // Wait for staleness threshold, then emit stale signal
    delay(provider.schema.stalenessThresholdMs)
    emit(snapshotType to StaleMarker(snapshotType))
}
```

But this changes the flow type. Better: have the coordinator handle it.

FINAL APPROACH — keep it in WidgetBindingCoordinator since it owns the status flows:

Change `files_modified` to include WidgetBindingCoordinator. In `startBinding()`, after the binding job, launch a watchdog job per widget:

```kotlin
// In startBinding(), after the main binding job:
val watchdogJob = bindingScope.launch {
    while (true) {
        delay(checkIntervalMs)
        val lastTs = lastEmissionTimestamps[widget.instanceId] ?: continue
        if (timeProvider() - lastTs > threshold) {
            statusFlow.value = WidgetStatusCache(overlayState = WidgetRenderState.DataStale, ...)
        }
    }
}
```

Track `lastEmissionTimestamps` in the coordinator. Update it in the `providerFlow.collect` block where data arrives.

OK — to keep this plan focused, do the following:

1. Add `timeProvider: () -> Long = { System.currentTimeMillis() }` to WidgetDataBinder constructor. Replace in throttle().
2. In WidgetDataBinder.bind(), the per-provider flow pipeline, AFTER the `scan()`, add a `transformLatest` that also emits a staleness signal:

```kotlin
// After scan accumulation, add per-snapshot staleness detection
.transformLatest { widgetData ->
    emit(widgetData)
    // Find the minimum staleness threshold across all bound providers
    // For now use a default. The proper per-slot approach needs provider schema access.
    // TODO: Per-slot staleness in Phase 8 with full widget health integration
}
```

Actually this is getting too complex for a clean plan. Let me simplify drastically:

**REVISED APPROACH:**
1. Add `timeProvider` to WidgetDataBinder constructor (for throttle testability). This is clean and self-contained.
2. For F3.11 staleness: Add staleness tracking to WidgetBindingCoordinator (which has the status flows). Track `lastEmissionTimestamp` per widget. Launch a watchdog coroutine per widget in `startBinding()` that periodically checks freshness against the provider's `schema.stalenessThresholdMs`. This is the correct architectural placement.

So the files_modified should be:
- WidgetDataBinder.kt (timeProvider only)
- WidgetBindingCoordinator.kt (staleness watchdog)
- WidgetDataBinderTest.kt (throttle test)
- WidgetBindingCoordinatorTest.kt (staleness test)

Implement:

**WidgetDataBinder.kt changes:**
1. Add `private val timeProvider: () -> Long = { System.currentTimeMillis() }` to constructor
2. Replace `System.currentTimeMillis()` in throttle() with `timeProvider()`

**WidgetBindingCoordinator.kt changes:**
1. Add `private val timeProvider: () -> Long = { System.currentTimeMillis() }` to constructor
2. Add `private val lastEmissionTimestamps = ConcurrentHashMap<String, Long>()`
3. In `startBinding()`, in the `providerFlow.collect` block (line 155-163), after `dataFlow.value = widgetData`, add: `lastEmissionTimestamps[widget.instanceId] = timeProvider()`
4. After the binding job launch, launch a staleness watchdog:
   ```kotlin
   bindingScope.launch {
       val threshold = renderer.schema?.stalenessThresholdMs ?: DEFAULT_STALENESS_MS
       while (true) {
           delay(threshold)
           val lastTs = lastEmissionTimestamps[widget.instanceId] ?: continue
           if (timeProvider() - lastTs > threshold) {
               val currentStatus = statusFlow.value
               if (currentStatus.overlayState !is WidgetRenderState.ConnectionError &&
                   currentStatus.overlayState !is WidgetRenderState.EntitlementRevoked) {
                   statusFlow.value = WidgetStatusCache(
                       overlayState = WidgetRenderState.DataStale,
                       issues = persistentListOf(),
                   )
               }
           }
       }
   }
   ```
5. In `unbind()`, remove from `lastEmissionTimestamps`
6. In `pauseAll()`, clear `lastEmissionTimestamps`
7. Add `companion object` constant: `private const val DEFAULT_STALENESS_MS = 10_000L`

NOTE: Check if `WidgetRenderState.DataStale` exists. If not, it needs to be added to the sealed interface in `:sdk:contracts`. Read WidgetRenderState to verify.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:compileDebugKotlin --console=plain 2>&amp;1 | tail -10</automated>
  </verify>
  <done>WidgetDataBinder uses injectable timeProvider. WidgetBindingCoordinator has per-widget staleness watchdog checking DataSchema.stalenessThresholdMs.</done>
</task>

<task type="auto">
  <name>Task 2: Add staleness detection test + thermal throttle test</name>
  <files>
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetDataBinderTest.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinatorTest.kt
  </files>
  <action>
**WidgetDataBinderTest — thermal throttle test:**

```kotlin
@Test
fun `thermal throttle reduces emission rate under DEGRADED config`() = runTest {
    var fakeTime = 0L
    val speedFlow = MutableSharedFlow<SpeedSnapshot>()
    val provider = SimpleProvider(
        dataFlow = speedFlow,
        sourceId = "test:speed",
        snapshotType = SpeedSnapshot::class,
    )
    val binder = WidgetDataBinder(
        providerRegistry = SimpleProviderRegistry(setOf(provider)),
        interceptors = emptySet(),
        thermalMonitor = thermalMonitor,
        logger = logger,
        timeProvider = { fakeTime },
    )

    // Set DEGRADED thermal level (15fps target)
    thermalMonitor.setLevel(ThermalLevel.DEGRADED)

    val widget = testWidget(typeId = "essentials:speed")
    val renderConfig = thermalMonitor.renderConfig
    val dataFlow = binder.bind(widget, setOf(SpeedSnapshot::class), renderConfig)

    // Collect with Turbine
    dataFlow.test {
        // Emit rapidly — only emissions spaced >= 66ms (1000/15) should pass
        fakeTime = 0L
        speedFlow.emit(SpeedSnapshot(speed = 1.0)) // passes (first)
        fakeTime = 30L
        speedFlow.emit(SpeedSnapshot(speed = 2.0)) // throttled (30ms < 66ms)
        fakeTime = 70L
        speedFlow.emit(SpeedSnapshot(speed = 3.0)) // passes (70ms >= 66ms)

        // Should receive speed=1.0 and speed=3.0 (speed=2.0 throttled)
        skipItems(1) // scan seed
        val first = awaitItem()
        assertThat(first.snapshot<SpeedSnapshot>()!!.speed).isEqualTo(1.0)
        val second = awaitItem()
        assertThat(second.snapshot<SpeedSnapshot>()!!.speed).isEqualTo(3.0)

        cancelAndIgnoreRemainingEvents()
    }
}
```

**WidgetBindingCoordinatorTest — data staleness test:**

```kotlin
@Test
fun `data staleness marks widget stale when no emission within threshold`() = runTest {
    // Use a provider that emits once then goes silent
    val provider = ContinuousProvider()
    val renderer = TestWidgetRenderer(
        typeId = "essentials:clock",
        compatibleSnapshots = setOf(TestSnapshot::class),
        // Schema with 5s staleness threshold
        schema = DataSchema(emptyList(), stalenessThresholdMs = 5_000L),
    )
    val widgetRegistry = WidgetRegistryImpl(setOf(renderer), logger)
    val providerRegistry = DataProviderRegistryImpl(setOf(provider), FakeEntitlementManager(), logger)

    var fakeTime = 0L
    val coordinator = createCoordinator(
        widgetRegistry, providerRegistry,
        timeProvider = { fakeTime },
    )

    val initJob = Job(coroutineContext[Job])
    coordinator.initialize(this + initJob)

    val widget = testWidget(typeId = "essentials:clock")
    coordinator.bind(widget)
    provider.emissionFlow.emit(TestSnapshot(timestamp = 1000L))
    advanceUntilIdle()

    // Data received — status should be Ready
    assertThat(coordinator.widgetStatus(widget.instanceId).value.overlayState)
        .isNotInstanceOf(WidgetRenderState.DataStale::class.java)

    // Advance past staleness threshold without new emission
    fakeTime = 6_000L
    advanceTimeBy(6_000)
    advanceUntilIdle()

    // Status should now be DataStale
    assertThat(coordinator.widgetStatus(widget.instanceId).value.overlayState)
        .isEqualTo(WidgetRenderState.DataStale)

    initJob.cancel()
}
```

NOTE: The `createCoordinator` helper needs to accept an optional `timeProvider` parameter and pass it to the WidgetBindingCoordinator constructor. Add this parameter.

NOTE: TestWidgetRenderer may need a `schema` parameter. Check if it has one; if not, the test should mock the renderer with MockK to provide a custom schema. Alternatively, if the staleness threshold comes from the DataProvider's schema (not the renderer), adjust accordingly.

NOTE: If `WidgetRenderState.DataStale` doesn't exist yet, add it to the sealed interface in `:sdk:contracts`. It should be a simple `data object DataStale : WidgetRenderState` or a data class with metadata.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.WidgetDataBinderTest" --tests "*.WidgetBindingCoordinatorTest" --console=plain 2>&amp;1 | tail -20</automated>
  </verify>
  <done>Staleness detection test proves DataStale emitted after threshold. Thermal throttle test proves emission rate reduction. All existing tests still pass.</done>
</task>

</tasks>

<verification>
```
cd android && ./gradlew :feature:dashboard:testDebugUnitTest --console=plain
```
All dashboard tests pass including new staleness and throttle tests.
</verification>

<success_criteria>
- F3.11 staleness detection implemented and tested — per-widget watchdog with DataSchema threshold
- Thermal throttle testable via injectable timeProvider
- WidgetDataBinder.throttle() no longer uses System.currentTimeMillis()
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-dashboard-shell/07-12-SUMMARY.md`
</output>
