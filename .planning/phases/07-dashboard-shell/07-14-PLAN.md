---
phase: 07-dashboard-shell
plan: 14
type: execute
wave: 1
depends_on: []
files_modified:
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/LayoutCoordinatorTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/EditModeCoordinatorTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinatorTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/ProfileCoordinatorTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/grid/ConfigurationBoundaryDetectorTest.kt
autonomous: true
requirements: [NF19]
gap_closure: true

must_haves:
  truths:
    - "Zero UnconfinedTestDispatcher imports across all 5 migrated test files"
    - "All 35 existing tests pass after migration to StandardTestDispatcher"
    - "LayoutCoordinatorTest uses StandardTestDispatcher for ioDispatcher injection"
    - "EditModeCoordinatorTest uses StandardTestDispatcher for LayoutCoordinator ioDispatcher in setup"
    - "NotificationCoordinatorTest uses runTest (StandardTestDispatcher default) with testScheduler.runCurrent()"
    - "ProfileCoordinatorTest uses runTest (StandardTestDispatcher default) with testScheduler.runCurrent()"
    - "ConfigurationBoundaryDetectorTest uses runTest (StandardTestDispatcher default) with testScheduler.runCurrent()"
  artifacts:
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/LayoutCoordinatorTest.kt"
      provides: "CLAUDE.md-compliant dispatcher"
      contains: "StandardTestDispatcher"
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/EditModeCoordinatorTest.kt"
      provides: "CLAUDE.md-compliant dispatcher"
      contains: "StandardTestDispatcher"
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinatorTest.kt"
      provides: "CLAUDE.md-compliant dispatcher"
      contains: "runCurrent"
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/ProfileCoordinatorTest.kt"
      provides: "CLAUDE.md-compliant dispatcher"
      contains: "runCurrent"
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/grid/ConfigurationBoundaryDetectorTest.kt"
      provides: "CLAUDE.md-compliant dispatcher"
      contains: "runCurrent"
  key_links:
    - from: "LayoutCoordinatorTest.createCoordinator"
      to: "StandardTestDispatcher"
      via: "ioDispatcher parameter"
      pattern: "StandardTestDispatcher"
    - from: "EditModeCoordinatorTest.setup"
      to: "StandardTestDispatcher"
      via: "LayoutCoordinator ioDispatcher"
      pattern: "StandardTestDispatcher"
---

<objective>
Migrate remaining 5 test files from UnconfinedTestDispatcher to StandardTestDispatcher per CLAUDE.md rule: "never UnconfinedTestDispatcher."

Purpose: Plan 07-10 migrated WidgetBindingCoordinatorTest + WidgetDataBinderTest but left 5 files unmigrated, representing ~21% of Phase 7's tests. CLAUDE.md explicitly bans UnconfinedTestDispatcher.

Output: All 5 test files using StandardTestDispatcher, all 35 existing tests passing.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-dashboard-shell/07-10-SUMMARY.md
@android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/LayoutCoordinatorTest.kt
@android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/EditModeCoordinatorTest.kt
@android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinatorTest.kt
@android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/ProfileCoordinatorTest.kt
@android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/grid/ConfigurationBoundaryDetectorTest.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/LayoutCoordinator.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinator.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/ProfileCoordinator.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/EditModeCoordinator.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/ConfigurationBoundaryDetector.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate LayoutCoordinatorTest + EditModeCoordinatorTest to StandardTestDispatcher</name>
  <files>
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/LayoutCoordinatorTest.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/EditModeCoordinatorTest.kt
  </files>
  <action>
These two are linked: EditModeCoordinatorTest creates a LayoutCoordinator in its `@BeforeEach` that uses `ioDispatcher = UnconfinedTestDispatcher()`.

**LayoutCoordinatorTest migration:**

1. Remove `import kotlinx.coroutines.test.UnconfinedTestDispatcher`
2. Add `import kotlinx.coroutines.test.StandardTestDispatcher`
3. In `createCoordinator()`: change `ioDispatcher = UnconfinedTestDispatcher()` to `ioDispatcher = StandardTestDispatcher(testScheduler)`. The `createCoordinator` is called inside `runTest`, so `testScheduler` is accessible.

Problem: `createCoordinator` is a class-level helper, not inside `runTest`. It has no access to `testScheduler`.

Fix: Change `createCoordinator` to accept a `CoroutineDispatcher` parameter:
```kotlin
private fun createCoordinator(
  fakeRepo: FakeLayoutRepository,
  ioDispatcher: CoroutineDispatcher = StandardTestDispatcher(),
): LayoutCoordinator = LayoutCoordinator(
  layoutRepository = fakeRepo,
  presetLoader = presetLoader,
  gridPlacementEngine = GridPlacementEngine(logger = logger),
  configurationBoundaryDetector = ConfigurationBoundaryDetector(
    windowInfoTracker = mockk(relaxed = true),
    logger = logger,
  ),
  ioDispatcher = ioDispatcher,
  logger = logger,
)
```

4. In each test, change `runTest(UnconfinedTestDispatcher())` to `runTest`. Then pass the test scheduler's dispatcher:
```kotlin
@Test
fun `initialize loads widgets from repository`() = runTest {
  val fakeRepo = FakeLayoutRepository()
  val coordinator = createCoordinator(fakeRepo, StandardTestDispatcher(testScheduler))
  // ...
  coordinator.initialize(backgroundScope)
  testScheduler.runCurrent()
  // assertions...
}
```

5. Replace `coordinator.initialize(backgroundScope)` with child scope pattern if LayoutCoordinator launches long-lived coroutines. Read the LayoutCoordinator source to check. Looking at the code: `initialize()` calls `scope.launch { layoutRepository.getActiveProfileWidgets().collect { ... } }`. This is a long-lived collection. With StandardTestDispatcher, `backgroundScope` won't advance. Use the child Job pattern:
```kotlin
val initJob = Job(coroutineContext[Job])
coordinator.initialize(this + initJob)
testScheduler.runCurrent()
// assertions...
initJob.cancel()
```

IMPORTANT: LayoutCoordinator does NOT have a `destroy()` method or standalone SupervisorJob. The initialize scope is the parent scope. Using `initJob.cancel()` should be sufficient cleanup.

6. After every mutation (setWidgets, handleAddWidget, handleRemoveWidget, etc.) add `testScheduler.runCurrent()` to drain queued coroutines.

**EditModeCoordinatorTest migration:**

1. Remove `import kotlinx.coroutines.test.UnconfinedTestDispatcher`
2. Add `import kotlinx.coroutines.test.StandardTestDispatcher`
3. The `@BeforeEach setup()` creates a LayoutCoordinator with `ioDispatcher = UnconfinedTestDispatcher()`. This needs to become a dispatcher that participates in the test scheduler. BUT: `@BeforeEach` runs OUTSIDE `runTest`. The cleanest approach is to not pre-create the LayoutCoordinator in setup. Instead, create it inside each test that needs `runTest`.

For the 2 tests that use `runTest(UnconfinedTestDispatcher())` — `endDrag snaps to grid` and `endDrag with no-straddle violation`:
```kotlin
fun `endDrag snaps to grid and commits position`() = runTest {
  fakeRepo = FakeLayoutRepository()
  layoutCoordinator = LayoutCoordinator(
    layoutRepository = fakeRepo,
    presetLoader = mockk(relaxed = true),
    gridPlacementEngine = gridPlacementEngine,
    configurationBoundaryDetector = boundaryDetector,
    ioDispatcher = StandardTestDispatcher(testScheduler),
    logger = logger,
  )
  coordinator = EditModeCoordinator(
    layoutCoordinator = layoutCoordinator,
    gridPlacementEngine = gridPlacementEngine,
    haptics = haptics,
    reducedMotionHelper = reducedMotionHelper,
    logger = logger,
  )

  val widget = testWidget(instanceId = "w1", col = 2, row = 2)
  fakeRepo.setWidgets(listOf(widget))
  val initJob = Job(coroutineContext[Job])
  layoutCoordinator.initialize(this + initJob)
  testScheduler.runCurrent()
  coordinator.initialize(this)

  // ... drag operations ...
  coordinator.endDrag(gridUnitPx = 48f)
  testScheduler.runCurrent()
  // assertions...
  initJob.cancel()
}
```

For the ~14 non-coroutine tests (enterEditMode, exitEditMode, focusWidget, startDrag, updateDrag, resize, interaction gating, statusBar): these don't use `runTest` at all. They only need the `@BeforeEach` setup. The `@BeforeEach` LayoutCoordinator still needs a dispatcher. Use `StandardTestDispatcher()` (no testScheduler linkage needed since these tests don't advance virtual time):
```kotlin
@BeforeEach
fun setup() {
  fakeRepo = FakeLayoutRepository()
  layoutCoordinator = LayoutCoordinator(
    layoutRepository = fakeRepo,
    presetLoader = mockk(relaxed = true),
    gridPlacementEngine = gridPlacementEngine,
    configurationBoundaryDetector = boundaryDetector,
    ioDispatcher = StandardTestDispatcher(),
    logger = logger,
  )
  // ...
}
```

4. Remove `advanceUntilIdle()` calls in the endDrag tests, replace with `testScheduler.runCurrent()`.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.LayoutCoordinatorTest" --tests "*.EditModeCoordinatorTest" --console=plain 2>&amp;1 | tail -20</automated>
  </verify>
  <done>All 9 LayoutCoordinatorTest + 18 EditModeCoordinatorTest tests pass with StandardTestDispatcher. No UnconfinedTestDispatcher imports remain.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate NotificationCoordinatorTest + ProfileCoordinatorTest + ConfigurationBoundaryDetectorTest</name>
  <files>
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinatorTest.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/ProfileCoordinatorTest.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/grid/ConfigurationBoundaryDetectorTest.kt
  </files>
  <action>
All three files follow the same pattern: `runTest(UnconfinedTestDispatcher()) { ... }`.

**NotificationCoordinatorTest (11 tests):**

1. Remove `import kotlinx.coroutines.test.UnconfinedTestDispatcher`
2. Add `import kotlinx.coroutines.test.StandardTestDispatcher`
3. Replace every `runTest(UnconfinedTestDispatcher())` with `runTest`.
4. NotificationCoordinator.initialize() launches `scope.launch { safeModeManager.safeModeActive.collect { ... } }` and `scope.launch { storageMonitor.isLow.collect { ... } }`. These are long-lived. Use child Job pattern:
```kotlin
val initJob = Job(coroutineContext[Job])
coordinator.initialize(this + initJob)
testScheduler.runCurrent()
```
5. After every StateFlow value change (`safeModeActive.value = true`, `storageIsLow.value = true`, etc.), add `testScheduler.runCurrent()` to dispatch the collector.
6. Add `initJob.cancel()` at end of each test.

Example migration for `safe mode active shows CRITICAL banner`:
```kotlin
@Test
fun `safe mode active shows CRITICAL banner`() = runTest {
  val coordinator = createCoordinator()
  val initJob = Job(coroutineContext[Job])
  coordinator.initialize(this + initJob)
  testScheduler.runCurrent()

  safeModeActive.value = true
  testScheduler.runCurrent()

  val banners = coordinator.activeBanners.value
  assertThat(banners).hasSize(1)
  assertThat(banners.first().id).isEqualTo("safe_mode")
  assertThat(banners.first().priority).isEqualTo(NotificationPriority.CRITICAL)
  assertThat(banners.first().message).contains("repeated crashes")

  initJob.cancel()
}
```

Apply the same pattern to all 11 tests. Some tests don't touch StateFlows (showToast, reportLayoutSaveFailure, etc.) — these may not need `testScheduler.runCurrent()` after mutation, but still need the child Job pattern for initialize().

**ProfileCoordinatorTest (9 tests):**

1. Remove `import kotlinx.coroutines.test.UnconfinedTestDispatcher`
2. Add `import kotlinx.coroutines.test.StandardTestDispatcher`
3. Replace every `runTest(UnconfinedTestDispatcher())` with `runTest`.
4. ProfileCoordinator.initialize() also launches flow collection. Same child Job pattern.
5. After `coordinator.initialize(this + initJob)`, add `testScheduler.runCurrent()`.
6. After every mutation that triggers flow emissions (handleCreateProfile, handleSwitchProfile, handleDeleteProfile, repo.addWidget, repo.setWidgets, etc.), add `testScheduler.runCurrent()`.
7. Add `initJob.cancel()` at end of each test.

NOTE: The `handleSwitchProfile updates activeProfileId` test calls `coordinator.initialize(backgroundScope)` twice. With StandardTestDispatcher, use the child Job pattern both times, or just once with the flow continuing.

NOTE: The `per-profile independence widget added to A not in B` test uses `repo.getActiveProfileWidgets().first()`. Since this is a suspend function inside `runTest`, it should work without special handling, but may need `testScheduler.runCurrent()` to ensure the internal profile switch flow has propagated.

**ConfigurationBoundaryDetectorTest (4 tests):**

1. Remove `import kotlinx.coroutines.test.UnconfinedTestDispatcher`
2. Add `import kotlinx.coroutines.test.StandardTestDispatcher`
3. Replace every `runTest(UnconfinedTestDispatcher())` with `runTest`.
4. `detector.observe(mockActivity, backgroundScope)` launches a flow collection. Use child Job pattern:
```kotlin
val observeJob = Job(coroutineContext[Job])
detector.observe(mockActivity, this + observeJob)
```
5. After `windowLayoutInfoFlow.emit(layoutInfo)`, add `testScheduler.runCurrent()`.
6. Add `observeJob.cancel()` at end of each test.

CRITICAL: The 07-10 SUMMARY established that `testScheduler.runCurrent()` is the correct approach when infinite delay loops exist. None of these 3 coordinator/detector classes have infinite delay loops — NotificationCoordinator, ProfileCoordinator, and ConfigurationBoundaryDetector all use simple `collect {}`. So `advanceUntilIdle()` SHOULD work for these. However, use `testScheduler.runCurrent()` consistently for uniformity and safety. If any test hangs with `runCurrent()`, try `advanceUntilIdle()` — it's safe when there are no infinite delay loops.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.NotificationCoordinatorTest" --tests "*.ProfileCoordinatorTest" --tests "*.ConfigurationBoundaryDetectorTest" --console=plain 2>&amp;1 | tail -20</automated>
  </verify>
  <done>All 11 NotificationCoordinatorTest + 9 ProfileCoordinatorTest + 4 ConfigurationBoundaryDetectorTest pass with StandardTestDispatcher. No UnconfinedTestDispatcher imports remain in ANY test file in the dashboard module.</done>
</task>

</tasks>

<verification>
```
cd android && grep -r "UnconfinedTestDispatcher" feature/dashboard/src/test/ && echo "FAIL: UnconfinedTestDispatcher still found" || echo "PASS: Zero UnconfinedTestDispatcher usage"
cd android && ./gradlew :feature:dashboard:testDebugUnitTest --console=plain 2>&1 | tail -20
```
Zero UnconfinedTestDispatcher imports across ALL test files. All tests pass.
</verification>

<success_criteria>
- Zero uses of UnconfinedTestDispatcher in any test file under feature/dashboard
- All 35 migrated tests pass with StandardTestDispatcher
- All other existing tests continue to pass (no regressions)
- CLAUDE.md dispatcher compliance fully restored
</success_criteria>

<output>
After completion, create `.planning/phases/07-dashboard-shell/07-14-SUMMARY.md`
</output>
