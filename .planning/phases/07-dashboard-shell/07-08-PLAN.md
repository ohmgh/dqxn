---
phase: 07-dashboard-shell
plan: 08
type: execute
wave: 1
depends_on: []
files_modified:
  - android/feature/dashboard/src/testFixtures/kotlin/app/dqxn/android/feature/dashboard/test/DashboardTestHarness.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/DashboardTestHarnessTest.kt
autonomous: true
requirements: [F2.4, NF19]
gap_closure: true

must_haves:
  truths:
    - "DashboardTestHarness contains WidgetBindingCoordinator backed by mocked dependencies"
    - "DashboardTestScope exposes widgetBindingCoordinator for test assertions"
    - "Integration test 'dispatch AddWidget creates binding job and reports ACTIVE' asserts widgetBindingCoordinator.activeBindings() contains the widget's instanceId"
  artifacts:
    - path: "android/feature/dashboard/src/testFixtures/kotlin/app/dqxn/android/feature/dashboard/test/DashboardTestHarness.kt"
      provides: "WidgetBindingCoordinator wired into harness"
      contains: "widgetBindingCoordinator"
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/DashboardTestHarnessTest.kt"
      provides: "Updated test asserting activeBindings()"
      contains: "activeBindings"
  key_links:
    - from: "DashboardTestHarness"
      to: "WidgetBindingCoordinator"
      via: "constructor with mocked deps"
      pattern: "WidgetBindingCoordinator\\("
    - from: "DashboardTestHarnessTest"
      to: "WidgetBindingCoordinator.activeBindings()"
      via: "test assertion"
      pattern: "activeBindings.*containsKey"
---

<objective>
Wire WidgetBindingCoordinator into DashboardTestHarness and fix the SC#3 integration test.

Purpose: The verification found that the test named "dispatch AddWidget creates binding job and reports ACTIVE" only asserts layout widget count, never checking WidgetBindingCoordinator.activeBindings(). The harness itself lacks a WidgetBindingCoordinator instance. This gap closure adds the coordinator to the harness and updates the test to actually verify what its name claims.

Output: Updated DashboardTestHarness with WidgetBindingCoordinator, updated test with binding assertion.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@android/feature/dashboard/src/testFixtures/kotlin/app/dqxn/android/feature/dashboard/test/DashboardTestHarness.kt
@android/feature/dashboard/src/testFixtures/kotlin/app/dqxn/android/feature/dashboard/test/FakeWidgetDataBinder.kt
@android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/DashboardTestHarnessTest.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinator.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetDataBinder.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WidgetBindingCoordinator to DashboardTestHarness and fix SC#3 test</name>
  <files>
    android/feature/dashboard/src/testFixtures/kotlin/app/dqxn/android/feature/dashboard/test/DashboardTestHarness.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/DashboardTestHarnessTest.kt
  </files>
  <action>
**Part A: Update DashboardTestHarness.kt (testFixtures)**

Add WidgetBindingCoordinator to the harness with mocked dependencies. The coordinator constructor needs:
- `binder: WidgetDataBinder` -- use a real WidgetDataBinder backed by a mock DataProviderRegistry (that returns empty provider list), empty Set of interceptors, mock ThermalMonitor (relaxed), and NoOpLogger. OR: use a mock WidgetDataBinder that returns `flow { emit(WidgetData.Empty) }` from `bind()`. The mock approach is simpler since FakeWidgetDataBinder is NOT a WidgetDataBinder subclass -- it's a standalone test utility.
- `widgetRegistry: WidgetRegistry` -- use a mock that returns a mock WidgetRenderer when `findByTypeId("essentials:clock")` is called. The renderer needs `compatibleSnapshots` returning an empty set, and `requiredAnyEntitlement` returning null/empty.
- `safeModeManager: SafeModeManager` -- reuse the existing `safeModeManager` in the harness
- `entitlementManager: EntitlementManager` -- use a mock returning `MutableStateFlow(emptySet<String>())` for `entitlementChanges`
- `thermalMonitor: ThermalMonitor` -- use a mock returning `MutableStateFlow(RenderConfig(targetFps = 60, glowEnabled = true, effectLevel = 1f))` for `renderConfig`
- `metricsCollector: MetricsCollector` -- relaxed mock
- `logger: DqxnLogger` -- reuse existing `NoOpLogger`
- `ioDispatcher: CoroutineDispatcher` -- reuse `testDispatcher`
- `defaultDispatcher: CoroutineDispatcher` -- reuse `testDispatcher`

Important: The mock WidgetRegistry MUST return a non-null renderer for common typeIds (at minimum "essentials:clock") so that `startBinding()` proceeds past the null-check on line 133-142 of WidgetBindingCoordinator.kt. The renderer mock needs:
- `compatibleSnapshots` returning a non-empty set (at least one KClass). Use a simple `setOf(DataSnapshot::class)` or define a test snapshot class.
- `requiredAnyEntitlement` returning null or emptySet

The WidgetBindingCoordinator must be initialized in `initialize()` with the same scope as layoutCoordinator.

Expose `widgetBindingCoordinator` as a public val on DashboardTestHarness.

Also update `DashboardTestScope` to expose `widgetBindingCoordinator` and add a `activeBindings()` convenience method.

Update `HarnessStateOnFailure.testFailed()` to also dump binding count if widgetBindingCoordinator is available.

**Part B: Update DashboardTestHarnessTest.kt**

In the test `dispatch AddWidget creates binding job and reports ACTIVE`:
1. After `harness.layoutCoordinator.handleAddWidget(widget)` and `advanceUntilIdle()`, also call `harness.widgetBindingCoordinator.bind(widget)` (the harness doesn't auto-bind -- LayoutCoordinator.handleAddWidget only updates layout state, it doesn't trigger binding. In production, the ViewModel wires AddWidget to both coordinators).
2. Then `advanceUntilIdle()` again.
3. Assert: `assertThat(harness.widgetBindingCoordinator.activeBindings()).containsKey(widget.instanceId)`

The test should read:
```kotlin
@Test
fun `dispatch AddWidget creates binding job and reports ACTIVE`() = runTest {
    val harness = DashboardTestHarness(testScope = this)
    stateOnFailure.harness = harness
    harness.initialize()
    advanceUntilIdle()

    val widget = testWidget(typeId = "essentials:clock")

    // Add widget to layout
    harness.layoutCoordinator.handleAddWidget(widget)
    advanceUntilIdle()

    // Verify widget was added to layout
    val layoutState = harness.layoutCoordinator.layoutState.value
    assertThat(layoutState.widgets).hasSize(1)
    assertThat(layoutState.widgets.first().typeId).isEqualTo("essentials:clock")

    // Bind widget (in production, ViewModel.routeCommand does both add + bind)
    harness.widgetBindingCoordinator.bind(layoutState.widgets.first())
    advanceUntilIdle()

    // SC#3: Verify WidgetBindingCoordinator created a binding job
    assertThat(harness.widgetBindingCoordinator.activeBindings()).containsKey(layoutState.widgets.first().instanceId)

    harness.close()
}
```

Note on imports: You will need to add imports for WidgetBindingCoordinator, WidgetDataBinder, ThermalMonitor, RenderConfig, WidgetRegistry, EntitlementManager, MetricsCollector, MutableStateFlow, DataSnapshot, and any other types used in the mock setup.

IMPORTANT: Do NOT break any existing tests. The harness is used by multiple tests across DashboardTestHarnessTest. Ensure all 9 existing tests still pass after the changes. The new coordinator should be additive -- it doesn't interfere with the existing LayoutCoordinator or SafeModeManager in the harness.

After making changes, also call `widgetBindingCoordinator.destroy()` in the `close()` method to clean up the SupervisorJob.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.DashboardTestHarnessTest" --console=plain 2>&amp;1 | tail -30</automated>
    <manual>Verify the test output shows "dispatch AddWidget creates binding job and reports ACTIVE" passes with the new activeBindings assertion</manual>
    <sampling_rate>run after this task commits, before declaring plan complete</sampling_rate>
  </verify>
  <done>
    - DashboardTestHarness contains WidgetBindingCoordinator wired with mocked dependencies
    - DashboardTestScope exposes widgetBindingCoordinator
    - Test "dispatch AddWidget creates binding job and reports ACTIVE" asserts activeBindings() contains the widget instanceId
    - All 9+ existing DashboardTestHarnessTest tests still pass
  </done>
</task>

</tasks>

<verification>
Run full dashboard test suite to confirm no regressions:
```
cd android && ./gradlew :feature:dashboard:testDebugUnitTest --console=plain
```
All tests pass (148+ existing tests + updated assertion).
</verification>

<success_criteria>
- DashboardTestHarness now wires WidgetBindingCoordinator
- The test "dispatch AddWidget creates binding job and reports ACTIVE" verifies both layout state AND binding coordinator state
- All existing tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/07-dashboard-shell/07-08-SUMMARY.md`
</output>
