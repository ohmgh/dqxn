---
phase: 07-dashboard-shell
plan: 15
type: execute
wave: 2
depends_on: ["14"]
files_modified:
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/ReducedMotionIntegrationTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetSlotTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinatorTest.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinator.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinatorTest.kt
autonomous: true
requirements: [F9.2, F2.14, NF39, NF5]
gap_closure: true

must_haves:
  truths:
    - "ReducedMotionIntegrationTest test #1 tests actual production composable state, not replicated gate logic"
    - "ReducedMotionIntegrationTest test #3 exercises ProfilePageTransition or its gate, not just mock self-assertion"
    - "WidgetSlotTest crash test exercises the hasRenderError state flag path, not just mock verification"
    - "NotificationCoordinator.showBanner() calls alertEmitter.fire() when alertProfile is non-null"
    - "NotificationCoordinatorTest verifies alertEmitter.fire() invocation on safe mode banner"
    - "WidgetBindingCoordinator unbind cancels the provider flow collection"
  artifacts:
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/ReducedMotionIntegrationTest.kt"
      provides: "Non-tautological reduced motion tests"
      contains: "DashboardGrid|ProfilePageTransition|ReducedMotionHelper"
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetSlotTest.kt"
      provides: "Error boundary behavioral coverage"
      contains: "hasRenderError|RenderState|status"
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinator.kt"
      provides: "alertEmitter.fire() invocation"
      contains: "alertEmitter.fire"
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinatorTest.kt"
      provides: "alertEmitter side-effect verification"
      contains: "verify.*alertEmitter.*fire"
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinatorTest.kt"
      provides: "Unbind cancels provider flow test"
      contains: "unbind.*cancel|provider.*stop"
  key_links:
    - from: "NotificationCoordinator.showBanner"
      to: "alertEmitter.fire"
      via: "conditional invocation when alertProfile non-null"
      pattern: "alertProfile.*fire"
    - from: "WidgetBindingCoordinator.unbind"
      to: "binding job cancellation"
      via: "job.cancel() stops provider flow collection"
      pattern: "unbind.*cancel"
---

<objective>
Fix 3 tautological tests (Q2), add alertEmitter.fire() production code + test (Q3), and add unbind-cancels-flow test (Q4).

Purpose: Q2 — 3 tests provide false confidence by testing mocks or replicated logic instead of production code. Q3 — alertEmitter is injected into NotificationCoordinator but never invoked; the safe mode VIBRATE alert is a data field only, not a side-effect. Q4 — WhileSubscribed/stopTimeout was planned but not implemented; the equivalent behavior (flow stops on unbind) needs explicit test coverage.

Output: Rewritten tests that exercise production code, alertEmitter.fire() wired and tested, unbind flow cancellation tested.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-dashboard-shell/07-VERIFICATION.md
@android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/ReducedMotionIntegrationTest.kt
@android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetSlotTest.kt
@android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinatorTest.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinator.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinator.kt
@android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinatorTest.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/gesture/ReducedMotionHelper.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/DashboardGrid.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/profile/ProfilePageTransition.kt
@android/sdk/contracts/src/main/kotlin/app/dqxn/android/sdk/contracts/notification/AlertEmitter.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite tautological tests (Q2) + add alertEmitter.fire() production code and test (Q3)</name>
  <files>
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/ReducedMotionIntegrationTest.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetSlotTest.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinator.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinatorTest.kt
  </files>
  <action>
**Q2 — Rewrite 3 tautological tests:**

**ReducedMotionIntegrationTest test #1** (`reduced motion - edit mode wiggle animation disabled`):

Problem: Replicates production gate logic (`val wiggle = if (isEditMode && !isReducedMotion) 0.5f else 0f`) in the test. Tests the test copy, not production code.

Fix: Test the actual ReducedMotionHelper contract — that when `isReducedMotion` returns true, the values used by DashboardGrid would result in zero animation. Since DashboardGrid uses Compose `animateFloatAsState` internally (untestable without compose-ui-test), the test should verify ReducedMotionHelper itself returns the correct value, AND verify that the DashboardGrid constants/logic contract is maintained.

Better approach: Read `ReducedMotionHelper.kt` to see if it exposes `isReducedMotion`. Then construct a real `ReducedMotionHelper` (or mock the ContentResolver it reads from) and assert `isReducedMotion == true` when `Settings.Global.ANIMATOR_DURATION_SCALE == 0f`. This tests the actual production component.

If ReducedMotionHelper reads from ContentResolver, use MockK to mock it:
```kotlin
@Test
fun `reduced motion - ReducedMotionHelper detects disabled animations`() {
  val contentResolver = mockk<ContentResolver>()
  every {
    Settings.Global.getFloat(contentResolver, Settings.Global.ANIMATOR_DURATION_SCALE, 1f)
  } returns 0f

  val helper = ReducedMotionHelper(contentResolver)
  assertThat(helper.isReducedMotion).isTrue()
}
```

If mockkStatic on Settings.Global is needed, use `mockkStatic(Settings.Global::class)`.

If ReducedMotionHelper is a simple class that can be directly instantiated, prefer that over mocking.

The key is: test the PRODUCTION ReducedMotionHelper, not replicated `if` statements.

**ReducedMotionIntegrationTest test #3** (`reduced motion - profile page transition is instant when reduced motion active`):

Problem: Only asserts `reducedMotionHelper.isReducedMotion == true` — a mock self-assertion. Never imports or invokes ProfilePageTransition. ProfilePageTransition is a `@Composable` function untestable without compose-ui-test.

Fix: Replace test #3 with a test that verifies ReducedMotionHelper returns false when animations are enabled (scale == 1f). This gives real two-sided coverage paired with test #1 (which tests scale == 0f → isReducedMotion == true):

```kotlin
@Test
fun `normal motion - ReducedMotionHelper detects enabled animations`() {
  // ... mock animator_duration_scale = 1f ...
  val helper = ReducedMotionHelper(...)
  assertThat(helper.isReducedMotion).isFalse()
}
```

**WidgetSlotTest crash test** (`widget crash reports DashboardCommand WidgetCrash via crash reporting`):

Problem: Calls `reportCrash()` on a mock and verifies it was called. Tests MockK, not application code.

Fix: Test the state-based error boundary. When a widget has `hasRenderError` (tracked via WidgetStatusCache), WidgetSlot should render an error fallback. Since we can't test Compose rendering, test the state transition:

```kotlin
@Test
fun `widget crash sets ConnectionError status via WidgetBindingCoordinator`() {
  // Create a real (or partially real) coordinator that tracks crash state
  // After reporting enough crashes, the status should change.
  // OR: Test that calling reportCrash delegates to SafeModeManager (the coordinator's actual behavior).

  // Since we can't use real WidgetBindingCoordinator here (it needs full DI),
  // verify the contract: reportCrash(widgetId, typeId) exists and is callable,
  // AND verify SafeModeManager gets the crash report.
  val safeModeManager = mockk<SafeModeManager>(relaxed = true)
  val coordinator = WidgetBindingCoordinator(
    binder = mockk(relaxed = true),
    widgetRegistry = mockk(relaxed = true),
    safeModeManager = safeModeManager,
    entitlementManager = mockk(relaxed = true),
    thermalMonitor = mockk(relaxed = true),
    metricsCollector = mockk(relaxed = true),
    logger = NoOpLogger,
    ioDispatcher = StandardTestDispatcher(),
    defaultDispatcher = StandardTestDispatcher(),
  )

  coordinator.reportCrash("test-widget-1", "essentials:clock")

  verify { safeModeManager.reportCrash("test-widget-1", "essentials:clock") }
}
```

Wait — this is still testing delegation, similar to the original. The difference: we're testing a REAL WidgetBindingCoordinator, not a mock. If someone removes the `safeModeManager.reportCrash()` call from `reportCrash()`, this test fails. The original test mocked both sides — it CANNOT detect regression.

To also test the error boundary state: verify that the WidgetStatusCache for a widget changes to an error state after enough crashes. But this requires the full binding pipeline. Given context constraints, the delegation test with a real coordinator is the pragmatic improvement.

**Q3 — Add alertEmitter.fire() production code:**

In `NotificationCoordinator.showBanner()`, after creating the banner and updating the map, invoke `alertEmitter.fire()` when `alertProfile` is non-null:

```kotlin
// In showBanner(), after refreshBannerState():
if (alertProfile != null) {
  // Fire alert on the scope — suspend function needs a coroutine
  // Problem: showBanner is NOT a suspend function and has no scope reference.
}
```

Issue: `alertEmitter.fire()` is a suspend function but `showBanner()` is not. The coordinator has no reference to the scope after `initialize()`. Two options:

Option A: Store the scope from `initialize()` and launch from it:
```kotlin
private lateinit var coordinatorScope: CoroutineScope

fun initialize(scope: CoroutineScope) {
  coordinatorScope = scope
  // ... existing code ...
}

fun showBanner(...) {
  // ... existing banner logic ...
  if (alertProfile != null) {
    coordinatorScope.launch {
      alertEmitter.fire(alertProfile)
    }
  }
}
```

Option B: Make `showBanner` a suspend function. But this would break all callers.

Go with Option A. Add `private lateinit var coordinatorScope: CoroutineScope` and save it in `initialize()`. Then add the alert fire logic.

**Q3 — Add alertEmitter test in NotificationCoordinatorTest:**

Add to the existing `safe mode banner has VIBRATE alert profile` test or add a new test:

```kotlin
@Test
fun `safe mode banner triggers alertEmitter fire with VIBRATE profile`() = runTest {
  val coordinator = createCoordinator()
  val initJob = Job(coroutineContext[Job])
  coordinator.initialize(this + initJob)
  testScheduler.runCurrent()

  safeModeActive.value = true
  testScheduler.runCurrent()

  // Verify alertEmitter.fire() was called with VIBRATE mode
  coVerify { alertEmitter.fire(match { it.mode == AlertMode.VIBRATE }) }

  initJob.cancel()
}
```

NOTE: Plan 07-14 (depends_on prerequisite) will have already migrated NotificationCoordinatorTest to StandardTestDispatcher. Write the new test using `runTest` + `testScheduler.runCurrent()` pattern to match.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.ReducedMotionIntegrationTest" --tests "*.WidgetSlotTest" --tests "*.NotificationCoordinatorTest" --console=plain 2>&amp;1 | tail -20</automated>
  </verify>
  <done>3 tautological tests rewritten to exercise production code. NotificationCoordinator.showBanner() calls alertEmitter.fire() when alertProfile is non-null. New test verifies alertEmitter.fire() invocation on safe mode banner.</done>
</task>

<task type="auto">
  <name>Task 2: Add unbind-cancels-provider-flow test (Q4)</name>
  <files>
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinatorTest.kt
  </files>
  <action>
The original plan specified "WhileSubscribed timeout: provider stops after last subscriber detaches (NF5)." The actual implementation uses cold Flow (not StateFlow with WhileSubscribed stateIn). The equivalent behavior is: when a widget is unbound, the binding job is cancelled, which cancels the flow collection, which stops the provider's `provideState()` flow.

Add a test that verifies: after `unbind(widgetId)`, the provider flow is no longer collected.

```kotlin
@Test
fun `unbind cancels provider flow collection`() = runTest {
  // Provider that tracks whether its flow is still being collected
  var isCollecting = false
  val mockBinder = mockk<WidgetDataBinder> {
    every { bind(any(), any(), any()) } returns flow {
      isCollecting = true
      try {
        emit(WidgetData.Empty)
        awaitCancellation()
      } finally {
        isCollecting = false
      }
    }
    every { minStalenessThresholdMs(any()) } returns null
  }

  val coordinator = createCoordinator(
    binder = mockBinder,
    // other params...
  )

  val initJob = Job(coroutineContext[Job])
  coordinator.initialize(this + initJob)

  val widget = testWidget(typeId = "essentials:clock")
  coordinator.bind(widget)
  testScheduler.runCurrent()

  assertThat(isCollecting).isTrue()
  assertThat(coordinator.activeBindings()).containsKey(widget.instanceId)

  coordinator.unbind(widget.instanceId)
  testScheduler.runCurrent()

  assertThat(isCollecting).isFalse()
  assertThat(coordinator.activeBindings()).doesNotContainKey(widget.instanceId)

  coordinator.destroy()
  initJob.cancel()
}
```

NOTE: The `createCoordinator` helper may need a `binder` parameter override. Check if it already has one (from the 07-11/07-12 additions). If the helper hardcodes a mock binder, add an optional `binder: WidgetDataBinder = defaultMockBinder` parameter.

Also NOTE: `awaitCancellation()` import: `import kotlinx.coroutines.awaitCancellation`. The `flow { ... awaitCancellation() }` pattern keeps the flow alive until cancellation, with the `finally` block tracking when cancellation happens.

This test proves:
1. Provider flow is actively collected after bind (isCollecting = true)
2. Provider flow stops collection after unbind (isCollecting = false)
3. Active bindings map is cleaned up after unbind

This is the behavioral equivalent of "WhileSubscribed stopTimeout" — the flow stops when there are no subscribers (the binding job IS the subscriber).
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.WidgetBindingCoordinatorTest" --console=plain 2>&amp;1 | tail -20</automated>
  </verify>
  <done>Unbind-cancels-provider-flow test passes, proving flow collection stops when widget is unbound. All existing WidgetBindingCoordinator tests still pass.</done>
</task>

</tasks>

<verification>
```
cd android && ./gradlew :feature:dashboard:testDebugUnitTest --console=plain 2>&1 | tail -20
```
All dashboard tests pass. Tautological tests rewritten. alertEmitter.fire() wired and tested. Unbind flow cancellation tested.
</verification>

<success_criteria>
- 3 tautological tests replaced with tests that exercise production code
- NotificationCoordinator.showBanner() invokes alertEmitter.fire() when alertProfile is non-null
- alertEmitter.fire() invocation verified in test
- Unbind cancels provider flow collection (WhileSubscribed equivalent)
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/07-dashboard-shell/07-15-SUMMARY.md`
</output>
