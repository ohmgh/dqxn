---
phase: 07-dashboard-shell
plan: 07
type: execute
wave: 5
depends_on: ["07-05", "07-06"]
files_modified:
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/DashboardViewModel.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/DashboardScreen.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/layer/OverlayNavHost.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/profile/ProfilePageTransition.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/DashboardViewModelTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/DashboardTestHarnessTest.kt
  - android/app/src/main/kotlin/app/dqxn/android/MainActivity.kt
autonomous: true
requirements:
  - F1.13
  - F1.14
  - F1.15
  - F1.16
  - F2.12
  - F2.16
  - F2.18
  - F2.20
  - F3.9
  - F3.15
  - NF2
  - NF3
  - NF4
  - NF-L1

must_haves:
  truths:
    - "DashboardViewModel routes DashboardCommand to correct coordinator"
    - "DashboardScreen assembles all layers: grid, button bar, banners, overlay nav host"
    - "OverlayNavHost scaffolded with empty route table (populated in Phase 10)"
    - "Profile switching via HorizontalPager (F1.29)"
    - "DashboardTestHarness integration: AddWidget -> WidgetBindingCoordinator creates job -> reports ACTIVE"
    - "dump-semantics returns dashboard_grid test tag after DashboardLayer registration"
  artifacts:
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/DashboardViewModel.kt"
      provides: "Thin coordinator host routing commands to coordinators"
      contains: "class DashboardViewModel"
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/DashboardScreen.kt"
      provides: "Root screen composable assembling all dashboard layers"
      contains: "fun DashboardScreen"
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/layer/OverlayNavHost.kt"
      provides: "Layer 1 navigation scaffold (empty route table)"
      contains: "fun OverlayNavHost"
  key_links:
    - from: "DashboardViewModel"
      to: "All 6 coordinators"
      via: "constructor injection + command routing loop"
      pattern: "when.*DashboardCommand"
    - from: "DashboardScreen"
      to: "DashboardLayer + OverlayNavHost + BannerHosts + ButtonBar"
      via: "layer stack composition"
      pattern: "DashboardLayer.*OverlayNavHost"
    - from: "MainActivity"
      to: "DashboardScreen"
      via: "setContent composition"
      pattern: "DashboardScreen"
---

<objective>
DashboardViewModel command routing, DashboardScreen layer assembly, OverlayNavHost scaffold, ProfilePageTransition, and integration tests via DashboardTestHarness.

Purpose: Final assembly plan that wires all coordinators into the ViewModel, composes the full screen with all layers, and validates end-to-end coordinator interactions via the test harness. This plan also integrates DashboardScreen into the existing :app MainActivity.

Output: Complete dashboard shell ready for widget rendering (Phase 8), overlay UI (Phase 10), and on-device validation.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-dashboard-shell/07-RESEARCH.md
@.planning/arch/state-management.md
@.planning/migration/phase-07.md
@.planning/phases/07-dashboard-shell/07-01-SUMMARY.md
@.planning/phases/07-dashboard-shell/07-02-SUMMARY.md
@.planning/phases/07-dashboard-shell/07-03-SUMMARY.md
@.planning/phases/07-dashboard-shell/07-04-SUMMARY.md
@.planning/phases/07-dashboard-shell/07-05-SUMMARY.md
@.planning/phases/07-dashboard-shell/07-06-SUMMARY.md
@.planning/phases/06-deployable-app-agentic-framework/06-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: DashboardViewModel + DashboardScreen + OverlayNavHost + ProfilePageTransition + MainActivity integration</name>
  <files>
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/DashboardViewModel.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/DashboardScreen.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/layer/OverlayNavHost.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/profile/ProfilePageTransition.kt
    android/app/src/main/kotlin/app/dqxn/android/MainActivity.kt
  </files>
  <action>
**DashboardViewModel.kt:** Package `app.dqxn.android.feature.dashboard`. `@HiltViewModel class DashboardViewModel @Inject constructor(val layoutCoordinator: LayoutCoordinator, val editModeCoordinator: EditModeCoordinator, val themeCoordinator: ThemeCoordinator, val widgetBindingCoordinator: WidgetBindingCoordinator, val notificationCoordinator: NotificationCoordinator, val profileCoordinator: ProfileCoordinator, private val savedStateHandle: SavedStateHandle, private val logger: DqxnLogger, private val errorReporter: ErrorReporter) : ViewModel()`.

Command processing:
- `private val commandChannel = Channel<DashboardCommand>(capacity = 64)`
- `fun dispatch(command: DashboardCommand)` — `viewModelScope.launch { commandChannel.send(command) }`
- `init` block launches command consumption loop per architecture doc: sequential `for (command in commandChannel)`, each wrapped in try/catch that logs + reports but NEVER kills the loop. `CancellationException` rethrown.

`routeCommand(command)`:
- `AddWidget` → `layoutCoordinator.handleAddWidget(command.widget)` then `widgetBindingCoordinator.bind(widget)`
- `RemoveWidget` → `widgetBindingCoordinator.unbind(command.widgetId)` then `layoutCoordinator.handleRemoveWidget(command.widgetId)`
- `MoveWidget` → `layoutCoordinator.handleMoveWidget(command.widgetId, command.newPosition)`
- `ResizeWidget` → `layoutCoordinator.handleResizeWidget(command.widgetId, command.newSize, command.newPosition)`
- `FocusWidget` → `editModeCoordinator.focusWidget(command.widgetId)`
- `EnterEditMode` → `editModeCoordinator.enterEditMode()`
- `ExitEditMode` → `editModeCoordinator.exitEditMode()`
- `SetTheme` → `themeCoordinator.handleSetTheme(command.themeId)`
- `PreviewTheme` → `themeCoordinator.handlePreviewTheme(command.theme)`
- `CycleThemeMode` → `themeCoordinator.handleCycleThemeMode()`
- `WidgetCrash` → `widgetBindingCoordinator.reportCrash(command.widgetId, command.typeId)` (WidgetBindingCoordinator already injects SafeModeManager per Plan 04 — do NOT inject SafeModeManager directly into ViewModel)
- `SwitchProfile` → `profileCoordinator.handleSwitchProfile(command.profileId)`
- `CreateProfile` → `profileCoordinator.handleCreateProfile(command.displayName, command.cloneCurrentId)`
- `DeleteProfile` → `profileCoordinator.handleDeleteProfile(command.profileId)`
- `ResetLayout` → `layoutCoordinator.handleResetLayout()`
- `ToggleStatusBar` → `editModeCoordinator.toggleStatusBar()`

`init` block: call `initialize(viewModelScope)` on all coordinators. Observe `layoutCoordinator.layoutState` to auto-bind new widgets via `widgetBindingCoordinator`.

SavedStateHandle: save/restore `activeProfileId`. `isEditMode` is NOT saved — always restore to view mode per architecture doc.

Slow command logging: if elapsed > 1s, log warning. In debug, `StrictMode.noteSlowCall`.

**DashboardScreen.kt:** Package `app.dqxn.android.feature.dashboard`. `@Composable fun DashboardScreen(viewModel: DashboardViewModel = hiltViewModel())`.

Collects state from all coordinators:
- `val layoutState by viewModel.layoutCoordinator.layoutState.collectAsState()` (Layer 0 — collectAsState, NOT collectAsStateWithLifecycle per CLAUDE.md)
- `val editState by viewModel.editModeCoordinator.editState.collectAsState()`
- `val themeState by viewModel.themeCoordinator.themeState.collectAsState()`
- `val profileState by viewModel.profileCoordinator.profileState.collectAsState()`
- `val banners by viewModel.notificationCoordinator.activeBanners.collectAsState()`
- `val dragState by viewModel.editModeCoordinator.dragState.collectAsState()`
- `val resizeState by viewModel.editModeCoordinator.resizeState.collectAsState()`

Layer stack per research:
```
CompositionLocalProvider(LocalDashboardTheme provides themeState.displayTheme) {
    Box(Modifier.fillMaxSize()) {
        ProfilePageTransition(profiles, activeProfileId) { profileId ->
            DashboardLayer(layoutState, editState, dragState, resizeState, ...)
        }
        DashboardButtonBar(editState, profileState, onCommand = viewModel::dispatch)
        NotificationBannerHost(banners.filter { it.priority != CRITICAL })
        OverlayNavHost(navController)
        CriticalBannerHost(banners.filter { it.priority == CRITICAL })
    }
}
```

Pause for overlays (F1.14): observe `navController.currentBackStackEntry`. When overlay route active (non-empty), call `widgetBindingCoordinator.pauseAll()`. On return, `resumeAll()`.

**OverlayNavHost.kt:** Package `app.dqxn.android.feature.dashboard.layer`. `@Composable fun OverlayNavHost(navController: NavHostController, onCommand: (DashboardCommand) -> Unit, modifier: Modifier = Modifier)`. Empty route table scaffold. `NavHost(navController, startDestination = Route.Empty)` with a single empty composable for Route.Empty. Routes populated in Phase 10 (WidgetPicker, Settings, WidgetSettings, Setup). `ExitTransition.None`/`EnterTransition.None` on WidgetSettings per replication advisory section 2.

**ProfilePageTransition.kt:** Package `app.dqxn.android.feature.dashboard.profile`. `@Composable fun ProfilePageTransition(profiles: ImmutableList<ProfileInfo>, activeProfileId: String, onSwitchProfile: (String) -> Unit, content: @Composable (profileId: String) -> Unit)`. Uses `HorizontalPager` from Compose Foundation. Single profile → no pager, direct content. Two+ profiles → `HorizontalPager(pageCount = profiles.size)`. Profile switching disabled during edit mode (F1.29 note: horizontal swipe is widget drag territory in edit mode).

**MainActivity.kt:** Update the existing blank canvas to render `DashboardScreen()`. Remove the placeholder `Box(Modifier.testTag("dashboard_grid"))` from Phase 6. The DashboardScreen now provides the real dashboard with `dashboard_grid` test tag on the grid.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:compileDebugKotlin :app:compileDebugKotlin --console=plain 2>&1 | tail -5</automated>
  </verify>
  <done>DashboardViewModel routes all DashboardCommand variants to correct coordinators. DashboardScreen assembles all layers. OverlayNavHost scaffolded with empty route table. ProfilePageTransition uses HorizontalPager. MainActivity renders DashboardScreen.</done>
</task>

<task type="auto">
  <name>Task 2: DashboardViewModel tests + DashboardTestHarness integration tests</name>
  <files>
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/DashboardViewModelTest.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/DashboardTestHarnessTest.kt
  </files>
  <action>
**DashboardViewModelTest.kt:** JUnit5 + `@Tag("fast")` + MockK. Tests:
- `dispatch AddWidget routes to layoutCoordinator.handleAddWidget`
- `dispatch RemoveWidget routes to widgetBindingCoordinator.unbind then layoutCoordinator.handleRemoveWidget`
- `dispatch EnterEditMode routes to editModeCoordinator.enterEditMode`
- `dispatch SetTheme routes to themeCoordinator.handleSetTheme`
- `dispatch SwitchProfile routes to profileCoordinator.handleSwitchProfile`
- `dispatch WidgetCrash routes to widgetBindingCoordinator.reportCrash` (which delegates to SafeModeManager internally)
- `dispatch CycleThemeMode routes to themeCoordinator.handleCycleThemeMode`
- `command handler exception does not kill processing loop` — mock coordinator that throws, dispatch another command, verify second command processed
- `slow command logged` — mock coordinator with delay, verify logger.warn called
- `all 16+ command variants routed without crash` — dispatch every DashboardCommand subtype

Mock all 6 coordinators. Use `StandardTestDispatcher`. Verify correct coordinator method called for each command variant.

**DashboardTestHarnessTest.kt:** JUnit5 + `@Tag("fast")`. Uses DashboardTestHarness from testFixtures. Integration tests with REAL coordinators (not mocks):
- `harness initializes all coordinators without crash`
- `dispatch AddWidget -> WidgetBindingCoordinator creates binding job -> reports ACTIVE` — the critical integration test from Phase 7 success criteria #3
- `dispatch EnterEditMode -> editState.isEditMode true`
- `dispatch ExitEditMode -> editState.isEditMode false`
- `dispatch SetTheme -> themeState.currentTheme updated`
- `safe mode: 4 WidgetCrash commands in 60s -> safeMode() returns active`
- `dispatch SwitchProfile -> layout loads new profile widgets`
- `dispatch ResetLayout -> layout contains preset widgets`
- `HarnessStateOnFailure dumps state on test failure` — deliberately fail assertion, verify TestWatcher output

These integration tests validate coordinator-to-coordinator interactions that mocked unit tests cannot catch. They prove the wiring works end-to-end without an Android device.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --console=plain 2>&1 | tail -10</automated>
  </verify>
  <done>DashboardViewModel tests verify command routing to all coordinators. DashboardTestHarness integration tests verify AddWidget -> bind -> ACTIVE flow, safe mode trigger, and cross-coordinator interactions.</done>
</task>

</tasks>

<verification>
- `./gradlew :feature:dashboard:compileDebugKotlin :app:compileDebugKotlin --console=plain` succeeds
- `./gradlew :feature:dashboard:testDebugUnitTest --console=plain` passes all ViewModel and harness tests
- `./gradlew test --console=plain` — full suite remains green
- DashboardViewModel routes all 16+ command variants
- DashboardTestHarness: AddWidget → bind → ACTIVE flow works end-to-end
- Safe mode: 4 crashes in 60s triggers safe mode in harness test
- OverlayNavHost scaffolded with empty route table (no crash)
</verification>

<success_criteria>
- DashboardViewModel routes DashboardCommand to correct coordinator (Phase 7 SC #2)
- DashboardTestHarness integration: AddWidget -> bind -> ACTIVE (Phase 7 SC #3)
- Safe mode: 4+ crashes in 60s triggers (Phase 7 SC #4)
- OverlayNavHost scaffolded empty (Phase 7 SC deferred overlay routes)
- ProfilePageTransition via HorizontalPager (F1.29)
- :app compiles with DashboardScreen integrated
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-dashboard-shell/07-07-SUMMARY.md`
</output>
