---
phase: 07-dashboard-shell
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - android/feature/dashboard/build.gradle.kts
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/command/DashboardCommand.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/LayoutCoordinator.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/GridPlacementEngine.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/safety/SafeModeManager.kt
  - android/feature/dashboard/src/testFixtures/kotlin/app/dqxn/android/feature/dashboard/test/DashboardTestHarness.kt
  - android/feature/dashboard/src/testFixtures/kotlin/app/dqxn/android/feature/dashboard/test/HarnessStateOnFailure.kt
  - android/feature/dashboard/src/testFixtures/kotlin/app/dqxn/android/feature/dashboard/test/FakeLayoutRepository.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/LayoutCoordinatorTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/grid/GridPlacementEngineTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/safety/SafeModeManagerTest.kt
autonomous: true
requirements:
  - F1.3
  - F1.4
  - F1.10
  - F1.12
  - F1.20
  - F1.26
  - F1.27
  - F1.28
  - F2.6
  - F2.10
  - F2.11
  - NF6
  - NF7
  - NF38
  - NF45
  - NF46

must_haves:
  truths:
    - "LayoutCoordinator loads widgets from LayoutRepository and exposes them via StateFlow"
    - "GridPlacementEngine finds optimal position for new widgets avoiding overlap"
    - "No-straddle snap prevents widgets from crossing configuration boundaries"
    - "SafeModeManager detects 4+ crashes in 60s rolling window across all widgets"
    - "DashboardTestHarness DSL enables coordinator-level testing with real implementations"
  artifacts:
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/command/DashboardCommand.kt"
      provides: "Sealed interface for all discrete dashboard commands"
      contains: "sealed interface DashboardCommand"
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/LayoutCoordinator.kt"
      provides: "Canvas positioning, viewport culling, grid placement"
      contains: "class LayoutCoordinator"
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/GridPlacementEngine.kt"
      provides: "Optimal widget placement with no-straddle snap"
      contains: "class GridPlacementEngine"
    - path: "android/feature/dashboard/src/testFixtures/kotlin/app/dqxn/android/feature/dashboard/test/DashboardTestHarness.kt"
      provides: "DSL for coordinator-level testing"
      contains: "class DashboardTestHarness"
  key_links:
    - from: "LayoutCoordinator"
      to: "LayoutRepository"
      via: "constructor injection"
      pattern: "layoutRepository.*LayoutRepository"
    - from: "LayoutCoordinator"
      to: "GridPlacementEngine"
      via: "constructor injection for widget placement"
      pattern: "gridPlacementEngine.*GridPlacementEngine"
    - from: "SafeModeManager"
      to: "CrashRecovery"
      via: "delegates to Phase 6 CrashRecovery for persistence"
      pattern: "crashRecovery.*CrashRecovery"
---

<objective>
Foundation types, LayoutCoordinator, GridPlacementEngine, SafeModeManager, and test infrastructure for the dashboard shell.

Purpose: Establish the foundational coordinator (LayoutCoordinator) that all other coordinators depend on, the command sealed interface for all dashboard operations, and the test harness DSL that all subsequent plans use for verification.

Output: DashboardCommand sealed interface, LayoutCoordinator with widget CRUD and viewport culling, GridPlacementEngine with no-straddle snap, SafeModeManager, DashboardTestHarness + fakes in testFixtures.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/07-dashboard-shell/07-RESEARCH.md
@.planning/arch/state-management.md
@.planning/migration/phase-07.md
@.planning/migration/replication-advisory.md
@.planning/phases/05-core-infrastructure/05-03-SUMMARY.md
@.planning/phases/06-deployable-app-agentic-framework/06-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build config + DashboardCommand + LayoutCoordinator + GridPlacementEngine + SafeModeManager</name>
  <files>
    android/feature/dashboard/build.gradle.kts
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/command/DashboardCommand.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/LayoutCoordinator.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/GridPlacementEngine.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/safety/SafeModeManager.kt
  </files>
  <action>
**build.gradle.kts:** Add dependencies beyond what `dqxn.android.feature` auto-provides. Add: `implementation(project(":core:design"))`, `implementation(project(":core:thermal"))`, `implementation(project(":data"))`, `implementation(project(":sdk:analytics"))`. Enable testFixtures: `android { testFixtures { enable = true } }`. Add `testImplementation(testFixtures(project(":sdk:contracts")))` for `TestDataProvider`. Add Turbine, Truth, MockK test deps. Add `testFixturesImplementation` for kotlinx-coroutines-test, Truth.

**DashboardCommand.kt:** Package `app.dqxn.android.feature.dashboard.command`. Sealed interface with `val traceId: String?` on every variant. Variants (all data classes except noted):
- `AddWidget(widget: DashboardWidgetInstance, profileId: String? = null, addToAllProfiles: Boolean = false)`
- `RemoveWidget(widgetId: String)`
- `MoveWidget(widgetId: String, newPosition: GridPosition)`
- `ResizeWidget(widgetId: String, newSize: GridSize, newPosition: GridPosition?)`
- `FocusWidget(widgetId: String?)`
- `EnterEditMode` (data object)
- `ExitEditMode` (data object)
- `SetTheme(themeId: String)`
- `PreviewTheme(theme: DashboardThemeDefinition?)`
- `WidgetCrash(widgetId: String, typeId: String, throwable: Throwable)`
- `SwitchProfile(profileId: String)`
- `CreateProfile(displayName: String, cloneCurrentId: String? = null)`
- `DeleteProfile(profileId: String)`
- `ResetLayout`
- `ToggleStatusBar`
- `CycleThemeMode`

**LayoutCoordinator.kt:** Package `app.dqxn.android.feature.dashboard.coordinator`. `@Inject constructor` with `layoutRepository: LayoutRepository`, `presetLoader: PresetLoader`, `gridPlacementEngine: GridPlacementEngine`, `@param:IoDispatcher ioDispatcher: CoroutineDispatcher`, `logger: DqxnLogger`.

State class: `data class LayoutState(val widgets: ImmutableList<DashboardWidgetInstance>, val isLoading: Boolean, val activeProfileId: String)` — `@Immutable`.

Methods: `initialize(scope: CoroutineScope)` — loads from `layoutRepository.observeWidgets()` on IO, updates `_layoutState`. `handleAddWidget(widget)` — uses `gridPlacementEngine.findOptimalPosition()`, updates state, persists. `handleRemoveWidget(widgetId)` — removes from state, cancels via WidgetBindingCoordinator (callback interface), persists. `handleMoveWidget(widgetId, position)` — updates position, persists. `handleResizeWidget(widgetId, size, position)` — updates size + optional position (non-BottomRight handles), persists. `handleResetLayout()` — reloads from PresetLoader. `visibleWidgets(viewportCols, viewportRows): ImmutableList<DashboardWidgetInstance>` — viewport culling filter.

Layout save via `layoutRepository` which already debounces at 500ms (Phase 5). No additional debouncing needed in coordinator.

**GridPlacementEngine.kt:** Package `app.dqxn.android.feature.dashboard.grid`. `@Inject constructor` with `logger: DqxnLogger`.

Core method: `findOptimalPosition(widget: DashboardWidgetInstance, existingWidgets: ImmutableList<DashboardWidgetInstance>, viewportCols: Int, viewportRows: Int, configBoundaries: List<ConfigurationBoundary> = emptyList()): GridPosition`. Algorithm: scan grid positions row by row, column by column. For each candidate position, check: (1) no overlap with existing widgets, (2) no straddle across any configuration boundary (F1.27), (3) prefer center of viewport. Return first valid position; if none found, place at bottom-right extending canvas.

`snapToGrid(pixelX: Float, pixelY: Float, gridUnitPx: Float): GridPosition` — midpoint snap per replication advisory section 6: `roundToInt(pixelPos / gridUnitPx)`. Snap to 2-unit boundaries.

`enforceNoStraddle(position: GridPosition, size: GridSize, boundaries: List<ConfigurationBoundary>): GridPosition` — if widget bounding box crosses a boundary, snap to nearest side (inside or outside, whichever is closer).

`data class ConfigurationBoundary(val name: String, val rect: IntRect)` — viewport rectangle for a display configuration.

**SafeModeManager.kt:** Package `app.dqxn.android.feature.dashboard.safety`. `@Inject constructor` with `crashRecovery: CrashRecovery` (from Phase 6 `:app`), `logger: DqxnLogger`. Wraps CrashRecovery's timestamp-based rolling window. `val safeModeActive: StateFlow<Boolean>`. `fun reportCrash(widgetId: String, typeId: String)` — records crash timestamp in CrashRecovery, checks if 4+ crashes in 60s window (cross-widget counting, not per-widget). `fun resetSafeMode()` — clears crash evidence.

Note: SafeModeManager depends on CrashRecovery from `:app`. Since `:feature:dashboard` cannot depend on `:app`, define a `CrashCounter` interface in `:feature:dashboard` that CrashRecovery can implement. Wire via Hilt. Alternatively, extract the crash-counting logic into SafeModeManager itself using SharedPreferences directly (same pattern as CrashRecovery). Choose the SharedPreferences approach — SafeModeManager owns its own crash timestamps via `SharedPreferences.edit().commit()` for process-death safety.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:compileDebugKotlin --console=plain 2>&1 | tail -5</automated>
    <manual>Verify DashboardCommand has all 16 variants, LayoutCoordinator exposes StateFlow of LayoutState</manual>
  </verify>
  <done>DashboardCommand sealed interface defined with all variants. LayoutCoordinator loads/mutates widget state with viewport culling. GridPlacementEngine places widgets optimally with no-straddle snap. SafeModeManager tracks cross-widget crash counting with 60s rolling window.</done>
</task>

<task type="auto">
  <name>Task 2: Test infrastructure + LayoutCoordinator tests + GridPlacementEngine tests + SafeModeManager tests</name>
  <files>
    android/feature/dashboard/src/testFixtures/kotlin/app/dqxn/android/feature/dashboard/test/DashboardTestHarness.kt
    android/feature/dashboard/src/testFixtures/kotlin/app/dqxn/android/feature/dashboard/test/HarnessStateOnFailure.kt
    android/feature/dashboard/src/testFixtures/kotlin/app/dqxn/android/feature/dashboard/test/FakeLayoutRepository.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/LayoutCoordinatorTest.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/grid/GridPlacementEngineTest.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/safety/SafeModeManagerTest.kt
  </files>
  <action>
**DashboardTestHarness.kt:** Package `app.dqxn.android.feature.dashboard.test`. DSL entry point: `fun dashboardTest(fakeLayout: Boolean = false, block: suspend DashboardTestScope.() -> Unit) = runTest { ... }`. Creates coordinator instances with real implementations by default. `DashboardTestScope` exposes: `dispatch(command)`, `layoutState()`, `editState()`, `themeState()`, `bindingJobs()`, `safeMode()`, `widgetStatuses()`. Uses `StandardTestDispatcher` (never UnconfinedTestDispatcher per CLAUDE.md). FakeLayoutRepository used when `fakeLayout = true`.

**HarnessStateOnFailure.kt:** JUnit5 `TestWatcher` that auto-dumps harness state as JSON on test failure. Captures: layout widgets, theme, widget statuses, binding jobs. Format matches agentic `diagnose-*` JSON structure.

**FakeLayoutRepository.kt:** Implements `LayoutRepository` interface. In-memory `MutableStateFlow<List<DashboardWidgetInstance>>` backing store. Methods: `observeWidgets()`, `addWidget()`, `removeWidget()`, `updateWidget()`, `observeProfiles()`, `createProfile()`, `cloneProfile()`, `switchProfile()`, `deleteProfile()`. All operations immediate (no debounce).

**LayoutCoordinatorTest.kt:** JUnit5 + `@Tag("fast")`. Tests:
- `initialize loads widgets from repository` — inject FakeLayoutRepository with 3 widgets, verify layoutState contains them
- `handleAddWidget places widget via GridPlacementEngine` — verify new widget added to state at engine-determined position
- `handleRemoveWidget removes from state` — add then remove, verify state
- `handleMoveWidget updates position` — move widget, verify new position in state
- `handleResizeWidget updates size and optional position` — resize from non-BottomRight handle, verify both size and position updated
- `handleResetLayout reloads from PresetLoader` — verify widgets replaced with preset
- `visibleWidgets filters by viewport` — add widgets inside and outside viewport, verify filtering
- `viewport culling returns zero for fully off-screen widgets` — widget at col=100 with viewport of 20 cols not returned

**GridPlacementEngineTest.kt:** JUnit5 + `@Tag("fast")`. Tests:
- `findOptimalPosition on empty grid returns center-biased position`
- `findOptimalPosition avoids existing widget overlap`
- `findOptimalPosition respects no-straddle snap on configuration boundary`
- `snapToGrid snaps to nearest 2-unit boundary` — verify midpoint snap behavior
- `enforceNoStraddle snaps widget to nearest side of boundary`
- `no valid position extends canvas downward`
- `configuration boundary intersection detection` — widget partially crossing boundary detected

**SafeModeManagerTest.kt:** JUnit5 + `@Tag("fast")`. Tests:
- `no crashes means safe mode inactive`
- `3 crashes in 60s does not trigger safe mode` — boundary condition
- `4 crashes in 60s triggers safe mode` — exactly at threshold
- `4 crashes from 4 different widgets triggers safe mode` — cross-widget counting
- `crashes older than 60s are expired` — use TestCoroutineScheduler to advance time
- `resetSafeMode clears state`
- `safe mode survives process death` — SharedPreferences commit() verified
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --console=plain 2>&1 | tail -10</automated>
    <manual>Verify all tests pass with 0 failures</manual>
  </verify>
  <done>DashboardTestHarness DSL usable for coordinator testing. LayoutCoordinator tests verify CRUD + viewport culling. GridPlacementEngine tests verify placement + no-straddle snap. SafeModeManager tests verify cross-widget crash counting with 60s rolling window.</done>
</task>

</tasks>

<verification>
- `./gradlew :feature:dashboard:compileDebugKotlin --console=plain` succeeds
- `./gradlew :feature:dashboard:testDebugUnitTest --console=plain` passes all tests
- DashboardCommand has 16+ variants covering all discrete operations
- GridPlacementEngine.findOptimalPosition respects no-straddle snap
- SafeModeManager counts cross-widget crashes (not per-widget)
- DashboardTestHarness usable in subsequent plan test files
</verification>

<success_criteria>
- LayoutCoordinator manages widget state with add/remove/move/resize/reset
- GridPlacementEngine places widgets optimally with no-straddle snap at configuration boundaries
- SafeModeManager detects 4+ crashes in 60s rolling window across all widgets
- Test infrastructure (harness, fakes, watcher) available via testFixtures for all subsequent plans
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-dashboard-shell/07-01-SUMMARY.md`
</output>
