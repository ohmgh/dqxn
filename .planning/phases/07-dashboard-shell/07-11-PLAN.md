---
phase: 07-dashboard-shell
plan: 11
type: execute
wave: 1
depends_on: []
files_modified:
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinatorTest.kt
autonomous: true
requirements: [NF16]
gap_closure: true

must_haves:
  truths:
    - "Exponential backoff retry test proves 1s, 2s, 4s delays via advanceTimeBy"
    - "Max retries test proves ProviderError status after 3 failed attempts"
    - "Successful emission resets error count test proves recovery"
  artifacts:
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinatorTest.kt"
      provides: "3 deferred retry tests"
      contains: "backoff|retries exhausted|resets error count"
  key_links:
    - from: "retry tests"
      to: "WidgetBindingCoordinator.handleBindingError"
      via: "advanceTimeBy drives delay-based retry schedule"
      pattern: "advanceTimeBy"
---

<objective>
Add the 3 retry tests that were deferred from the original 07-04 execution due to coroutine testing difficulties.

Purpose: The exponential backoff retry logic (1s/2s/4s, max 3 attempts) is the core failure recovery mechanism in WidgetBindingCoordinator. It was verified "by code review" only — no test proves the timing, termination, or recovery behavior. The original agent couldn't make these work due to "kotlinx.coroutines.test incompatibility with CoroutineExceptionHandler + SupervisorJob + delay-based retry cascades."

Approach: The key insight the original agent missed: use a provider that tracks invocation count and throws on specific calls. The CoroutineExceptionHandler in WidgetBindingCoordinator catches the exception and calls handleBindingError, which launches a delayed retry via `bindingScope.launch { delay(backoffMs); startBinding(widget) }`. With StandardTestDispatcher, `advanceTimeBy(1000)` drives past the first delay, triggering retry #2. Advance again for retry #3, etc.

The cascade issue occurs because each retry creates a new coroutine that immediately crashes, which triggers another handleBindingError. With StandardTestDispatcher (not Unconfined), these don't cascade instantly — they queue and advance predictably.

Output: 3 new tests in WidgetBindingCoordinatorTest, all passing.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinatorTest.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinator.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetDataBinder.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 3 deferred retry tests to WidgetBindingCoordinatorTest</name>
  <files>
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/WidgetBindingCoordinatorTest.kt
  </files>
  <action>
Add a new test provider class and 3 tests. Remove the NOTE comment about deferred retry tests (lines 328-334).

**New provider: CountingCrashProvider**

A provider that throws on the first N calls to `provideState()`, then emits normally. Tracks call count.

```kotlin
class CountingCrashProvider(
    private val crashUntilCall: Int = Int.MAX_VALUE,
    override val sourceId: String = "test:counting-crash",
    override val snapshotType: KClass<TestSnapshot> = TestSnapshot::class,
) : DataProvider<TestSnapshot> {
    var callCount = 0
        private set
    override val displayName = "Counting Crash Provider"
    override val description = "Crashes until call #$crashUntilCall"
    override val dataType = DataTypes.SPEED
    override val priority = ProviderPriority.SIMULATED
    override val schema = DataSchema(emptyList(), 3000L)
    override val setupSchema = emptyList<SetupPageDefinition>()
    override val subscriberTimeout = 5.seconds
    override val firstEmissionTimeout = 5.seconds
    override val requiredAnyEntitlement: Set<String>? = null
    override val isAvailable = true
    override val connectionState = flowOf(true)
    override val connectionErrorDescription = flowOf<String?>(null)
    override fun provideState(): Flow<TestSnapshot> = flow {
        callCount++
        if (callCount <= crashUntilCall) {
            throw RuntimeException("Crash #$callCount")
        }
        emit(TestSnapshot(timestamp = System.currentTimeMillis()))
        // Keep the flow alive so the job stays active
        delay(Long.MAX_VALUE)
    }
}
```

**Test 1: `exponential backoff retry timing 1s 2s 4s`**

```kotlin
@Test
fun `exponential backoff retry timing 1s 2s 4s`() = runTest {
    val provider = CountingCrashProvider(crashUntilCall = 3)
    val renderer = TestWidgetRenderer(
        typeId = "essentials:clock",
        compatibleSnapshots = setOf(TestSnapshot::class),
    )
    val widgetRegistry = WidgetRegistryImpl(setOf(renderer), logger)
    val providerRegistry = DataProviderRegistryImpl(setOf(provider), FakeEntitlementManager(), logger)
    val coordinator = createCoordinator(widgetRegistry, providerRegistry)

    val initJob = Job(coroutineContext[Job])
    coordinator.initialize(this + initJob)

    val widget = testWidget(typeId = "essentials:clock")
    coordinator.bind(widget)
    advanceUntilIdle() // crash #1 occurs immediately

    assertThat(provider.callCount).isEqualTo(1)

    // First retry after 1s backoff
    advanceTimeBy(1001)
    advanceUntilIdle()
    assertThat(provider.callCount).isEqualTo(2) // crash #2

    // Second retry after 2s backoff
    advanceTimeBy(2001)
    advanceUntilIdle()
    assertThat(provider.callCount).isEqualTo(3) // crash #3

    // Third retry after 4s backoff — should succeed (crashUntilCall=3, call #4 emits)
    advanceTimeBy(4001)
    advanceUntilIdle()
    assertThat(provider.callCount).isEqualTo(4) // success

    initJob.cancel()
}
```

NOTE: The exact timing may need adjustment. handleBindingError increments count THEN checks `if (count > MAX_RETRIES)`. With MAX_RETRIES=3: crash 1 → count=1 → retry(1s), crash 2 → count=2 → retry(2s), crash 3 → count=3 → retry(4s), crash 4 → count=4 → exceeds MAX_RETRIES → ProviderError status. So `crashUntilCall=3` means 3 crashes then success on call 4, but call 4 has count=4 which exceeds MAX_RETRIES. The provider emits successfully, but handleBindingError isn't called on success. WAIT — if call 4 succeeds, provideState() emits without throwing, so CoroutineExceptionHandler is never invoked. The count=4 branch is never reached. So this should work.

Actually, re-read the code more carefully: `bind()` resets errorCounts to 0. `startBinding()` does NOT reset. After crash #1, handleBindingError sets count=1, schedules retry with startBinding. Crash #2: count=2. Crash #3: count=3. Then retry at 4s: count would be 3 still (startBinding doesn't increment, only handleBindingError does). If call #4 succeeds, the flow emits and the successful emission in the collect block resets `errorCounts[widget.instanceId] = 0`. The binding stays active.

If this test proves fragile due to the CoroutineExceptionHandler + SupervisorJob interaction, an alternative approach: mock the binder instead of using a real one. `mockk<WidgetDataBinder>()` with `every { bind(...) }` returning a flow that throws on first 3 calls then emits. This avoids the provider registry resolution entirely and tests the coordinator's retry logic in isolation.

**Test 2: `max 3 retries then ProviderError status`**

Use `CountingCrashProvider(crashUntilCall = Int.MAX_VALUE)` — always crashes.

```kotlin
@Test
fun `max 3 retries then ProviderError status`() = runTest {
    val provider = CountingCrashProvider(crashUntilCall = Int.MAX_VALUE)
    // ... same setup as test 1 ...
    coordinator.bind(widget)
    advanceUntilIdle() // crash #1

    advanceTimeBy(1001); advanceUntilIdle() // crash #2
    advanceTimeBy(2001); advanceUntilIdle() // crash #3
    advanceTimeBy(4001); advanceUntilIdle() // crash #4 → count exceeds MAX_RETRIES

    val status = coordinator.widgetStatus(widget.instanceId).value
    assertThat(status.overlayState).isInstanceOf(WidgetRenderState.ConnectionError::class.java)

    initJob.cancel()
}
```

**Test 3: `successful emission resets error count`**

Use a provider that crashes once, then emits, then the test re-binds and verifies the error count was reset by the successful emission.

```kotlin
@Test
fun `successful emission resets error count`() = runTest {
    val provider = CountingCrashProvider(crashUntilCall = 1)
    // ... same setup ...
    coordinator.bind(widget)
    advanceUntilIdle() // crash #1

    advanceTimeBy(1001); advanceUntilIdle() // retry succeeds (call #2)

    // Verify data was received (error count reset by successful emission)
    val data = coordinator.widgetData(widget.instanceId).value
    assertThat(data.hasData()).isTrue()

    // Active binding should exist (not terminated by retries)
    assertThat(coordinator.activeBindings()).containsKey(widget.instanceId)

    initJob.cancel()
}
```

CRITICAL: If any of these tests hang, the issue is the CoroutineExceptionHandler dispatching. With StandardTestDispatcher, exceptions thrown inside `launch(exceptionHandler) { ... }` are caught by the handler which calls `handleBindingError`, which calls `bindingScope.launch { delay(...); startBinding(...) }`. Each of these launches is queued on the scheduler and driven by `advanceTimeBy`/`advanceUntilIdle`. This SHOULD work deterministically. If it doesn't, fall back to mocking `WidgetDataBinder` to control the flow behavior directly.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.WidgetBindingCoordinatorTest" --console=plain 2>&amp;1 | tail -20</automated>
  </verify>
  <done>3 retry tests added and passing: backoff timing, max retries exhaustion, error count reset. NOTE comment about deferred tests removed.</done>
</task>

</tasks>

<verification>
```
cd android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.WidgetBindingCoordinatorTest" --console=plain
```
All 10 tests pass (7 existing + 3 new retry tests).
</verification>

<success_criteria>
- Exponential backoff 1s/2s/4s timing verified by advanceTimeBy
- Max 3 retries then ProviderError status verified
- Successful emission resets error count verified
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-dashboard-shell/07-11-SUMMARY.md`
</output>
