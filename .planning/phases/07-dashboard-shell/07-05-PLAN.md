---
phase: 07-dashboard-shell
plan: 05
type: execute
wave: 3
depends_on: ["07-01", "07-04"]
files_modified:
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/ProfileCoordinator.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinator.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/di/DashboardModule.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/ProfileCoordinatorTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinatorTest.kt
autonomous: true
requirements:
  - F1.29
  - F1.30
  - F2.20
  - F9.1
  - F9.2
  - F9.3
  - F9.4
  - NF41
  - NF42

must_haves:
  truths:
    - "ProfileCoordinator manages profile CRUD with per-profile canvas independence"
    - "New profile clones current dashboard"
    - "Widget added to profile A not visible in profile B"
    - "NotificationCoordinator re-derives all condition-based banners from singleton state on recreation"
    - "Notification priority ordering: CRITICAL > HIGH > NORMAL > LOW"
    - "Low storage warning banner emitted when StorageMonitor.isLow is true"
  artifacts:
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/ProfileCoordinator.kt"
      provides: "Profile create/clone/switch/delete with per-profile canvas"
      contains: "class ProfileCoordinator"
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinator.kt"
      provides: "Banner derivation, toast queue, priority ordering"
      contains: "class NotificationCoordinator"
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/di/DashboardModule.kt"
      provides: "Hilt module binding coordinators, registries, and binder"
      contains: "@Module"
  key_links:
    - from: "ProfileCoordinator"
      to: "LayoutRepository"
      via: "profile CRUD operations on layout persistence"
      pattern: "layoutRepository.*LayoutRepository"
    - from: "NotificationCoordinator"
      to: "SafeModeManager"
      via: "observes safe mode state for CRITICAL banner"
      pattern: "safeModeManager.*SafeModeManager"
    - from: "NotificationCoordinator"
      to: "StorageMonitor"
      via: "observes low storage for HIGH banner"
      pattern: "storageMonitor.*StorageMonitor"
---

<objective>
ProfileCoordinator with per-profile canvas independence, NotificationCoordinator with banner re-derivation from singletons, and DashboardModule Hilt wiring.

Purpose: Profile management and notification coordination are the last two coordinators. ProfileCoordinator depends on LayoutRepository (available from Plan 01). NotificationCoordinator depends on WidgetBindingCoordinator for widget status observation (Plan 04). DashboardModule wires all coordinators into the Hilt graph.

Output: Complete coordinator set (all 6), DashboardModule Hilt module, notification banner system with priority ordering.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-dashboard-shell/07-RESEARCH.md
@.planning/arch/state-management.md
@.planning/arch/platform.md
@.planning/migration/phase-07.md
@.planning/phases/07-dashboard-shell/07-01-SUMMARY.md
@.planning/phases/07-dashboard-shell/07-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: ProfileCoordinator + NotificationCoordinator + DashboardModule</name>
  <files>
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/ProfileCoordinator.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinator.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/di/DashboardModule.kt
  </files>
  <action>
**ProfileCoordinator.kt:** Package `app.dqxn.android.feature.dashboard.coordinator`. `@Inject constructor` with `layoutRepository: LayoutRepository`, `logger: DqxnLogger`.

State: `data class ProfileState(val profiles: ImmutableList<ProfileInfo>, val activeProfileId: String)` — `@Immutable`. `data class ProfileInfo(val id: String, val displayName: String, val isDefault: Boolean)` — `@Immutable`.

Methods:
- `initialize(scope: CoroutineScope)` — observes `layoutRepository.observeProfiles()`, initializes profile list
- `handleSwitchProfile(profileId: String)` — calls `layoutRepository.switchProfile(profileId)`, updates LayoutCoordinator via callback/event. Active profile changes trigger LayoutCoordinator to reload widgets for the new profile.
- `handleCreateProfile(displayName: String, cloneCurrentId: String?)` — if cloneCurrentId provided, calls `layoutRepository.cloneProfile(cloneCurrentId, displayName)` (F1.30 new profile clones current). Otherwise creates empty profile. Updates profile list state.
- `handleDeleteProfile(profileId: String)` — fails silently if trying to delete default profile. Switches to default if deleting active profile. Calls `layoutRepository.deleteProfile(profileId)`.
- `profileCount(): Int` — used by bottom bar to decide whether to show profile icons (2+ required per F1.9, F1.29).

Per-profile independence (F1.30): Each profile owns its own widget set via `LayoutRepository`. Switching profile reloads the widget list from persistence. No shared state between profiles.

**NotificationCoordinator.kt:** Package `app.dqxn.android.feature.dashboard.coordinator`. `@Inject constructor` with `safeModeManager: SafeModeManager`, `storageMonitor: StorageMonitor`, `alertEmitter: AlertEmitter`, `logger: DqxnLogger`.

State:
- `val activeBanners: StateFlow<ImmutableList<InAppNotification.Banner>>` — derived from condition state
- `val toasts: Channel<InAppNotification.Toast>(capacity = Channel.BUFFERED)` — single consumer, exactly-once

Banners are condition-keyed (NOT UUID-keyed — prevents flicker per pitfall 4 in research):
- `"safe_mode"` — CRITICAL priority. Shown when `safeModeManager.safeModeActive` is true. Message: "App recovered from repeated crashes. Reset to fix."
- `"low_storage"` — HIGH priority. Shown when `storageMonitor.isLow` is true (NF41). Message: "Storage is running low. Free up space to save changes."
- `"layout_save_failed"` — HIGH priority. Shown when LayoutRepository reports save failure (NF42). Message: "Unable to save layout. Free up storage space."

Methods:
- `initialize(scope: CoroutineScope)` — launches 3+ coroutines observing singleton state flows with `distinctUntilChanged()` to prevent banner flicker. Each coroutine: state active → `showBanner(id, priority, ...)`, state inactive → `dismissBanner(id)`.
- `showBanner(id: String, priority: NotificationPriority, message: String, actions: ImmutableList<NotificationAction> = persistentListOf())` — adds/updates banner by id. Banners sorted by priority.
- `dismissBanner(id: String)` — removes banner by id.
- `showToast(toast: InAppNotification.Toast)` — sends to toast channel.
- `emitConnectionStatus(deviceName: String, connected: Boolean)` — silent connection notification (F9.1). Creates banner with NORMAL priority for disconnect, dismisses on connect.

Alert modes (F9.2): Each notification carries an `AlertProfile` with mode (SILENT/VIBRATE/SOUND). When banner shown, delegates to `alertEmitter` (AlertSoundManager from Phase 6) for audio/vibration.

TTS (F9.3): `AlertProfile.ttsMessage` passed to `alertEmitter.ttsReadout()` for qualifying notifications.

Custom sound URIs (F9.4): `AlertProfile.soundUri` passed to `alertEmitter.playCustomSound()`.

**Re-derivation pattern:** On ViewModel recreation (process death), NotificationCoordinator re-initializes and all singleton state flows (`safeModeManager.safeModeActive`, `storageMonitor.isLow`) re-emit current values. `distinctUntilChanged()` ensures no duplicate processing. This guarantees no lost banners after process death.

**DashboardModule.kt:** Package `app.dqxn.android.feature.dashboard.di`. `@Module @InstallIn(SingletonComponent::class)` for singleton-scoped bindings (registries). Separate `@Module @InstallIn(ViewModelComponent::class)` for coordinator-scoped bindings if needed, or just use constructor injection (coordinators are injected into ViewModel which is ViewModelScoped).

Bindings:
- `@Binds @Singleton` WidgetRegistry → WidgetRegistryImpl
- `@Binds @Singleton` DataProviderRegistry → DataProviderRegistryImpl
- `@Provides @Singleton` StorageMonitor (if not constructor-injectable)
- No `@Binds` for coordinators — they're constructor-injected into DashboardViewModel directly
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:compileDebugKotlin --console=plain 2>&1 | tail -5</automated>
  </verify>
  <done>ProfileCoordinator manages profile CRUD with per-profile canvas independence. NotificationCoordinator derives banners from singleton state with re-derivation on recreation. DashboardModule wires registries into Hilt graph.</done>
</task>

<task type="auto">
  <name>Task 2: ProfileCoordinator tests + NotificationCoordinator tests</name>
  <files>
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/ProfileCoordinatorTest.kt
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/coordinator/NotificationCoordinatorTest.kt
  </files>
  <action>
**ProfileCoordinatorTest.kt:** JUnit5 + `@Tag("fast")` + MockK + Turbine. Tests:
- `initialize loads profiles from repository`
- `handleSwitchProfile updates activeProfileId`
- `handleCreateProfile creates new profile in repository`
- `handleCreateProfile with clone duplicates current layout` (F1.30)
- `handleDeleteProfile removes profile`
- `handleDeleteProfile on default profile does nothing`
- `handleDeleteProfile on active profile switches to default`
- `per-profile independence: widget added to A not in B` — create 2 profiles, add widget to A, switch to B, verify widget not present
- `profileCount returns correct count for bottom bar logic`

Use FakeLayoutRepository from testFixtures.

**NotificationCoordinatorTest.kt:** JUnit5 + `@Tag("fast")` + Turbine. Tests:
- `safe mode active shows CRITICAL banner` — set SafeModeManager.safeModeActive to true, verify banner appears
- `safe mode inactive dismisses banner`
- `low storage shows HIGH banner` (NF41)
- `layout save failure shows HIGH banner with specific message` (NF42)
- `banner priority ordering: CRITICAL before HIGH before NORMAL`
- `condition-keyed banners: same id updates in-place, no duplicate`
- `re-derivation on recreation: kill coordinator, recreate, all condition banners re-derived from current singleton state` — set safe mode active, create coordinator, verify banner present immediately without explicit event
- `showToast delivers to channel exactly once`
- `connection status: disconnect shows NORMAL banner, connect dismisses` (F9.1)
- `alert mode VIBRATE triggers alertEmitter vibration` (F9.2)
- `distinctUntilChanged prevents banner flicker on rapid state changes` — rapidly toggle state, verify only one show/dismiss cycle

Use MockK for SafeModeManager, StorageMonitor, AlertEmitter. Use `StandardTestDispatcher`.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --console=plain --tests "*.ProfileCoordinatorTest" --tests "*.NotificationCoordinatorTest" 2>&1 | tail -10</automated>
  </verify>
  <done>ProfileCoordinator tests verify create/clone/switch/delete lifecycle with per-profile independence. NotificationCoordinator tests verify banner derivation, re-derivation, priority ordering, and toast delivery.</done>
</task>

</tasks>

<verification>
- `./gradlew :feature:dashboard:compileDebugKotlin --console=plain` succeeds
- `./gradlew :feature:dashboard:testDebugUnitTest --console=plain` passes all profile and notification tests
- All 6 coordinators now implemented: Layout, EditMode, Theme, WidgetBinding, Profile, Notification
- DashboardModule Hilt wiring compiles without missing binding errors
- NotificationCoordinator re-derives banners from singleton state after recreation
</verification>

<success_criteria>
- ProfileCoordinator handles create/clone/switch/delete with per-profile canvas independence (F1.29, F1.30)
- NotificationCoordinator derives banners from singleton state with re-derivation pattern
- Banner priority ordering correct (F9.1-F9.4)
- Low storage and save failure banners emitted (NF41, NF42)
- DashboardModule Hilt wiring resolves all bindings
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-dashboard-shell/07-05-SUMMARY.md`
</output>
