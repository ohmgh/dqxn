---
phase: 07-dashboard-shell
plan: 13
type: execute
wave: 1
depends_on: []
files_modified:
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/DataProviderRegistryImplTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/StorageMonitorTest.kt
autonomous: true
requirements: [NF17, NF41]
gap_closure: true

must_haves:
  truths:
    - "DataProviderRegistryImplTest covers: getAll, findByDataType, entitlement filtering, availableProviders"
    - "StorageMonitorTest covers: low storage detection, normal storage, polling behavior"
  artifacts:
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/DataProviderRegistryImplTest.kt"
      provides: "DataProviderRegistryImpl test coverage"
      contains: "DataProviderRegistryImplTest"
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/StorageMonitorTest.kt"
      provides: "StorageMonitor test coverage"
      contains: "StorageMonitorTest"
  key_links:
    - from: "DataProviderRegistryImplTest"
      to: "DataProviderRegistryImpl"
      via: "tests getAll, findByDataType, getFiltered, availableProviders"
      pattern: "findByDataType|availableProviders|getFiltered"
    - from: "StorageMonitorTest"
      to: "StorageMonitor"
      via: "tests isLow StateFlow behavior"
      pattern: "isLow"
---

<objective>
Add missing test classes for DataProviderRegistryImpl and StorageMonitor.

Purpose: Both production classes have zero test coverage. DataProviderRegistryImpl has filtering logic (entitlement-based, dataType indexing) that should be tested. StorageMonitor has a polling loop and threshold check that should be tested.

Output: Two new test classes with comprehensive coverage.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/DataProviderRegistryImpl.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/StorageMonitor.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: DataProviderRegistryImplTest</name>
  <files>
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/DataProviderRegistryImplTest.kt
  </files>
  <action>
Create `DataProviderRegistryImplTest.kt` with tests covering all public methods.

Reuse the `SimpleProvider` pattern from WidgetDataBinderTest, or create a minimal test provider.

```kotlin
package app.dqxn.android.feature.dashboard.binding

import app.dqxn.android.sdk.contracts.entitlement.EntitlementManager
import app.dqxn.android.sdk.contracts.provider.DataProvider
import app.dqxn.android.sdk.contracts.provider.DataSchema
import app.dqxn.android.sdk.contracts.provider.DataSnapshot
import app.dqxn.android.sdk.contracts.provider.DataTypes
import app.dqxn.android.sdk.contracts.provider.ProviderPriority
import app.dqxn.android.sdk.contracts.setup.SetupPageDefinition
import app.dqxn.android.sdk.observability.log.NoOpLogger
import com.google.common.truth.Truth.assertThat
import io.mockk.every
import io.mockk.mockk
import kotlin.reflect.KClass
import kotlin.time.Duration
import kotlin.time.Duration.Companion.seconds
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.emptyFlow
import kotlinx.coroutines.flow.flowOf
import org.junit.jupiter.api.Tag
import org.junit.jupiter.api.Test

@Tag("fast")
class DataProviderRegistryImplTest {

    private val logger = NoOpLogger

    // Minimal test snapshot
    data class TestSnapshot(override val timestamp: Long = 0L) : DataSnapshot

    // Minimal provider for testing
    class TestProvider(
        override val sourceId: String,
        override val dataType: String,
        override val priority: ProviderPriority = ProviderPriority.SIMULATED,
        override val requiredAnyEntitlement: Set<String>? = null,
        override val isAvailable: Boolean = true,
    ) : DataProvider<TestSnapshot> {
        override val displayName = sourceId
        override val description = "Test"
        override val snapshotType: KClass<TestSnapshot> = TestSnapshot::class
        override val schema = DataSchema(emptyList(), 3000L)
        override val setupSchema = emptyList<SetupPageDefinition>()
        override val subscriberTimeout: Duration = 5.seconds
        override val firstEmissionTimeout: Duration = 5.seconds
        override val connectionState: Flow<Boolean> = flowOf(true)
        override val connectionErrorDescription: Flow<String?> = flowOf(null)
        override fun provideState(): Flow<TestSnapshot> = emptyFlow()
    }

    private fun fakeEntitlementManager(
        entitlements: Set<String> = setOf("free"),
    ): EntitlementManager = object : EntitlementManager {
        override fun hasEntitlement(id: String) = id in entitlements
        override fun getActiveEntitlements() = entitlements
        override val entitlementChanges = MutableStateFlow(entitlements)
    }

    @Test
    fun `getAll returns all providers`() {
        val providers = setOf(
            TestProvider("speed", DataTypes.SPEED),
            TestProvider("battery", DataTypes.BATTERY),
        )
        val registry = DataProviderRegistryImpl(providers, fakeEntitlementManager(), logger)

        assertThat(registry.getAll()).hasSize(2)
    }

    @Test
    fun `findByDataType returns matching providers sorted by priority`() {
        val hardware = TestProvider("hw-speed", DataTypes.SPEED, ProviderPriority.HARDWARE)
        val simulated = TestProvider("sim-speed", DataTypes.SPEED, ProviderPriority.SIMULATED)
        val battery = TestProvider("battery", DataTypes.BATTERY)

        val registry = DataProviderRegistryImpl(
            setOf(simulated, hardware, battery), fakeEntitlementManager(), logger,
        )

        val speedProviders = registry.findByDataType(DataTypes.SPEED)
        assertThat(speedProviders).hasSize(2)
        // Should be sorted by priority ordinal: HARDWARE < SIMULATED
        assertThat(speedProviders[0].sourceId).isEqualTo("hw-speed")
        assertThat(speedProviders[1].sourceId).isEqualTo("sim-speed")
    }

    @Test
    fun `findByDataType returns empty for unknown type`() {
        val registry = DataProviderRegistryImpl(
            setOf(TestProvider("speed", DataTypes.SPEED)),
            fakeEntitlementManager(),
            logger,
        )

        assertThat(registry.findByDataType("NONEXISTENT")).isEmpty()
    }

    @Test
    fun `getFiltered excludes providers requiring missing entitlements`() {
        val freeProvider = TestProvider("free-speed", DataTypes.SPEED)
        val plusProvider = TestProvider(
            "plus-speed", DataTypes.SPEED,
            requiredAnyEntitlement = setOf("plus"),
        )

        val registry = DataProviderRegistryImpl(
            setOf(freeProvider, plusProvider),
            fakeEntitlementManager(setOf("free")),
            logger,
        )

        val filtered = registry.getFiltered { it == "free" }
        assertThat(filtered).hasSize(1)
        assertThat(filtered.first().sourceId).isEqualTo("free-speed")
    }

    @Test
    fun `availableProviders uses entitlementManager for filtering`() {
        val freeProvider = TestProvider("free-speed", DataTypes.SPEED)
        val plusProvider = TestProvider(
            "plus-speed", DataTypes.SPEED,
            requiredAnyEntitlement = setOf("plus"),
        )

        val registry = DataProviderRegistryImpl(
            setOf(freeProvider, plusProvider),
            fakeEntitlementManager(setOf("free", "plus")),
            logger,
        )

        val available = registry.availableProviders()
        assertThat(available).hasSize(2)
    }

    @Test
    fun `empty provider set produces empty registry`() {
        val registry = DataProviderRegistryImpl(
            emptySet(), fakeEntitlementManager(), logger,
        )

        assertThat(registry.getAll()).isEmpty()
        assertThat(registry.findByDataType(DataTypes.SPEED)).isEmpty()
        assertThat(registry.availableProviders()).isEmpty()
    }
}
```

NOTE: The `isAccessible` extension on DataProvider checks `requiredAnyEntitlement`. Verify how it works in the actual code to ensure the test's entitlement logic matches. If `requiredAnyEntitlement` is null, the provider should be accessible to everyone (no entitlement required). If it's a non-empty set, at least one entitlement must match.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.DataProviderRegistryImplTest" --console=plain 2>&amp;1 | tail -20</automated>
  </verify>
  <done>DataProviderRegistryImplTest passes with 6 tests covering getAll, findByDataType (sorted, empty), getFiltered, availableProviders, empty set.</done>
</task>

<task type="auto">
  <name>Task 2: StorageMonitorTest</name>
  <files>
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/binding/StorageMonitorTest.kt
  </files>
  <action>
StorageMonitor uses `StatFs(context.dataDir.absolutePath)` which requires an Android context. Use MockK or Robolectric.

Since StorageMonitor has a `checkStorage()` private method and `startMonitoring()` public method, the cleanest test approach is to make `checkStorage()` overridable or to test via the public API with a mocked Context.

**Option A (MockK):** Mock the Context to return a controlled `dataDir`. But `StatFs` is a final Android class that can't be easily mocked.

**Option B (Robolectric):** Use Robolectric to provide a real Android context with controlled filesystem. Check if Robolectric is configured for this module.

**Option C (Extract for testability):** Add a `storageChecker: () -> Boolean` constructor parameter (default calls StatFs). Tests inject a fake checker. This is the cleanest approach and matches the `timeProvider` pattern.

Go with Option C — add a `storageChecker: () -> Boolean` parameter:

```kotlin
// In StorageMonitor constructor, add:
private val storageChecker: () -> Boolean = {
    try {
        val stat = StatFs(context.dataDir.absolutePath)
        stat.availableBytes < LOW_STORAGE_THRESHOLD_BYTES
    } catch (_: Exception) {
        false
    }
}
```

Then `checkStorage()` becomes `private fun checkStorage(): Boolean = storageChecker()`.

For the production Hilt injection, the default works. Tests pass a lambda.

**StorageMonitorTest.kt:**

```kotlin
package app.dqxn.android.feature.dashboard.binding

import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.advanceTimeBy
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.Tag
import org.junit.jupiter.api.Test

@OptIn(ExperimentalCoroutinesApi::class)
@Tag("fast")
class StorageMonitorTest {

    @Test
    fun `isLow starts as false`() {
        val monitor = createMonitor(isLowStorage = false)
        assertThat(monitor.isLow.value).isFalse()
    }

    @Test
    fun `startMonitoring detects low storage immediately`() = runTest {
        val monitor = createMonitor(isLowStorage = true)
        monitor.startMonitoring(backgroundScope)
        advanceUntilIdle()

        assertThat(monitor.isLow.value).isTrue()
    }

    @Test
    fun `startMonitoring detects normal storage`() = runTest {
        val monitor = createMonitor(isLowStorage = false)
        monitor.startMonitoring(backgroundScope)
        advanceUntilIdle()

        assertThat(monitor.isLow.value).isFalse()
    }

    @Test
    fun `polling detects storage change from normal to low`() = runTest {
        var isLow = false
        val monitor = createMonitor(storageChecker = { isLow })
        monitor.startMonitoring(backgroundScope)
        advanceUntilIdle()

        assertThat(monitor.isLow.value).isFalse()

        // Storage drops
        isLow = true
        advanceTimeBy(StorageMonitor.POLL_INTERVAL_MS + 1)
        advanceUntilIdle()

        assertThat(monitor.isLow.value).isTrue()
    }

    @Test
    fun `polling detects storage recovery from low to normal`() = runTest {
        var isLow = true
        val monitor = createMonitor(storageChecker = { isLow })
        monitor.startMonitoring(backgroundScope)
        advanceUntilIdle()

        assertThat(monitor.isLow.value).isTrue()

        // Storage recovers
        isLow = false
        advanceTimeBy(StorageMonitor.POLL_INTERVAL_MS + 1)
        advanceUntilIdle()

        assertThat(monitor.isLow.value).isFalse()
    }

    // -- Helpers --

    private fun createMonitor(
        isLowStorage: Boolean = false,
    ): StorageMonitor = createMonitor(storageChecker = { isLowStorage })

    private fun createMonitor(
        storageChecker: () -> Boolean,
    ): StorageMonitor {
        // Use mockk for context since we bypass StatFs via storageChecker
        val context: android.content.Context = io.mockk.mockk(relaxed = true)
        return StorageMonitor(
            context = context,
            storageChecker = storageChecker,
        )
    }
}
```

NOTE: The `storageChecker` parameter must be added to StorageMonitor's constructor. Make it the LAST parameter with a default value so existing Hilt injection is unaffected. Also make `POLL_INTERVAL_MS` and `LOW_STORAGE_THRESHOLD_BYTES` `internal` (not private) so tests can reference them.

Production code change to StorageMonitor.kt:
```kotlin
@Singleton
public class StorageMonitor
@Inject
constructor(
    @param:ApplicationContext private val context: Context,
    private val storageChecker: () -> Boolean = {
        try {
            val stat = StatFs(context.dataDir.absolutePath)
            stat.availableBytes < LOW_STORAGE_THRESHOLD_BYTES
        } catch (_: Exception) {
            false
        }
    },
)
```

WAIT: Hilt cannot inject a `() -> Boolean` lambda. The `storageChecker` should NOT be in the Hilt constructor. Instead, make it a non-injected parameter with a default that uses the context internally.

Better approach: Don't put it in the constructor. Make `checkStorage()` open (for test subclass) or use a separate `internal` method.

SIMPLEST: Make `checkStorage()` `internal` instead of `private`. Tests can then subclass or spy:

```kotlin
internal fun checkStorage(): Boolean = ...
```

Then in tests, use a spy:
```kotlin
val monitor = spyk(StorageMonitor(context = mockk(relaxed = true)))
every { monitor.checkStorage() } returns true
```

Or: extract a `StorageChecker` interface injected via Hilt, but that's over-engineering.

GO WITH THE SPY APPROACH. Keep production code minimal — just change `private fun checkStorage()` to `internal fun checkStorage()`. Tests spy on it.
  </action>
  <verify>
    <automated>cd /Users/ohm/Workspace/dqxn/android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.StorageMonitorTest" --console=plain 2>&amp;1 | tail -20</automated>
  </verify>
  <done>StorageMonitorTest passes with 5 tests covering initial state, low/normal detection, polling transitions.</done>
</task>

</tasks>

<verification>
```
cd android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.DataProviderRegistryImplTest" --tests "*.StorageMonitorTest" --console=plain
```
All 11 tests pass (6 registry + 5 storage).
</verification>

<success_criteria>
- DataProviderRegistryImpl has test coverage for all public methods
- StorageMonitor has test coverage for polling and threshold detection
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-dashboard-shell/07-13-SUMMARY.md`
</output>
