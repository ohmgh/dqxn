---
phase: 14-ui-visual-interactive-parity
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeSelector.kt
  - android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/main/MainSettings.kt
  - android/feature/settings/src/main/res/values/strings.xml
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/layer/OverlayNavHost.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/layer/OverlayRoutes.kt
  - android/feature/settings/src/test/kotlin/app/dqxn/android/feature/settings/theme/ThemeSelectorTest.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/layer/OverlayNavHostRouteTest.kt
autonomous: true
requirements: [F4.6]

must_haves:
  truths:
    - "ThemeSelector uses 4-column grid (GridCells.Fixed(4)) instead of 3"
    - "ThemeSelector has 2-page HorizontalPager: page 0 = built-in themes (Native), page 1 = custom themes"
    - "Theme cards show gradient background via theme.backgroundBrush"
    - "Theme cards show 4 color swatch circles (primaryTextColor, secondaryTextColor, accentColor, highlightColor)"
    - "Premium themes show star icon overlay"
    - "Title bar has page indicator icons: Palette (page 0) + Add (page 1), highlighted when active"
    - "Theme preview timeout is removed (old codebase had none)"
    - "onNavigateToThemeMode routes to AutoSwitchModeRoute (not ThemeSelectorRoute)"
    - "MainSettings has separate Light Theme and Dark Theme navigation rows pointing to ThemeSelectorRoute with isDark parameter"
  artifacts:
    - path: "android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeSelector.kt"
      provides: "4-col HorizontalPager theme selector with gradient backgrounds and color dots"
      contains: "HorizontalPager"
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/layer/OverlayRoutes.kt"
      provides: "AutoSwitchModeRoute and ThemeSelectorRoute(isDark) routes"
      contains: "AutoSwitchModeRoute"
    - path: "android/feature/settings/src/test/kotlin/app/dqxn/android/feature/settings/theme/ThemeSelectorTest.kt"
      provides: "Tests for 4-col grid, pager, color dots, no timeout"
  key_links:
    - from: "OverlayNavHost.kt"
      to: "AutoSwitchModeContent.kt"
      via: "AutoSwitchModeRoute composable destination"
      pattern: "AutoSwitchModeRoute"
    - from: "MainSettings.kt"
      to: "OverlayNavHost.kt"
      via: "onNavigateToThemeMode, onNavigateToLightTheme, onNavigateToDarkTheme callbacks"
      pattern: "onNavigateToLightTheme"
---

<objective>
Rework ThemeSelector grid to 4-column 2-page layout with visual parity, fix theme mode routing, and add per-mode theme navigation rows.

Purpose: Three corrections bundled:
1. ThemeSelector uses 3-col single grid -- old codebase had 2-page HorizontalPager (Native/Custom), user wants 4-col x 3-row. Theme cards lack gradient backgrounds, 4-color-dot swatches, and premium star icons.
2. Preview timeout (60s) exists but old codebase had NO timeout -- remove it.
3. `onNavigateToThemeMode` navigates to ThemeSelectorRoute instead of an auto-switch mode selector. Fix: add AutoSwitchModeRoute, wire to AutoSwitchModeContent. Add separate "Light Theme" and "Dark Theme" rows in MainSettings that navigate to ThemeSelectorRoute with an isDark parameter.

Output: Reworked ThemeSelector.kt, new AutoSwitchModeRoute, updated OverlayNavHost, updated MainSettings with Light/Dark Theme rows.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeSelector.kt
@android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/main/MainSettings.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/layer/OverlayNavHost.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/layer/OverlayRoutes.kt
@android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/AutoSwitchModeContent.kt

<interfaces>
<!-- DashboardThemeDefinition fields for theme cards:
     val themeId: String
     val displayName: String
     val isDark: Boolean
     val packId: String?
     val requiredAnyEntitlement: Set<String>?
     val primaryTextColor: Color
     val secondaryTextColor: Color
     val accentColor: Color
     val highlightColor: Color
     val widgetBorderColor: Color
     val backgroundBrush: Brush
     val widgetBackgroundBrush: Brush
-->

<!-- AutoSwitchModeContent is already a complete composable in :feature:settings that shows
     5 radio rows (LIGHT, DARK, SYSTEM, SOLAR_AUTO, ILLUMINANCE_AUTO). It just needs a route
     in OverlayNavHost and an OverlayScaffold wrapper. -->

<!-- Old codebase ThemeSelector layout:
     - 2-page HorizontalPager (page 0: "Native" built-in, page 1: "Custom" themes)
     - LazyVerticalGrid with GridCells.Fixed(3) -- USER OVERRIDE: wants 4 columns
     - Each theme item: aspectRatio(2f), background = theme.backgroundBrush, selected = 2dp highlightColor border
     - Content: theme name (caption bold) + 4 color swatches (8dp circles: primaryTextColor,
       secondaryTextColor, accentColor, highlightColor) + star icon if premium
     - Page 1: same grid + CreateThemeButton at end
     - Title bar icons: Palette (page 0) + Add (page 1), highlighted when active
-->

<!-- Old codebase theme mode vs theme selector:
     - Route.ThemeModeSelector -> renders AutoSwitchModeContent (5 radio rows)
     - Route.ThemeSelector(isDark: Boolean) -> shows themes for that mode only
     - MainSettings items: "Theme Mode" -> ThemeModeSelector, "Light Theme" -> ThemeSelector(isDark=false),
       "Dark Theme" -> ThemeSelector(isDark=true)
-->

<!-- Current OverlayRoutes.kt has: EmptyRoute, WidgetPickerRoute, SettingsRoute,
     WidgetSettingsRoute, SetupRoute, ThemeSelectorRoute, ThemeStudioRoute,
     DiagnosticsRoute, OnboardingRoute -->

<!-- ThemeCoordinator.themeState has: activeTheme, previewTheme, darkTheme, lightTheme,
     autoSwitchMode, illuminanceThreshold -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AutoSwitchModeRoute, update ThemeSelectorRoute, fix routing, update MainSettings</name>
  <files>
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/layer/OverlayRoutes.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/layer/OverlayNavHost.kt
    android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/main/MainSettings.kt
    android/feature/settings/src/main/res/values/strings.xml
  </files>
  <action>
**1. Update OverlayRoutes.kt** -- Add `AutoSwitchModeRoute` and update `ThemeSelectorRoute` to take `isDark` param:

```kotlin
/** Auto-switch mode selector -- preview transitions. */
@Serializable
public data object AutoSwitchModeRoute

/** Theme selector -- now parameterized with isDark to filter themes for light/dark mode. */
@Serializable
public data class ThemeSelectorRoute(val isDark: Boolean = true)
```

Note: `ThemeSelectorRoute` changes from `data object` to `data class` with `isDark` parameter. This means all usages of `ThemeSelectorRoute` in OverlayNavHost.kt and route pattern matching must update to use the class form.

**2. Update OverlayNavHost.kt** -- Add AutoSwitchModeRoute composable destination and fix theme routing:

a) Add route pattern for AutoSwitchModeRoute:
```kotlin
private val AUTO_SWITCH_MODE_ROUTE_PATTERN = AutoSwitchModeRoute::class.qualifiedName!!
```

b) Add `AutoSwitchModeRoute` composable destination after the Settings route. Wrap `AutoSwitchModeContent` in `OverlayScaffold`:
```kotlin
// Auto-switch mode selector -- preview transitions
composable<AutoSwitchModeRoute>(
    enterTransition = { DashboardMotion.previewEnter },
    exitTransition = { DashboardMotion.previewExit },
    popEnterTransition = { fadeIn(tween(150)) },
    popExitTransition = { DashboardMotion.previewExit },
) {
    val themeState by themeCoordinator.themeState.collectAsState()

    OverlayScaffold(
        title = "Theme Mode",
        overlayType = OverlayType.Preview,
        onClose = { navController.popBackStack() },
    ) {
        AutoSwitchModeContent(
            selectedMode = themeState.autoSwitchMode,
            illuminanceThreshold = themeState.illuminanceThreshold,
            entitlementManager = entitlementManager,
            onModeSelected = { mode ->
                onCommand(DashboardCommand.SetAutoSwitchMode(mode))
            },
            onIlluminanceThresholdChanged = { threshold ->
                onCommand(DashboardCommand.SetIlluminanceThreshold(threshold))
            },
        )
    }
}
```

Import `AutoSwitchModeContent` from `app.dqxn.android.feature.settings.theme.AutoSwitchModeContent` and `OverlayScaffold`/`OverlayType` from `app.dqxn.android.feature.settings.overlay.*`.

c) Update Settings route's `onNavigateToThemeMode` to navigate to `AutoSwitchModeRoute` instead of `ThemeSelectorRoute`:
```kotlin
onNavigateToThemeMode = {
    navController.navigate(AutoSwitchModeRoute)
},
```

Remove the existing preview theme command from `onNavigateToThemeMode` (preview not needed for mode selector).

d) Add `onNavigateToLightTheme` and `onNavigateToDarkTheme` callbacks in Settings route:
```kotlin
onNavigateToLightTheme = {
    val lightTheme = themeCoordinator.themeState.value.lightTheme
    onCommand(DashboardCommand.PreviewTheme(lightTheme))
    navController.navigate(ThemeSelectorRoute(isDark = false))
},
onNavigateToDarkTheme = {
    val darkTheme = themeCoordinator.themeState.value.darkTheme
    onCommand(DashboardCommand.PreviewTheme(darkTheme))
    navController.navigate(ThemeSelectorRoute(isDark = true))
},
```

e) Update Settings route's exit/popEnter source-varying transitions to include AutoSwitchModeRoute pattern alongside ThemeSelectorRoute:
```kotlin
exitTransition = {
    val target = targetState.destination.route ?: ""
    when {
        target.contains(THEME_SELECTOR_ROUTE_PATTERN) -> fadeOut(tween(100))
        target.contains(AUTO_SWITCH_MODE_ROUTE_PATTERN) -> fadeOut(tween(100))
        // ... rest unchanged
    }
},
popEnterTransition = {
    val source = initialState.destination.route ?: ""
    when {
        source.contains(THEME_SELECTOR_ROUTE_PATTERN) -> fadeIn(tween(150))
        source.contains(AUTO_SWITCH_MODE_ROUTE_PATTERN) -> fadeIn(tween(150))
        // ... rest unchanged
    }
},
```

f) Update ThemeSelectorRoute composable to read `isDark` from route param and pass it to ThemeSelector:
```kotlin
composable<ThemeSelectorRoute>(...) { backStackEntry ->
    val route = backStackEntry.toRoute<ThemeSelectorRoute>()
    val themeState by themeCoordinator.themeState.collectAsState()

    ThemeSelector(
        allThemes = allThemes,
        isDark = route.isDark,
        // ... rest unchanged
    )
}
```

g) Verify `DashboardCommand.SetAutoSwitchMode` and `DashboardCommand.SetIlluminanceThreshold` exist. If they don't, the executor should check ThemeCoordinator for the correct command names (likely `SetAutoSwitchMode(AutoSwitchMode)` and `SetIlluminanceThreshold(Float)` -- these were created in Phase 7 as part of ThemeCoordinator). If the exact command sealed variants don't exist, add them to DashboardCommand.kt. Check the actual file before adding.

**3. Update MainSettings.kt** -- Add `onNavigateToLightTheme` and `onNavigateToDarkTheme` params, add "Light Theme" and "Dark Theme" navigation rows:

Add two new callback parameters:
```kotlin
onNavigateToLightTheme: () -> Unit,
onNavigateToDarkTheme: () -> Unit,
```

In the Appearance section, after the "Theme Mode" row, add:
```kotlin
NavigationRow(
    label = stringResource(R.string.main_settings_light_theme),
    subtitle = lightThemeName,
    theme = theme,
    onClick = onNavigateToLightTheme,
    testTag = "main_settings_light_theme",
)
NavigationRow(
    label = stringResource(R.string.main_settings_dark_theme),
    subtitle = darkThemeName,
    theme = theme,
    onClick = onNavigateToDarkTheme,
    testTag = "main_settings_dark_theme",
)
```

Add `lightThemeName: String` and `darkThemeName: String` parameters to MainSettings (these come from ThemeCoordinator via the OverlayNavHost). Wire them in OverlayNavHost:
```kotlin
val lightThemeName = themeState.lightTheme?.displayName ?: "Default"
val darkThemeName = themeState.darkTheme?.displayName ?: "Default"
```

Wait -- MainSettings is a pure composable with callbacks only. Add params `lightThemeName` and `darkThemeName` as String params. The OverlayNavHost wiring:
```kotlin
val themeState by themeCoordinator.themeState.collectAsState()
MainSettings(
    // ... existing params ...
    lightThemeName = themeState.lightTheme?.displayName ?: "Default",
    darkThemeName = themeState.darkTheme?.displayName ?: "Default",
    onNavigateToLightTheme = { ... },
    onNavigateToDarkTheme = { ... },
)
```

Update the `NavigationRow` composable to support an optional `subtitle` param:
```kotlin
@Composable
private fun NavigationRow(
    label: String,
    theme: DashboardThemeDefinition,
    onClick: () -> Unit,
    testTag: String,
    subtitle: String? = null,
    modifier: Modifier = Modifier,
)
```

When subtitle is non-null, render it below the label:
```kotlin
Column(modifier = Modifier.weight(1f)) {
    Text(text = label, style = DashboardTypography.itemTitle, color = theme.primaryTextColor)
    if (subtitle != null) {
        Text(
            text = subtitle,
            style = DashboardTypography.description,
            color = theme.primaryTextColor.copy(alpha = TextEmphasis.Medium),
        )
    }
}
```

**4. Add string resources** to `android/feature/settings/src/main/res/values/strings.xml`:
```xml
<string name="main_settings_light_theme">Light Theme</string>
<string name="main_settings_dark_theme">Dark Theme</string>
<string name="main_settings_theme_mode_description">%s</string>
```

**5. Update existing test call sites** if they use `ThemeSelectorRoute` as a data object -- it's now `ThemeSelectorRoute(isDark = true)`. Check:
- `OverlayNavHostRouteTest.kt` -- update `ThemeSelectorRoute` references
- `OverlayNavHostTest.kt` -- update `ThemeSelectorRoute` references
- `MainSettingsTest.kt` -- add `onNavigateToLightTheme = {}`, `onNavigateToDarkTheme = {}`, `lightThemeName = ""`, `darkThemeName = ""` to test helper
- `TalkBackAccessibilityTest.kt` -- add new params to helper
- `FontScaleTest.kt` -- add new params to helper
  </action>
  <verify>
    <automated>cd android && ./gradlew :feature:dashboard:compileDebugKotlin :feature:settings:compileDebugKotlin --console=plain 2>&1 | tail -10</automated>
  </verify>
  <done>
    - AutoSwitchModeRoute added to OverlayRoutes.kt
    - ThemeSelectorRoute updated to data class with isDark param
    - OverlayNavHost wires AutoSwitchModeRoute to AutoSwitchModeContent in OverlayScaffold
    - onNavigateToThemeMode now navigates to AutoSwitchModeRoute (not ThemeSelectorRoute)
    - MainSettings has "Light Theme" and "Dark Theme" rows with subtitle showing current theme name
    - Source-varying transitions updated to include AutoSwitchModeRoute pattern
    - All test call sites updated for new params and ThemeSelectorRoute(isDark) form
    - Compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Rework ThemeSelector to 4-col HorizontalPager with visual parity and remove timeout</name>
  <files>
    android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeSelector.kt
    android/feature/settings/src/test/kotlin/app/dqxn/android/feature/settings/theme/ThemeSelectorTest.kt
  </files>
  <action>
**Rework ThemeSelector.kt** completely:

**1. Add `isDark` parameter** to filter themes by mode:
```kotlin
@Composable
public fun ThemeSelector(
    allThemes: ImmutableList<DashboardThemeDefinition>,
    isDark: Boolean,
    previewTheme: DashboardThemeDefinition?,
    // ... rest unchanged
)
```

Filter themes by isDark first, then sort:
```kotlin
val filteredThemes = remember(allThemes, isDark) {
    allThemes.filter { it.isDark == isDark }
}
val sortedThemes = remember(filteredThemes) { sortThemes(filteredThemes.toImmutableList()) }
```

**2. Remove preview timeout** -- delete the `PREVIEW_TIMEOUT_MS` constant and the `LaunchedEffect(previewTheme?.themeId)` that calls `delay(PREVIEW_TIMEOUT_MS)` followed by `onClearPreview()` and `onShowToast("Preview timed out")`. The old codebase had NO preview timeout. Keep the entitlement revocation LaunchedEffect and the DisposableEffect cleanup.

**3. Replace LazyVerticalGrid with 2-page HorizontalPager** layout:

Add imports:
```kotlin
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.pager.HorizontalPager
import androidx.compose.foundation.pager.rememberPagerState
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Palette
import androidx.compose.material.icons.filled.Star
import androidx.compose.ui.graphics.graphicsLayer
```

Split themes into two groups:
```kotlin
// Page 0: built-in (free + premium), Page 1: custom
val builtInThemes = remember(sortedThemes) {
    sortedThemes.filter { !it.themeId.startsWith("custom_") }
}
val customThemes = remember(sortedThemes) {
    sortedThemes.filter { it.themeId.startsWith("custom_") }
}
```

Create pager state:
```kotlin
val pagerState = rememberPagerState(initialPage = 0) { 2 }
val scope = rememberCoroutineScope()
```

Replace the `LazyVerticalGrid` with this structure inside OverlayScaffold:

```kotlin
OverlayScaffold(
    title = if (isDark) "Dark Themes" else "Light Themes",
    overlayType = OverlayType.Preview,
    onClose = onClose,
    modifier = modifier.testTag("theme_selector"),
    actions = {
        // Title bar page icons: Palette (page 0) + Add (page 1)
        ThemePageIcons(
            currentPage = pagerState.currentPage,
            onNavigateToPage = { page -> scope.launch { pagerState.animateScrollToPage(page) } },
            accentColor = theme.accentColor,
            secondaryTextColor = theme.secondaryTextColor,
        )
    },
) {
    HorizontalPager(
        state = pagerState,
        modifier = Modifier.fillMaxSize().testTag("theme_pager"),
    ) { page ->
        when (page) {
            0 -> ThemeGrid(
                themes = builtInThemes,
                previewTheme = previewTheme,
                entitlementManager = entitlementManager,
                customThemeCount = customThemeCount,
                onTap = onPreviewTheme,
                onLongPress = { themeItem ->
                    if (customThemeCount < MAX_CUSTOM_THEMES) {
                        onCloneToCustom(themeItem)
                    } else {
                        onShowToast("Maximum $MAX_CUSTOM_THEMES custom themes reached")
                    }
                },
                onApply = { themeItem, hasAccess ->
                    if (hasAccess) onApplyTheme(themeItem.themeId)
                    else onShowToast("Upgrade required to apply this theme")
                },
                accentColor = theme.accentColor,
                textColor = theme.primaryTextColor,
                modifier = Modifier.testTag("theme_page_builtin"),
            )
            1 -> ThemeGrid(
                themes = customThemes,
                previewTheme = previewTheme,
                entitlementManager = entitlementManager,
                customThemeCount = customThemeCount,
                onTap = onPreviewTheme,
                onLongPress = { /* no clone action for custom themes */ },
                onApply = { themeItem, _ -> onApplyTheme(themeItem.themeId) },
                accentColor = theme.accentColor,
                textColor = theme.primaryTextColor,
                isCustomPage = true,
                onEdit = onOpenStudio,
                onDelete = { themeItem -> onDeleteCustom(themeItem.themeId) },
                onCreateNew = {
                    if (customThemeCount < MAX_CUSTOM_THEMES) {
                        onOpenStudio(DashboardThemeDefinition( /* need a "new" signal -- use existingTheme=null in ThemeStudio */))
                        // Actually: just navigate to ThemeStudio with no themeId. The onOpenStudio lambda
                        // expects a DashboardThemeDefinition. For "create new", the parent OverlayNavHost
                        // needs a new callback. Add `onCreateNewTheme: () -> Unit` param to ThemeSelector.
                    }
                },
                modifier = Modifier.testTag("theme_page_custom"),
            )
        }
    }
}
```

IMPORTANT: The "create new theme" action on page 1 needs a separate callback since ThemeStudio(themeId=null) means "create new". Add `onCreateNewTheme: () -> Unit` parameter to ThemeSelector. In OverlayNavHost, wire it:
```kotlin
onCreateNewTheme = {
    navController.navigate(ThemeStudioRoute(themeId = null))
},
```

**4. Create ThemePageIcons composable** (title bar icons):
```kotlin
@Composable
private fun ThemePageIcons(
    currentPage: Int,
    onNavigateToPage: (Int) -> Unit,
    accentColor: Color,
    secondaryTextColor: Color,
) {
    Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
        IconButton(onClick = { onNavigateToPage(0) }) {
            Icon(
                imageVector = Icons.Filled.Palette,
                contentDescription = "Built-in themes",
                tint = if (currentPage == 0) accentColor else secondaryTextColor,
                modifier = Modifier.testTag("theme_page_icon_builtin"),
            )
        }
        IconButton(onClick = { onNavigateToPage(1) }) {
            Icon(
                imageVector = Icons.Filled.Add,
                contentDescription = "Custom themes",
                tint = if (currentPage == 1) accentColor else secondaryTextColor,
                modifier = Modifier.testTag("theme_page_icon_custom"),
            )
        }
    }
}
```

**5. Create ThemeGrid composable** (shared grid for both pages):
```kotlin
@Composable
private fun ThemeGrid(
    themes: List<DashboardThemeDefinition>,
    previewTheme: DashboardThemeDefinition?,
    entitlementManager: EntitlementManager,
    customThemeCount: Int,
    onTap: (DashboardThemeDefinition) -> Unit,
    onLongPress: (DashboardThemeDefinition) -> Unit,
    onApply: (DashboardThemeDefinition, Boolean) -> Unit,
    accentColor: Color,
    textColor: Color,
    modifier: Modifier = Modifier,
    isCustomPage: Boolean = false,
    onEdit: ((DashboardThemeDefinition) -> Unit)? = null,
    onDelete: ((DashboardThemeDefinition) -> Unit)? = null,
    onCreateNew: (() -> Unit)? = null,
) {
    LazyVerticalGrid(
        columns = GridCells.Fixed(4), // USER OVERRIDE: 4 columns (old codebase had 3)
        contentPadding = PaddingValues(8.dp),
        horizontalArrangement = Arrangement.spacedBy(8.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp),
        modifier = modifier.fillMaxSize(),
    ) {
        items(themes, key = { it.themeId }) { themeItem ->
            val isSelected = previewTheme?.themeId == themeItem.themeId
            val isGated = !themeItem.requiredAnyEntitlement.isNullOrEmpty()
            val hasAccess = !isGated || themeItem.requiredAnyEntitlement!!.any { entitlementManager.hasEntitlement(it) }

            ThemeCard(
                theme = themeItem,
                isSelected = isSelected,
                isGated = isGated,
                hasAccess = hasAccess,
                isCustom = isCustomPage,
                onTap = { onTap(themeItem) },
                onLongPress = { onLongPress(themeItem) },
                onApply = { onApply(themeItem, hasAccess) },
                onEdit = if (isCustomPage && onEdit != null) { { onEdit(themeItem) } } else null,
                onDelete = if (isCustomPage && onDelete != null) { { onDelete(themeItem) } } else null,
                accentColor = accentColor,
                textColor = textColor,
            )
        }

        // "Create new" button on custom page
        if (isCustomPage && onCreateNew != null) {
            item {
                CreateThemeButton(
                    accentColor = accentColor,
                    onClick = onCreateNew,
                )
            }
        }
    }
}
```

**6. Rework ThemeCard composable** to match old codebase visual:
```kotlin
@Composable
private fun ThemeCard(
    theme: DashboardThemeDefinition,
    isSelected: Boolean,
    isGated: Boolean,
    hasAccess: Boolean,
    isCustom: Boolean,
    onTap: () -> Unit,
    onLongPress: () -> Unit,
    onApply: () -> Unit,
    onEdit: (() -> Unit)?,
    onDelete: (() -> Unit)?,
    accentColor: Color,
    textColor: Color,
) {
    val borderColor = if (isSelected) theme.highlightColor else Color.Transparent
    val cornerShape = RoundedCornerShape(CardSize.SMALL.cornerRadius)

    Column(
        modifier = Modifier
            .testTag("theme_card_${theme.themeId}")
            .clip(cornerShape)
            .border(2.dp, borderColor, cornerShape)
            .combinedClickable(
                onClick = onTap,
                onLongClick = onLongPress,
                onDoubleClick = onApply,
            )
            .padding(4.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
    ) {
        // Background swatch with gradient
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .aspectRatio(2f) // old codebase used 2f aspect ratio
                .clip(cornerShape)
                .background(theme.backgroundBrush) // gradient background from theme
                .testTag("theme_swatch_${theme.themeId}"),
        ) {
            // Premium star icon (top-end)
            if (isGated) {
                Icon(
                    imageVector = Icons.Filled.Star,
                    contentDescription = "Premium",
                    tint = Color.White.copy(alpha = 0.8f),
                    modifier = Modifier
                        .align(Alignment.TopEnd)
                        .padding(4.dp)
                        .size(14.dp)
                        .testTag("theme_star_${theme.themeId}"),
                )
            }
        }

        // Theme name (caption bold)
        Text(
            text = theme.displayName,
            style = DashboardTypography.caption, // TODO: verify bold variant exists, else use fontWeight = FontWeight.Bold
            color = textColor,
            maxLines = 1,
            modifier = Modifier.testTag("theme_name_${theme.themeId}"),
        )

        // 4 color swatch dots: primaryTextColor, secondaryTextColor, accentColor, highlightColor
        Row(
            horizontalArrangement = Arrangement.spacedBy(4.dp),
            modifier = Modifier
                .padding(top = 2.dp)
                .testTag("theme_dots_${theme.themeId}"),
        ) {
            ColorDot(color = theme.primaryTextColor)
            ColorDot(color = theme.secondaryTextColor)
            ColorDot(color = theme.accentColor)
            ColorDot(color = theme.highlightColor)
        }

        // Edit/delete row for custom themes
        if (isCustom && onEdit != null && onDelete != null) {
            Box(modifier = Modifier.testTag("theme_custom_actions_${theme.themeId}")) {
                IconButton(onClick = onEdit, modifier = Modifier.size(24.dp)) {
                    Icon(Icons.Filled.Edit, "Edit", tint = textColor.copy(alpha = 0.7f), modifier = Modifier.size(16.dp))
                }
                IconButton(onClick = onDelete, modifier = Modifier.align(Alignment.CenterEnd).size(24.dp)) {
                    Icon(Icons.Filled.Delete, "Delete", tint = textColor.copy(alpha = 0.7f), modifier = Modifier.size(16.dp))
                }
            }
        }
    }
}
```

**7. Add ColorDot and CreateThemeButton composables:**
```kotlin
@Composable
private fun ColorDot(color: Color, modifier: Modifier = Modifier) {
    Box(
        modifier = modifier
            .size(8.dp)
            .clip(CircleShape)
            .background(color),
    )
}

@Composable
private fun CreateThemeButton(
    accentColor: Color,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
) {
    val cornerShape = RoundedCornerShape(CardSize.SMALL.cornerRadius)
    Box(
        modifier = modifier
            .fillMaxWidth()
            .aspectRatio(2f)
            .clip(cornerShape)
            .border(2.dp, accentColor.copy(alpha = 0.3f), cornerShape)
            .clickable(onClick = onClick)
            .testTag("create_theme_button"),
        contentAlignment = Alignment.Center,
    ) {
        Icon(
            imageVector = Icons.Filled.Add,
            contentDescription = "Create theme",
            tint = accentColor,
            modifier = Modifier.size(32.dp),
        )
    }
}
```

**8. Check if OverlayScaffold supports `actions` slot.** If it doesn't have an `actions` composable lambda parameter, pass the ThemePageIcons differently. Look at OverlayScaffold's signature. If no `actions` param exists, place ThemePageIcons as the first item in the grid column, spanning full width, or put it above the HorizontalPager inside a Column.

**9. Update ThemeSelectorTest.kt** to reflect new behavior:
- Verify `GridCells.Fixed(4)` (not 3) -- source assertion test
- Verify `HorizontalPager` presence
- Verify theme card has `theme_dots_` test tag (color swatches exist)
- Verify premium themes show star icon (`theme_star_` tag)
- Verify NO preview timeout behavior (remove any timeout-related test assertions)
- Verify themes filtered by `isDark` parameter
- Add test for page icon highlighting
  </action>
  <verify>
    <automated>cd android && ./gradlew :feature:settings:testDebugUnitTest --tests "*.ThemeSelectorTest" --console=plain 2>&1 | tail -10</automated>
  </verify>
  <done>
    - ThemeSelector uses GridCells.Fixed(4) (4 columns)
    - 2-page HorizontalPager: page 0 = built-in, page 1 = custom
    - Theme cards show gradient background via theme.backgroundBrush
    - Theme cards show 4 color dot swatches (8dp circles)
    - Premium themes show star icon instead of lock
    - Title bar has Palette/Add page icons
    - Preview timeout removed (no PREVIEW_TIMEOUT_MS, no timeout LaunchedEffect)
    - Themes filtered by isDark parameter
    - Create new theme button on custom page
    - All ThemeSelectorTest tests pass
    - All OverlayNavHost tests pass (route changes compatible)
  </done>
</task>

</tasks>

<verification>
1. `cd android && ./gradlew :feature:dashboard:compileDebugKotlin --console=plain` -- compiles (OverlayNavHost/Routes changes)
2. `cd android && ./gradlew :feature:settings:compileDebugKotlin --console=plain` -- compiles (ThemeSelector/MainSettings changes)
3. `cd android && ./gradlew :feature:settings:testDebugUnitTest --tests "*.ThemeSelectorTest" --console=plain` -- all tests pass
4. `cd android && ./gradlew :feature:settings:testDebugUnitTest --tests "*.MainSettingsTest" --console=plain` -- existing tests pass with new params
5. `cd android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.OverlayNavHostRouteTest" --console=plain` -- route tests pass
6. `cd android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.OverlayNavHostTest" --console=plain` -- nav tests pass
</verification>

<success_criteria>
- ThemeSelector: 4-col grid, 2-page HorizontalPager, gradient backgrounds, color dots, premium stars, page icons
- Theme preview timeout removed
- AutoSwitchModeRoute wired to AutoSwitchModeContent in OverlayNavHost
- onNavigateToThemeMode routes to AutoSwitchModeRoute (not ThemeSelectorRoute)
- MainSettings has Light Theme and Dark Theme rows with subtitle
- ThemeSelectorRoute(isDark) filters themes by mode
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-ui-visual-interactive-parity/14-06-SUMMARY.md`
</output>
