---
phase: 14-ui-visual-interactive-parity
plan: 14
type: execute
wave: 1
depends_on: []
files_modified:
  - android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudio.kt
  - android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudioStateHolder.kt
  - android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeSwatchRow.kt
  - android/feature/settings/src/test/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudioTest.kt
  - android/feature/settings/src/test/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudioStateHolderTest.kt
autonomous: true
requirements: [F4.6]

must_haves:
  truths:
    - "ThemeStudio title is editable via BasicTextField (not static Text), user can rename the theme"
    - "ThemeStudioStateHolder has a displayName: String mutable property initialized from existingTheme?.displayName or 'Custom Theme'"
    - "ThemeStudioStateHolder.isDirty includes displayName comparison"
    - "ThemeStudioStateHolder.buildCustomTheme uses the mutable displayName (not a hardcoded default)"
    - "ThemeStudio header row has Undo and Delete icon buttons alongside the editable title"
    - "Undo button resets ThemeStudioStateHolder to initial values (calls stateHolder.reset())"
    - "Delete button calls onDelete with the themeId, preceded by onClearPreview"
    - "Undo button disabled (alpha-dimmed) when !stateHolder.isDirty"
    - "Delete button hidden when existingTheme is null (new theme, nothing to delete)"
    - "ThemeSwatchRow uses 48dp container (rounded square, 8dp corner radius) with 36dp inner color circle (not 40dp flat circles)"
    - "ThemeSwatchRow selection border uses theme.highlightColor (not accentColor)"
    - "Gradient editing for BACKGROUND and WIDGET_BACKGROUND swatches wires GradientStopRow + GradientTypeSelector (not placeholder text)"
    - "ThemeStudioStateHolder has gradientType: GradientType and stops: ImmutableList<GradientStop> for each brush property"
    - "Auto-save fires on ANY dirty change including displayName and gradient changes"
  artifacts:
    - path: "android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudio.kt"
      provides: "Theme Studio with editable title, undo/delete buttons, wired gradient editing"
      contains: "BasicTextField"
    - path: "android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudioStateHolder.kt"
      provides: "State holder with displayName, gradient state, reset() method"
      contains: "displayName"
    - path: "android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeSwatchRow.kt"
      provides: "48dp container with 36dp inner circle swatch, highlightColor selection border"
      contains: "48.dp"
    - path: "android/feature/settings/src/test/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudioTest.kt"
      provides: "Tests for editable title, undo/delete buttons, gradient editing wiring, swatch dimensions"
      contains: "editable_title"
---

<objective>
Theme Studio layout parity: editable title, undo/delete buttons, proper swatch dimensions, gradient editing wiring.

Purpose: Current ThemeStudio has a static title ("Edit Theme" / "New Theme"), no undo/delete buttons, 40dp flat circle swatches (old codebase: 48dp rounded-square container with 36dp inner circle), and gradient editing shows placeholder text instead of wiring GradientStopRow + GradientTypeSelector. This plan fixes all layout deltas to match the old codebase's Theme Studio.

Output: Updated ThemeStudio.kt, ThemeStudioStateHolder.kt, ThemeSwatchRow.kt, and tests.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudio.kt
@android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudioStateHolder.kt
@android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeSwatchRow.kt
@android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/GradientStopRow.kt
@android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/GradientTypeSelector.kt
@android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/InlineColorPicker.kt
@android/feature/settings/src/test/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudioTest.kt
@android/feature/settings/src/test/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudioStateHolderTest.kt

<interfaces>
<!-- Old codebase ThemeStudio layout (deltas to fix):
     1. Title: BasicTextField with editable theme name (not static "Edit Theme" / "New Theme")
     2. Title bar: Undo button (resets to initial) + Delete button (deletes theme)
     3. Swatch row: 48dp rounded-square container (8dp corner radius) with 36dp inner color circle
        - Current: 40dp flat CircleShape circles
        - Old: 48dp RoundedCornerShape(8.dp) container with background, 36dp CircleShape inner swatch
     4. Selection border on swatch: highlightColor (not accentColor)
        - Current: theme.accentColor for border
        - Old: theme.highlightColor for border
     5. Gradient editing: GradientStopRow + GradientTypeSelector wired to state holder
        - Current: placeholder Text("Gradient editing for ${selectedSwatch.displayName}")
        - Old: GradientTypeSelector selector + GradientStopRow editor
-->

<!-- OverlayScaffold renders OverlayTitleBar(title, onClose) internally.
     OverlayTitleBar is a Row with static Text + Close button.
     Since we can't add an actions slot to OverlayTitleBar without changing the shared component,
     ThemeStudio keeps the OverlayScaffold for its container (shape, background, animation)
     but overrides the title display by:
     - Passing a minimal/generic title like "Theme Studio" to OverlayScaffold
     - Adding its own custom header row inside content with BasicTextField + undo/delete buttons
     The OverlayScaffold title bar still provides the Close button.
-->

<!-- ThemeStudioStateHolder current state:
     - 6 mutable color properties + isDark + 2 Brush properties
     - isDirty: derivedStateOf comparing colors + isDark against saved values
     - buildCustomTheme(themeId, displayName = "Custom Theme") -- displayName is a param with default
     - NO displayName mutable property
     - NO gradientType / gradientStops state
     - NO reset() method
-->

<!-- GradientStopRow existing API:
     @Composable fun GradientStopRow(
         stops: ImmutableList<GradientStop>,
         onStopsChanged: (ImmutableList<GradientStop>) -> Unit,
         modifier: Modifier = Modifier,
     )
     Already functional, just not wired in ThemeStudio.
-->

<!-- GradientTypeSelector existing API:
     @Composable fun GradientTypeSelector(
         selected: GradientType,
         onSelected: (GradientType) -> Unit,
         modifier: Modifier = Modifier,
     )
     Already functional, just not wired in ThemeStudio.
-->

<!-- GradientType and GradientStop types from :sdk:ui:
     enum class GradientType { VERTICAL, HORIZONTAL, LINEAR, RADIAL, SWEEP }
     data class GradientStop(val color: Long, val position: Float)
-->

<!-- buildCustomTheme currently builds Brush from backgroundBrush/widgetBackgroundBrush state
     directly. After this plan, the brush properties should be derived from gradient stops + type
     for the BACKGROUND and WIDGET_BACKGROUND swatches. For color swatches (5 non-brush), the
     existing InlineColorPicker flow remains unchanged. -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add displayName, gradient state, and reset() to ThemeStudioStateHolder</name>
  <files>
    android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudioStateHolder.kt
    android/feature/settings/src/test/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudioStateHolderTest.kt
  </files>
  <action>
**1. Add displayName mutable property to ThemeStudioStateHolder:**

```kotlin
public var displayName: String by mutableStateOf(initialTheme?.displayName ?: "Custom Theme")
```

Add saved state for dirty tracking:
```kotlin
private val savedDisplayName: String = initialTheme?.displayName ?: "Custom Theme"
```

Update `isDirty` derivedStateOf to include displayName:
```kotlin
public val isDirty: Boolean by derivedStateOf {
    displayName != savedDisplayName ||
        primaryTextColor != savedPrimaryTextColor ||
        secondaryTextColor != savedSecondaryTextColor ||
        accentColor != savedAccentColor ||
        highlightColor != savedHighlightColor ||
        widgetBorderColor != savedWidgetBorderColor ||
        isDark != savedIsDark ||
        backgroundGradientType != savedBackgroundGradientType ||
        backgroundStops != savedBackgroundStops ||
        widgetBackgroundGradientType != savedWidgetBackgroundGradientType ||
        widgetBackgroundStops != savedWidgetBackgroundStops
}
```

**2. Update buildCustomTheme** to use the mutable displayName:
```kotlin
public fun buildCustomTheme(themeId: String): DashboardThemeDefinition =
    DashboardThemeDefinition(
        themeId = themeId,
        displayName = displayName,
        isDark = isDark,
        primaryTextColor = primaryTextColor,
        secondaryTextColor = secondaryTextColor,
        accentColor = accentColor,
        highlightColor = highlightColor,
        widgetBorderColor = widgetBorderColor,
        backgroundBrush = buildBrush(backgroundGradientType, backgroundStops),
        widgetBackgroundBrush = buildBrush(widgetBackgroundGradientType, widgetBackgroundStops),
    )
```

Remove the old `displayName: String = "Custom Theme"` parameter from buildCustomTheme -- it now reads from the mutable property.

**3. Add gradient state properties:**

```kotlin
import app.dqxn.android.sdk.ui.theme.GradientStop
import app.dqxn.android.sdk.ui.theme.GradientType
import kotlinx.collections.immutable.ImmutableList
import kotlinx.collections.immutable.persistentListOf
import kotlinx.collections.immutable.toImmutableList
```

Add gradient state for background:
```kotlin
public var backgroundGradientType: GradientType by mutableStateOf(
    initialTheme?.let { extractGradientType(it.backgroundBrush) } ?: GradientType.VERTICAL
)
public var backgroundStops: ImmutableList<GradientStop> by mutableStateOf(
    initialTheme?.let { extractGradientStops(it.backgroundBrush) }
        ?: persistentListOf(
            GradientStop(color = Color.Black.value.toLong(), position = 0f),
            GradientStop(color = Color.DarkGray.value.toLong(), position = 1f),
        )
)
```

Add gradient state for widget background:
```kotlin
public var widgetBackgroundGradientType: GradientType by mutableStateOf(
    initialTheme?.let { extractGradientType(it.widgetBackgroundBrush) } ?: GradientType.VERTICAL
)
public var widgetBackgroundStops: ImmutableList<GradientStop> by mutableStateOf(
    initialTheme?.let { extractGradientStops(it.widgetBackgroundBrush) }
        ?: persistentListOf(
            GradientStop(color = Color(0xFF1A1A1A).value.toLong(), position = 0f),
            GradientStop(color = Color.Black.value.toLong(), position = 1f),
        )
)
```

Add saved state for gradient dirty tracking:
```kotlin
private val savedBackgroundGradientType: GradientType = initialTheme?.let { extractGradientType(it.backgroundBrush) } ?: GradientType.VERTICAL
private val savedBackgroundStops: ImmutableList<GradientStop> = initialTheme?.let { extractGradientStops(it.backgroundBrush) }
    ?: persistentListOf(GradientStop(color = Color.Black.value.toLong(), position = 0f), GradientStop(color = Color.DarkGray.value.toLong(), position = 1f))
private val savedWidgetBackgroundGradientType: GradientType = initialTheme?.let { extractGradientType(it.widgetBackgroundBrush) } ?: GradientType.VERTICAL
private val savedWidgetBackgroundStops: ImmutableList<GradientStop> = initialTheme?.let { extractGradientStops(it.widgetBackgroundBrush) }
    ?: persistentListOf(GradientStop(color = Color(0xFF1A1A1A).value.toLong(), position = 0f), GradientStop(color = Color.Black.value.toLong(), position = 1f))
```

**4. Add buildBrush helper function** that converts gradient type + stops to a Compose Brush:
```kotlin
private fun buildBrush(type: GradientType, stops: ImmutableList<GradientStop>): Brush {
    if (stops.size < 2) return SolidColor(Color(stops.firstOrNull()?.color?.toULong() ?: Color.Black.value))
    val colorStops = stops.sortedBy { it.position }.map { it.position to Color(it.color.toULong()) }.toTypedArray()
    return when (type) {
        GradientType.VERTICAL -> Brush.verticalGradient(colorStops = colorStops)
        GradientType.HORIZONTAL -> Brush.horizontalGradient(colorStops = colorStops)
        GradientType.LINEAR -> Brush.linearGradient(colorStops = colorStops)
        GradientType.RADIAL -> Brush.radialGradient(colorStops = colorStops)
        GradientType.SWEEP -> Brush.sweepGradient(colorStops = colorStops)
    }
}
```

**5. Add extractGradientType and extractGradientStops helpers:**

Since Brush objects don't expose their internal structure, these helpers provide sensible defaults for existing themes. For SolidColor brushes, return VERTICAL type with a single-color two-stop gradient. For gradient brushes, since we can't introspect them, return VERTICAL with defaults.

```kotlin
private companion object {
    /** Best-effort gradient type extraction from a Brush. Brushes are opaque, so default to VERTICAL. */
    fun extractGradientType(brush: Brush): GradientType = GradientType.VERTICAL

    /** Best-effort gradient stop extraction from a Brush. Brushes are opaque, so use default stops. */
    fun extractGradientStops(brush: Brush): ImmutableList<GradientStop> {
        // Brush internals are not exposed -- return defaults.
        // When user edits, they'll set new stops that correctly persist.
        return persistentListOf(
            GradientStop(color = Color.Black.value.toLong(), position = 0f),
            GradientStop(color = Color.DarkGray.value.toLong(), position = 1f),
        )
    }
}
```

**6. Add reset() method** that restores all mutable properties to saved values:
```kotlin
public fun reset() {
    displayName = savedDisplayName
    primaryTextColor = savedPrimaryTextColor
    secondaryTextColor = savedSecondaryTextColor
    accentColor = savedAccentColor
    highlightColor = savedHighlightColor
    widgetBorderColor = savedWidgetBorderColor
    isDark = savedIsDark
    backgroundGradientType = savedBackgroundGradientType
    backgroundStops = savedBackgroundStops
    widgetBackgroundGradientType = savedWidgetBackgroundGradientType
    widgetBackgroundStops = savedWidgetBackgroundStops
}
```

**7. Remove the old backgroundBrush and widgetBackgroundBrush mutable properties.** They are now derived from gradient type + stops via buildBrush. If other code reads these properties, replace reads with `buildBrush(backgroundGradientType, backgroundStops)`.

**8. Update ThemeStudioStateHolderTest.kt:**

Add test for displayName:
```kotlin
@Test
fun `displayName initialized from existing theme`() {
    val holder = ThemeStudioStateHolder(existingTheme)
    assertThat(holder.displayName).isEqualTo("My Custom")
}

@Test
fun `displayName defaults to Custom Theme for new`() {
    val holder = ThemeStudioStateHolder(null)
    assertThat(holder.displayName).isEqualTo("Custom Theme")
}

@Test
fun `isDirty includes displayName change`() {
    val holder = ThemeStudioStateHolder(existingTheme)
    assertThat(holder.isDirty).isFalse()
    holder.displayName = "Renamed"
    assertThat(holder.isDirty).isTrue()
}

@Test
fun `reset restores all properties to initial`() {
    val holder = ThemeStudioStateHolder(existingTheme)
    holder.displayName = "Changed"
    holder.accentColor = Color.Red
    holder.isDark = !holder.isDark
    assertThat(holder.isDirty).isTrue()
    holder.reset()
    assertThat(holder.isDirty).isFalse()
    assertThat(holder.displayName).isEqualTo("My Custom")
}

@Test
fun `buildCustomTheme uses mutable displayName`() {
    val holder = ThemeStudioStateHolder(null)
    holder.displayName = "Sunset Glow"
    val theme = holder.buildCustomTheme("test_id")
    assertThat(theme.displayName).isEqualTo("Sunset Glow")
}
```

Update the existing `buildCustomTheme` test if it passes displayName as a parameter -- the param is removed. It now reads from the mutable property.
  </action>
  <verify>
    <automated>cd android && ./gradlew :feature:settings:testDebugUnitTest --tests "*.ThemeStudioStateHolderTest" --console=plain 2>&1 | tail -10</automated>
  </verify>
  <done>
    - displayName mutable property added, initialized from existingTheme
    - isDirty includes displayName and gradient comparisons
    - buildCustomTheme uses mutable displayName (no param)
    - Gradient state properties: backgroundGradientType, backgroundStops, widgetBackgroundGradientType, widgetBackgroundStops
    - buildBrush helper converts gradient state to Compose Brush
    - reset() restores all properties to saved/initial values
    - Old backgroundBrush/widgetBackgroundBrush mutable properties removed
    - All state holder tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ThemeStudio layout, ThemeSwatchRow dimensions, wire gradient editing</name>
  <files>
    android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudio.kt
    android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeSwatchRow.kt
    android/feature/settings/src/test/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudioTest.kt
  </files>
  <action>
**A. Update ThemeSwatchRow.kt -- fix swatch dimensions and selection color:**

**1. Change swatch from 40dp circle to 48dp rounded-square container with 36dp inner circle:**

Replace the Box in the forEach loop:
```kotlin
types.forEach { swatchType ->
    val isSelected = swatchType == selected
    val swatchColor = swatchType.resolveColor(theme)
    val borderColor = if (isSelected) theme.highlightColor else Color.Transparent  // highlightColor, NOT accentColor
    val containerShape = RoundedCornerShape(8.dp)

    Box(
        modifier = Modifier
            .size(48.dp)  // 48dp container (NOT 40dp)
            .clip(containerShape)
            .background(
                color = if (isSelected) theme.highlightColor.copy(alpha = 0.15f) else Color.Transparent,
                shape = containerShape,
            )
            .border(2.dp, borderColor, containerShape)
            .clickable { onSelected(swatchType) }
            .semantics { contentDescription = swatchType.displayName }
            .testTag("swatch_${swatchType.name}"),
        contentAlignment = Alignment.Center,
    ) {
        // 36dp inner color circle
        Box(
            modifier = Modifier
                .size(36.dp)  // 36dp inner circle (NOT 40dp)
                .clip(CircleShape)
                .background(swatchColor, CircleShape),
        )
    }
}
```

**2. Add required imports:**
```kotlin
import androidx.compose.foundation.layout.Box  // if not already
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.ui.Alignment
```

Remove `.size(40.dp)` reference.

**B. Update ThemeStudio.kt -- editable title, undo/delete buttons, wire gradient editing:**

**1. Change OverlayScaffold title** from conditional "Edit Theme"/"New Theme" to generic "Theme Studio":
```kotlin
OverlayScaffold(
    title = "Theme Studio",
    overlayType = OverlayType.Preview,
    onClose = onClose,
    modifier = modifier.testTag("theme_studio"),
) {
```

**2. Add custom header row inside content** with editable BasicTextField + undo/delete buttons:
```kotlin
// -- Custom header: editable title + undo/delete buttons --
Row(
    modifier = Modifier.fillMaxWidth().testTag("theme_studio_header"),
    verticalAlignment = Alignment.CenterVertically,
    horizontalArrangement = Arrangement.spacedBy(DashboardSpacing.SpaceXS),
) {
    // Editable theme name
    BasicTextField(
        value = stateHolder.displayName,
        onValueChange = { stateHolder.displayName = it },
        textStyle = DashboardTypography.itemTitle.copy(color = theme.primaryTextColor),
        singleLine = true,
        cursorBrush = SolidColor(theme.accentColor),
        modifier = Modifier
            .weight(1f)
            .testTag("editable_title"),
    )

    // Undo button -- alpha-dimmed when not dirty
    Box(
        modifier = Modifier
            .sizeIn(minWidth = 48.dp, minHeight = 48.dp)
            .alpha(if (stateHolder.isDirty) 1f else TextEmphasis.Disabled)
            .testTag("undo_button")
            .semantics { role = Role.Button }
            .clickable(enabled = stateHolder.isDirty) { stateHolder.reset() },
        contentAlignment = Alignment.Center,
    ) {
        Icon(
            imageVector = Icons.Filled.Undo,
            contentDescription = "Undo changes",
            tint = theme.primaryTextColor.copy(alpha = if (stateHolder.isDirty) TextEmphasis.High else TextEmphasis.Disabled),
            modifier = Modifier.size(20.dp),
        )
    }

    // Delete button -- hidden for new themes
    if (existingTheme != null) {
        Box(
            modifier = Modifier
                .sizeIn(minWidth = 48.dp, minHeight = 48.dp)
                .testTag("delete_button")
                .semantics { role = Role.Button }
                .clickable {
                    onClearPreview()
                    onDelete(stableThemeId)
                },
            contentAlignment = Alignment.Center,
        ) {
            Icon(
                imageVector = Icons.Filled.Delete,
                contentDescription = "Delete theme",
                tint = theme.warningColor,
                modifier = Modifier.size(20.dp),
            )
        }
    }
}
```

Add imports:
```kotlin
import androidx.compose.foundation.text.BasicTextField
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Undo
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.semantics.Role
import androidx.compose.ui.semantics.role
import androidx.compose.ui.semantics.semantics
import app.dqxn.android.core.design.token.TextEmphasis
```

**3. Wire gradient editing** -- replace the placeholder text for BACKGROUND and WIDGET_BACKGROUND swatches with GradientTypeSelector + GradientStopRow:

```kotlin
SwatchType.BACKGROUND -> {
    Column(verticalArrangement = Arrangement.spacedBy(DashboardSpacing.ItemGap)) {
        GradientTypeSelector(
            selected = stateHolder.backgroundGradientType,
            onSelected = { stateHolder.backgroundGradientType = it },
            modifier = Modifier.testTag("gradient_type_background"),
        )
        GradientStopRow(
            stops = stateHolder.backgroundStops,
            onStopsChanged = { stateHolder.backgroundStops = it },
            modifier = Modifier.testTag("gradient_stops_background"),
        )
    }
}
SwatchType.WIDGET_BACKGROUND -> {
    Column(verticalArrangement = Arrangement.spacedBy(DashboardSpacing.ItemGap)) {
        GradientTypeSelector(
            selected = stateHolder.widgetBackgroundGradientType,
            onSelected = { stateHolder.widgetBackgroundGradientType = it },
            modifier = Modifier.testTag("gradient_type_widget_background"),
        )
        GradientStopRow(
            stops = stateHolder.widgetBackgroundStops,
            onStopsChanged = { stateHolder.widgetBackgroundStops = it },
            modifier = Modifier.testTag("gradient_stops_widget_background"),
        )
    }
}
```

**4. Update buildPreviewTheme helper** since buildCustomTheme no longer takes displayName:
```kotlin
private fun buildPreviewTheme(
    stateHolder: ThemeStudioStateHolder,
    themeId: String,
): DashboardThemeDefinition = stateHolder.buildCustomTheme(themeId)
```
(This should already be correct since we removed the displayName parameter.)

**5. Update auto-save snapshotFlow** -- the existing `isDirty` monitor should still work since isDirty now includes displayName and gradient changes. Verify the snapshotFlow still fires when gradient stops or gradient type change. Since isDirty is a derivedStateOf that reads gradient properties, any change to those mutable states will trigger isDirty recomputation, which will trigger the snapshotFlow.

**C. Update ThemeStudioTest.kt:**

**1. Update all ThemeStudio call sites** since buildCustomTheme signature changed (no displayName param). Check if any tests call `stateHolder.buildCustomTheme(themeId, displayName)` and update to `stateHolder.buildCustomTheme(themeId)`.

**2. Add new tests:**

```kotlin
@Test
fun `editable title field exists`() {
    composeTestRule.setContent {
        CompositionLocalProvider(LocalDashboardTheme provides containerTheme) {
            ThemeStudio(
                existingTheme = existingTheme,
                customThemeCount = 1,
                onAutoSave = {},
                onDelete = {},
                onClearPreview = {},
                onClose = {},
            )
        }
    }
    composeTestRule.waitForIdle()
    composeTestRule.mainClock.advanceTimeBy(1000)
    composeTestRule.waitForIdle()

    composeTestRule.onNodeWithTag("editable_title", useUnmergedTree = true).assertExists()
}

@Test
fun `undo button exists`() {
    composeTestRule.setContent {
        CompositionLocalProvider(LocalDashboardTheme provides containerTheme) {
            ThemeStudio(
                existingTheme = existingTheme,
                customThemeCount = 1,
                onAutoSave = {},
                onDelete = {},
                onClearPreview = {},
                onClose = {},
            )
        }
    }
    composeTestRule.waitForIdle()
    composeTestRule.mainClock.advanceTimeBy(1000)
    composeTestRule.waitForIdle()

    composeTestRule.onNodeWithTag("undo_button", useUnmergedTree = true).assertExists()
}

@Test
fun `delete button shown for existing theme`() {
    composeTestRule.setContent {
        CompositionLocalProvider(LocalDashboardTheme provides containerTheme) {
            ThemeStudio(
                existingTheme = existingTheme,
                customThemeCount = 1,
                onAutoSave = {},
                onDelete = {},
                onClearPreview = {},
                onClose = {},
            )
        }
    }
    composeTestRule.waitForIdle()
    composeTestRule.mainClock.advanceTimeBy(1000)
    composeTestRule.waitForIdle()

    composeTestRule.onNodeWithTag("delete_button", useUnmergedTree = true).assertExists()
}

@Test
fun `delete button hidden for new theme`() {
    composeTestRule.setContent {
        CompositionLocalProvider(LocalDashboardTheme provides containerTheme) {
            ThemeStudio(
                existingTheme = null,
                customThemeCount = 0,
                onAutoSave = {},
                onDelete = {},
                onClearPreview = {},
                onClose = {},
            )
        }
    }
    composeTestRule.waitForIdle()
    composeTestRule.mainClock.advanceTimeBy(1000)
    composeTestRule.waitForIdle()

    composeTestRule.onNodeWithTag("delete_button", useUnmergedTree = true).assertDoesNotExist()
}

@Test
fun `swatch dimensions are 48dp container in source`() {
    val file = File(System.getProperty("user.dir"),
        "feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeSwatchRow.kt")
    val content = file.readText()
    assertThat(content).contains(".size(48.dp)")
    assertThat(content).contains(".size(36.dp)")
    assertThat(content).doesNotContain(".size(40.dp)")
}

@Test
fun `swatch selection uses highlightColor not accentColor`() {
    val file = File(System.getProperty("user.dir"),
        "feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeSwatchRow.kt")
    val content = file.readText()
    assertThat(content).contains("theme.highlightColor")
    // Verify the border uses highlightColor
    assertThat(content).doesNotContain("if (isSelected) theme.accentColor")
}

@Test
fun `gradient editing wired for background swatch`() {
    val file = File(System.getProperty("user.dir"),
        "feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudio.kt")
    val content = file.readText()
    assertThat(content).contains("GradientTypeSelector")
    assertThat(content).contains("GradientStopRow")
    assertThat(content).doesNotContain("Gradient editing for")  // placeholder text removed
}

@Test
fun `editable title uses BasicTextField in source`() {
    val file = File(System.getProperty("user.dir"),
        "feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/theme/ThemeStudio.kt")
    val content = file.readText()
    assertThat(content).contains("BasicTextField")
}
```

**3. Add import:**
```kotlin
import java.io.File
```
  </action>
  <verify>
    <automated>cd android && ./gradlew :feature:settings:testDebugUnitTest --tests "*.ThemeStudioTest" --console=plain 2>&1 | tail -10</automated>
  </verify>
  <done>
    - ThemeStudio has editable BasicTextField title
    - Undo button in header, alpha-dimmed when not dirty
    - Delete button in header, hidden for new themes
    - ThemeSwatchRow uses 48dp container + 36dp inner circle (not 40dp flat)
    - ThemeSwatchRow selection border uses highlightColor (not accentColor)
    - Gradient editing wires GradientTypeSelector + GradientStopRow for BACKGROUND and WIDGET_BACKGROUND
    - Placeholder gradient text removed
    - Source verification tests pass for swatch dimensions, highlightColor, gradient wiring, BasicTextField
    - UI tests pass for editable title, undo, delete visible/hidden
    - All tests pass
  </done>
</task>

</tasks>

<verification>
1. `cd android && ./gradlew :feature:settings:compileDebugKotlin --console=plain` -- compiles
2. `cd android && ./gradlew :feature:settings:testDebugUnitTest --tests "*.ThemeStudioTest" --console=plain` -- all tests pass
3. `cd android && ./gradlew :feature:settings:testDebugUnitTest --tests "*.ThemeStudioStateHolderTest" --console=plain` -- all tests pass
4. `cd android && ./gradlew :feature:settings:testDebugUnitTest --console=plain` -- no regressions
</verification>

<success_criteria>
- ThemeStudio title is editable BasicTextField, not static Text
- Undo button resets state holder to initial values
- Delete button calls onClearPreview + onDelete, hidden for new themes
- ThemeSwatchRow: 48dp rounded-square container with 36dp inner circle
- ThemeSwatchRow: selection border uses highlightColor
- Gradient editing: GradientTypeSelector + GradientStopRow wired for BACKGROUND and WIDGET_BACKGROUND
- ThemeStudioStateHolder: displayName mutable, gradient state, reset() method
- Auto-save fires on all dirty changes including displayName and gradient
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-ui-visual-interactive-parity/14-14-SUMMARY.md`
</output>
