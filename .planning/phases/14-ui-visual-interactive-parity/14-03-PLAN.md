---
phase: 14-ui-visual-interactive-parity
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/DashboardGrid.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/grid/CornerBracketTest.kt
autonomous: true
requirements: [F1.11, F1.20]

must_haves:
  truths:
    - "Edit mode shows Canvas-drawn corner brackets with pulsing stroke width (3dp to 6dp, 800ms)"
    - "Bracket pulse animates stroke width NOT widget scale"
    - "Grid snap overlay shows grid lines during drag"
    - "Visual grid overlay visible only while drag is active"
    - "Reduced motion disables bracket pulse and grid overlay animation"
  artifacts:
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/DashboardGrid.kt"
      provides: "Canvas corner brackets + grid snap overlay + drag lift scale"
      contains: "drawLine"
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/grid/CornerBracketTest.kt"
      provides: "Corner bracket + grid overlay tests"
  key_links:
    - from: "DashboardGrid.kt"
      to: "EditState.isEditMode"
      via: "Conditional bracket rendering"
      pattern: "isEditMode"
---

<objective>
Replace broken bracket scale animation with Canvas-drawn corner brackets, add drag lift effect, and
implement visual grid snap overlay during drag.

Purpose: F1.11 requires corner brackets in edit mode. Current implementation animates scaleX/scaleY
1.0-1.02f on the entire widget -- visually wrong (content breathes/zooms) and differs from old
codebase which animated Canvas stroke width 3-6dp. F1.20 requires visual grid overlay during drag.
Drag lift scale (1.03f spring) is missing from graphicsLayer.

Output: Correct Canvas bracket drawing, drag lift scale, grid line overlay during drag.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/DashboardGrid.kt
@android/core/design/src/main/kotlin/app/dqxn/android/core/design/motion/DashboardMotion.kt

<interfaces>
<!-- DashboardGrid uses Layout + custom MeasurePolicy, NOT LazyLayout -->
<!-- editState.isEditMode drives bracket visibility -->
<!-- dragState: DragUpdate? contains widgetId, currentOffsetX/Y, isDragging -->
<!-- reducedMotionHelper.isReducedMotion gates all animations -->
<!-- GridConstants.GRID_UNIT_SIZE = 16.dp -->
<!-- Each widget is wrapped in graphicsLayer for isolated RenderNode -->
<!-- Current bracketScale animation (scaleX/scaleY 1.0-1.02f) is WRONG and must be replaced -->
<!-- Wiggle animation (rotationZ +-0.5f, 150ms) is CORRECT and must be preserved -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace bracket scale with Canvas brackets + add drag lift + grid overlay</name>
  <files>
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/DashboardGrid.kt
  </files>
  <action>
**Remove the broken bracketScale animation entirely.** Delete the `bracketScale` variable and its infiniteTransition. Remove `scaleX = bracketScale` and `scaleY = bracketScale` from the graphicsLayer.

**Add bracket stroke width animation** (replaces bracketScale):

```kotlin
// Bracket stroke pulse for edit mode (F1.11) -- Canvas-drawn, NOT scale
val bracketStrokeWidth = if (isEditMode && !isReducedMotion) {
    val infiniteTransition = rememberInfiniteTransition(label = "bracket_stroke_${widget.instanceId}")
    val strokeWidth by infiniteTransition.animateFloat(
        initialValue = 3f,
        targetValue = 6f,
        animationSpec = infiniteRepeatable(
            animation = tween(durationMillis = 800, easing = FastOutSlowInEasing),
            repeatMode = RepeatMode.Reverse,
        ),
        label = "bracket_stroke_${widget.instanceId}",
    )
    strokeWidth
} else if (isEditMode) {
    4f // Static midpoint for reduced motion
} else {
    0f // Not in edit mode
}
```

Add import: `import androidx.compose.animation.core.FastOutSlowInEasing`

**Add drag lift scale** (missing from old port):

```kotlin
// Drag lift scale (old codebase: 1.03f spring on drag)
val isDragging = widgetDragState?.isDragging == true
val liftScale by animateFloatAsState(
    targetValue = if (isDragging) 1.03f else 1f,
    animationSpec = if (isReducedMotion) snap() else spring(
        dampingRatio = Spring.DampingRatioMediumBouncy,
        stiffness = Spring.StiffnessMedium,
    ),
    label = "lift_scale_${widget.instanceId}",
)
```

**Update graphicsLayer** on WidgetSlot to include liftScale and remove bracketScale:

```kotlin
.graphicsLayer {
    // Drag offset via graphicsLayer (NOT Modifier.offset)
    if (widgetDragState != null) {
        translationX = widgetDragState.currentOffsetX
        translationY = widgetDragState.currentOffsetY
    }
    // Edit mode wiggle
    rotationZ = wiggleRotation
    // Drag lift scale
    scaleX = liftScale
    scaleY = liftScale
}
```

**Add Canvas corner brackets** as an overlay after WidgetSlot within the AnimatedVisibility block. The brackets are drawn AROUND the widget content using a Box wrapper:

```kotlin
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.matchParentSize
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color

// Replace the standalone WidgetSlot call with a Box containing both WidgetSlot + Canvas brackets:
Box {
    WidgetSlot(
        widget = widget,
        widgetBindingCoordinator = widgetBindingCoordinator,
        widgetRegistry = widgetRegistry,
        editModeCoordinator = editModeCoordinator,
        resizeState = resizeState,
        onCommand = onCommand,
        modifier = gestureModifier
            .graphicsLayer {
                if (widgetDragState != null) {
                    translationX = widgetDragState.currentOffsetX
                    translationY = widgetDragState.currentOffsetY
                }
                rotationZ = wiggleRotation
                scaleX = liftScale
                scaleY = liftScale
            },
    )

    // Corner brackets for edit mode (F1.11)
    if (isEditMode && bracketStrokeWidth > 0f) {
        Canvas(
            modifier = Modifier
                .matchParentSize()
                .graphicsLayer {
                    // Apply same drag offset so brackets follow widget
                    if (widgetDragState != null) {
                        translationX = widgetDragState.currentOffsetX
                        translationY = widgetDragState.currentOffsetY
                    }
                    scaleX = liftScale
                    scaleY = liftScale
                }
                .testTag("bracket_${widget.instanceId}"),
        ) {
            val strokePx = bracketStrokeWidth.dp.toPx()
            val bracketLength = 16.dp.toPx()
            val color = Color.White

            // Top-left corner
            drawLine(color, Offset(0f, strokePx / 2), Offset(bracketLength, strokePx / 2), strokePx)
            drawLine(color, Offset(strokePx / 2, 0f), Offset(strokePx / 2, bracketLength), strokePx)

            // Top-right corner
            drawLine(color, Offset(size.width - bracketLength, strokePx / 2), Offset(size.width, strokePx / 2), strokePx)
            drawLine(color, Offset(size.width - strokePx / 2, 0f), Offset(size.width - strokePx / 2, bracketLength), strokePx)

            // Bottom-left corner
            drawLine(color, Offset(0f, size.height - strokePx / 2), Offset(bracketLength, size.height - strokePx / 2), strokePx)
            drawLine(color, Offset(strokePx / 2, size.height - bracketLength), Offset(strokePx / 2, size.height), strokePx)

            // Bottom-right corner
            drawLine(color, Offset(size.width - bracketLength, size.height - strokePx / 2), Offset(size.width, size.height - strokePx / 2), strokePx)
            drawLine(color, Offset(size.width - strokePx / 2, size.height - bracketLength), Offset(size.width - strokePx / 2, size.height), strokePx)
        }
    }
}
```

Add necessary imports: `import androidx.compose.foundation.Canvas`, `import androidx.compose.foundation.layout.Box`, `import androidx.compose.foundation.layout.matchParentSize`, `import androidx.compose.ui.geometry.Offset`, `import androidx.compose.ui.graphics.Color`, `import androidx.compose.ui.unit.dp` (if not already imported).

**Add visual grid overlay during drag (F1.20):**

After the widget Layout content block, add a grid overlay that renders when ANY drag is active:

```kotlin
// Visual grid overlay during drag (F1.20)
if (dragState != null) {
    Canvas(
        modifier = Modifier
            .fillMaxSize()
            .testTag("grid_overlay"),
    ) {
        val gridPx = gridUnitPx
        val cols = (size.width / gridPx).toInt()
        val rows = (size.height / gridPx).toInt()
        val lineColor = Color.White.copy(alpha = 0.15f)

        // Vertical grid lines at 2-unit boundaries (snap boundary)
        for (col in 0..cols step 2) {
            val x = col * gridPx
            drawLine(lineColor, Offset(x, 0f), Offset(x, size.height), 1f)
        }
        // Horizontal grid lines at 2-unit boundaries
        for (row in 0..rows step 2) {
            val y = row * gridPx
            drawLine(lineColor, Offset(0f, y), Offset(size.width, y), 1f)
        }
    }
}
```

Add this grid overlay BEFORE the Layout call (so it renders behind widgets) or AFTER (so it renders on top). Rendering it inside a Box that wraps the Layout is cleanest -- render it BEHIND the Layout in the same parent Box so it shows as a background grid. Actually, the simplest approach: add the Canvas as part of the Layout modifier by drawing in `drawBehind`:

Instead, add a `Modifier.drawBehind` on the Layout modifier when drag is active:

```kotlin
val gridOverlayModifier = if (dragState != null) {
    Modifier.drawBehind {
        val gridPx = gridUnitPx
        val cols = (size.width / gridPx).toInt()
        val rows = (size.height / gridPx).toInt()
        val lineColor = Color.White.copy(alpha = 0.15f)
        for (col in 0..cols step 2) {
            val x = col * gridPx
            drawLine(lineColor, Offset(x, 0f), Offset(x, size.height), strokeWidth = 1f)
        }
        for (row in 0..rows step 2) {
            val y = row * gridPx
            drawLine(lineColor, Offset(0f, y), Offset(size.width, y), strokeWidth = 1f)
        }
    }
} else {
    Modifier
}
```

Add import: `import androidx.compose.ui.draw.drawBehind`

Then chain it onto the Layout modifier:
```kotlin
modifier = modifier
    .semantics {}
    .testTag("dashboard_grid")
    .then(blankSpaceModifier)
    .then(gridOverlayModifier)
```
  </action>
  <verify>
    <automated>cd android && ./gradlew :feature:dashboard:compileDebugKotlin --console=plain 2>&1 | tail -5</automated>
  </verify>
  <done>
    - bracketScale animation removed from graphicsLayer
    - Canvas corner brackets draw at all 4 corners with pulsing stroke width 3-6dp
    - Drag lift scale (1.03f) applied in graphicsLayer
    - Grid overlay renders behind widgets during drag
    - Wiggle rotation preserved unchanged
    - Reduced motion gates all animations
    - Compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Add corner bracket and grid overlay tests</name>
  <files>
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/grid/CornerBracketTest.kt
  </files>
  <action>
Create a Compose UI test that verifies bracket test tags appear in edit mode and grid overlay exists during drag:

```kotlin
package app.dqxn.android.feature.dashboard.grid

import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onNodeWithTag
import com.google.common.truth.Truth.assertThat
import io.mockk.every
import io.mockk.mockk
import kotlinx.collections.immutable.persistentListOf
import kotlinx.coroutines.flow.MutableStateFlow
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner
import org.robolectric.annotation.Config
import app.dqxn.android.data.layout.DashboardWidgetInstance
import app.dqxn.android.data.layout.GridPosition
import app.dqxn.android.data.layout.GridSize
import app.dqxn.android.feature.dashboard.coordinator.EditModeCoordinator
import app.dqxn.android.feature.dashboard.coordinator.EditState
import app.dqxn.android.feature.dashboard.coordinator.WidgetAnimationState
import app.dqxn.android.feature.dashboard.coordinator.WidgetBindingCoordinator
import app.dqxn.android.feature.dashboard.gesture.ReducedMotionHelper
import app.dqxn.android.sdk.contracts.registry.WidgetRegistry

@RunWith(RobolectricTestRunner::class)
@Config(sdk = [34])
class CornerBracketTest {

    @get:Rule
    val composeTestRule = createComposeRule()

    private val testWidget = DashboardWidgetInstance(
        instanceId = "w1",
        typeId = "essentials:clock-digital",
        profileId = "default",
        position = GridPosition(col = 0, row = 0),
        size = GridSize(widthUnits = 4, heightUnits = 4),
        zIndex = 0,
    )

    @Test
    fun `bracket test tags exist in edit mode`() {
        val editModeCoordinator = mockk<EditModeCoordinator>(relaxed = true)
        every { editModeCoordinator.editState } returns MutableStateFlow(EditState(isEditMode = true))
        every { editModeCoordinator.animatingWidgets } returns MutableStateFlow(emptySet())
        every { editModeCoordinator.isInteractionAllowed(any()) } returns false

        val widgetBindingCoordinator = mockk<WidgetBindingCoordinator>(relaxed = true)
        val widgetRegistry = mockk<WidgetRegistry>(relaxed = true)
        val reducedMotionHelper = mockk<ReducedMotionHelper>(relaxed = true)
        every { reducedMotionHelper.isReducedMotion } returns false
        val widgetGestureHandler = mockk<WidgetGestureHandler>(relaxed = true)
        val blankSpaceGestureHandler = mockk<BlankSpaceGestureHandler>(relaxed = true)

        composeTestRule.setContent {
            DashboardGrid(
                widgets = persistentListOf(testWidget),
                viewportCols = 20,
                viewportRows = 12,
                editState = EditState(isEditMode = true),
                dragState = null,
                resizeState = null,
                configurationBoundaries = persistentListOf(),
                widgetBindingCoordinator = widgetBindingCoordinator,
                widgetRegistry = widgetRegistry,
                editModeCoordinator = editModeCoordinator,
                reducedMotionHelper = reducedMotionHelper,
                widgetGestureHandler = widgetGestureHandler,
                blankSpaceGestureHandler = blankSpaceGestureHandler,
                onCommand = {},
            )
        }

        composeTestRule.onNodeWithTag("bracket_w1", useUnmergedTree = true).assertExists()
    }

    @Test
    fun `brackets do not render outside edit mode`() {
        val editModeCoordinator = mockk<EditModeCoordinator>(relaxed = true)
        every { editModeCoordinator.editState } returns MutableStateFlow(EditState(isEditMode = false))
        every { editModeCoordinator.animatingWidgets } returns MutableStateFlow(emptySet())
        every { editModeCoordinator.isInteractionAllowed(any()) } returns true

        val widgetBindingCoordinator = mockk<WidgetBindingCoordinator>(relaxed = true)
        val widgetRegistry = mockk<WidgetRegistry>(relaxed = true)
        val reducedMotionHelper = mockk<ReducedMotionHelper>(relaxed = true)
        every { reducedMotionHelper.isReducedMotion } returns false
        val widgetGestureHandler = mockk<WidgetGestureHandler>(relaxed = true)
        val blankSpaceGestureHandler = mockk<BlankSpaceGestureHandler>(relaxed = true)

        composeTestRule.setContent {
            DashboardGrid(
                widgets = persistentListOf(testWidget),
                viewportCols = 20,
                viewportRows = 12,
                editState = EditState(isEditMode = false),
                dragState = null,
                resizeState = null,
                configurationBoundaries = persistentListOf(),
                widgetBindingCoordinator = widgetBindingCoordinator,
                widgetRegistry = widgetRegistry,
                editModeCoordinator = editModeCoordinator,
                reducedMotionHelper = reducedMotionHelper,
                widgetGestureHandler = widgetGestureHandler,
                blankSpaceGestureHandler = blankSpaceGestureHandler,
                onCommand = {},
            )
        }

        composeTestRule.onNodeWithTag("bracket_w1").assertDoesNotExist()
    }

    @Test
    fun `dashboard grid tag exists`() {
        val editModeCoordinator = mockk<EditModeCoordinator>(relaxed = true)
        every { editModeCoordinator.editState } returns MutableStateFlow(EditState())
        every { editModeCoordinator.animatingWidgets } returns MutableStateFlow(emptySet())

        val widgetBindingCoordinator = mockk<WidgetBindingCoordinator>(relaxed = true)
        val widgetRegistry = mockk<WidgetRegistry>(relaxed = true)
        val reducedMotionHelper = mockk<ReducedMotionHelper>(relaxed = true)
        every { reducedMotionHelper.isReducedMotion } returns false
        val widgetGestureHandler = mockk<WidgetGestureHandler>(relaxed = true)
        val blankSpaceGestureHandler = mockk<BlankSpaceGestureHandler>(relaxed = true)

        composeTestRule.setContent {
            DashboardGrid(
                widgets = persistentListOf(),
                viewportCols = 20,
                viewportRows = 12,
                editState = EditState(),
                dragState = null,
                resizeState = null,
                configurationBoundaries = persistentListOf(),
                widgetBindingCoordinator = widgetBindingCoordinator,
                widgetRegistry = widgetRegistry,
                editModeCoordinator = editModeCoordinator,
                reducedMotionHelper = reducedMotionHelper,
                widgetGestureHandler = widgetGestureHandler,
                blankSpaceGestureHandler = blankSpaceGestureHandler,
                onCommand = {},
            )
        }

        composeTestRule.onNodeWithTag("dashboard_grid").assertExists()
    }
}
```

The tests verify bracket rendering via test tags (Canvas nodes have test tags). Grid overlay is verified by the drawBehind modifier which doesn't produce a separate semantics node -- test the drag state integration separately.

Adapt imports based on actual DashboardWidgetInstance constructor. If the constructor differs, adjust field names to match.
  </action>
  <verify>
    <automated>cd android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.CornerBracketTest" --console=plain 2>&1 | tail -10</automated>
  </verify>
  <done>
    - All 3 bracket tests pass
    - Brackets appear in edit mode, absent otherwise
    - Dashboard grid tag always present
  </done>
</task>

</tasks>

<verification>
1. `cd android && ./gradlew :feature:dashboard:compileDebugKotlin --console=plain` -- compiles
2. `cd android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.CornerBracketTest" --console=plain` -- all tests pass
3. `cd android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.DashboardGridTest" --console=plain` -- existing tests still pass
</verification>

<success_criteria>
- Canvas corner brackets with stroke pulse 3-6dp (not scale) in edit mode
- Drag lift scale 1.03f via graphicsLayer
- Grid overlay with 2-unit boundary lines during drag
- Wiggle animation preserved
- Reduced motion disables all animations
- All bracket tests pass
- All existing DashboardGridTest tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-ui-visual-interactive-parity/14-03-SUMMARY.md`
</output>
