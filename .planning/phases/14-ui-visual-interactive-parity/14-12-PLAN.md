---
phase: 14-ui-visual-interactive-parity
plan: 12
type: execute
wave: 2
depends_on: [14-09, 14-10, 14-11]
files_modified:
  - android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/overlay/OverlayScaffold.kt
  - android/feature/settings/build.gradle.kts
  - android/gradle/libs.versions.toml
  - android/feature/settings/src/test/kotlin/app/dqxn/android/feature/settings/overlay/OverlayScaffoldAdaptiveTest.kt
autonomous: true
requirements: []

must_haves:
  truths:
    - "On compact screens (< 600dp), overlay sheets render at full width (unchanged)"
    - "On medium screens (600-840dp), Hub overlays constrain to max 480dp centered, Preview to 520dp"
    - "On expanded screens (> 840dp), same constraints as medium screens"
    - "WindowSizeClass computation added to OverlayScaffold"
    - "Width constraint applied via Modifier.widthIn(max = maxWidth).align(CenterHorizontally)"
  artifacts:
    - path: "android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/overlay/OverlayScaffold.kt"
      provides: "WindowSizeClass-based width constraints for overlay sheets"
      contains: "widthIn"
    - path: "android/feature/settings/src/test/kotlin/app/dqxn/android/feature/settings/overlay/OverlayScaffoldAdaptiveTest.kt"
      provides: "Tests for adaptive width constraints"
  key_links:
    - from: "OverlayScaffold.kt"
      to: "OverlayType"
      via: "Width constraint varies by overlay type (Hub=480dp, Preview=520dp, Confirmation=400dp)"
      pattern: "maxWidthForType"
---

<objective>
Add adaptive width constraints to OverlayScaffold for medium and expanded screens.

Purpose: All overlay sheets currently use `fillMaxSize()` with no width constraints, rendering
identically on phone, tablet, and foldable. On larger screens (tablets, foldable inner displays),
full-width sheets look stretched and waste screen space. Material 3 adaptive patterns recommend
constraining sheet width on medium (600-840dp) and expanded (>840dp) screens.

This plan adds WindowSizeClass computation to OverlayScaffold and applies type-appropriate max-width
constraints. Hub overlays get 480dp max, Preview overlays get 520dp max, Confirmation overlays
get 400dp max. On compact screens, behavior is unchanged.

Depends on 14-09 (settings header), 14-10 (widget picker), 14-11 (onboarding) because this
modifies the shared OverlayScaffold that those plans' composables use.

Output: Width-constrained, centered overlay sheets on medium+ screens.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/overlay/OverlayScaffold.kt
@android/feature/settings/build.gradle.kts
@android/gradle/libs.versions.toml

<interfaces>
<!-- OverlayScaffold(title, overlayType, onClose, modifier, visible, content) -->
<!-- OverlayType: Hub (0dp corners), Preview (top-rounded), Confirmation (all-rounded) -->
<!-- Current OverlayScaffold applies: clip, background, padding, then content -->
<!-- No width constraints exist -- caller controls via modifier -->
<!-- WindowSizeClass API:
     import androidx.compose.material3.windowsizeclass.WindowWidthSizeClass
     import androidx.compose.material3.windowsizeclass.calculateWindowSizeClass
     OR use BoxWithConstraints + manual breakpoints:
       maxWidth < 600.dp -> Compact
       maxWidth < 840.dp -> Medium
       maxWidth >= 840.dp -> Expanded
-->
<!-- The material3-window-size-class artifact is in compose BOM but needs explicit dependency -->
<!-- Alternative: Use BoxWithConstraints and manual dp breakpoints to avoid extra dep -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add adaptive width constraints to OverlayScaffold</name>
  <files>
    android/feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/overlay/OverlayScaffold.kt
    android/feature/settings/build.gradle.kts
    android/gradle/libs.versions.toml
  </files>
  <action>
1. **Choose approach**: Use `BoxWithConstraints` with manual dp breakpoints rather than adding
   `material3-window-size-class` dependency. This avoids pulling in a new library for a simple
   breakpoint check. The breakpoints are:
   - Compact: maxWidth < 600dp (no constraint)
   - Medium: 600dp <= maxWidth < 840dp (apply max-width)
   - Expanded: maxWidth >= 840dp (apply max-width)

2. **Add max-width constants** per overlay type:
```kotlin
/** Maximum content width per overlay type on medium+ screens. */
private fun OverlayType.maxWidthDp(): Dp = when (this) {
    OverlayType.Hub -> 480.dp
    OverlayType.Preview -> 520.dp
    OverlayType.Confirmation -> 400.dp
}

/** Compact screen width threshold. Below this, no width constraint is applied. */
private val COMPACT_MAX_WIDTH = 600.dp
```

3. **Wrap OverlayScaffold content in BoxWithConstraints** to read available width, then apply
   `Modifier.widthIn(max = ...)` when on medium+ screens:

```kotlin
import androidx.compose.foundation.layout.BoxWithConstraints
import androidx.compose.foundation.layout.widthIn
import androidx.compose.ui.Alignment

@Composable
public fun OverlayScaffold(
  title: String,
  overlayType: OverlayType,
  onClose: () -> Unit,
  modifier: Modifier = Modifier,
  visible: Boolean = true,
  content: @Composable () -> Unit,
) {
  val theme = LocalDashboardTheme.current
  val cornerRadius = CardSize.LARGE.cornerRadius
  val shape = overlayType.toShape(cornerRadius)

  AnimatedVisibility(
    visible = visible,
    enter = DashboardMotion.sheetEnter,
    exit = DashboardMotion.sheetExit,
  ) {
    BoxWithConstraints(
      modifier = Modifier.fillMaxSize(),
      contentAlignment = when (overlayType) {
        OverlayType.Hub -> Alignment.Center
        OverlayType.Preview -> Alignment.BottomCenter
        OverlayType.Confirmation -> Alignment.Center
      },
    ) {
      val isCompact = maxWidth < COMPACT_MAX_WIDTH
      val contentModifier = if (isCompact) {
        modifier
      } else {
        modifier.widthIn(max = overlayType.maxWidthDp())
      }

      Column(
        modifier = contentModifier
          .testTag("overlay_scaffold_${overlayType.name.lowercase()}")
          .clip(shape)
          .background(theme.backgroundBrush, shape)
          .padding(DashboardSpacing.ScreenEdgePadding),
      ) {
        OverlayTitleBar(title = title, onClose = onClose)
        content()
      }
    }
  }
}
```

**Key considerations:**
- On compact screens: behavior identical to current (fills available space via caller's modifier)
- On medium+ screens: Column gets `widthIn(max = ...)` which constrains maximum width
- `contentAlignment` varies by type: Hub/Confirmation are centered, Preview is bottom-anchored
- The `BoxWithConstraints` provides the parent constraints needed for the breakpoint check

**Alternative approach** if BoxWithConstraints causes issues with existing tests or layout:
Use `LocalConfiguration.current.screenWidthDp.dp` instead of `BoxWithConstraints.maxWidth`:
```kotlin
val screenWidth = LocalConfiguration.current.screenWidthDp.dp
val isCompact = screenWidth < COMPACT_MAX_WIDTH
```
This is simpler and doesn't add a layout level, but uses screen width instead of available width.
For overlays that always fill the screen, these are equivalent. Use this simpler approach.

4. **For Hub-type overlays**: On medium+ screens, the Hub fills height but constrains width.
   Add `fillMaxHeight()` to the Column modifier when Hub is constrained:

```kotlin
val contentModifier = if (isCompact) {
  modifier
} else {
  val baseModifier = modifier.widthIn(max = overlayType.maxWidthDp())
  if (overlayType == OverlayType.Hub) {
    baseModifier.fillMaxHeight()
  } else {
    baseModifier
  }
}
```

5. **No new dependencies needed** if using LocalConfiguration approach. If using BoxWithConstraints,
   it's already available from compose-foundation (already a dependency).
  </action>
  <verify>
    <automated>cd android && ./gradlew :feature:settings:compileDebugKotlin --console=plain 2>&1 | tail -5</automated>
  </verify>
  <done>
    - OverlayScaffold applies width constraints on medium+ screens
    - Hub: max 480dp, centered
    - Preview: max 520dp, bottom-anchored
    - Confirmation: max 400dp, centered
    - Compact screens unchanged (no constraint)
    - Compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Add adaptive layout tests</name>
  <files>
    android/feature/settings/src/test/kotlin/app/dqxn/android/feature/settings/overlay/OverlayScaffoldAdaptiveTest.kt
  </files>
  <action>
Create tests verifying the adaptive behavior:

```kotlin
package app.dqxn.android.feature.settings.overlay

import com.google.common.truth.Truth.assertThat
import org.junit.jupiter.api.Test
import java.io.File

class OverlayScaffoldAdaptiveTest {

    private val projectDir = File(System.getProperty("user.dir"))

    @Test
    fun `OverlayScaffold contains width constraint logic`() {
        val file = File(
            projectDir,
            "feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/overlay/OverlayScaffold.kt"
        )
        val content = file.readText()
        assertThat(content).contains("widthIn")
        assertThat(content).contains("maxWidthDp")
    }

    @Test
    fun `Hub overlay max width is 480dp`() {
        val file = File(
            projectDir,
            "feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/overlay/OverlayScaffold.kt"
        )
        val content = file.readText()
        assertThat(content).contains("480.dp")
    }

    @Test
    fun `Preview overlay max width is 520dp`() {
        val file = File(
            projectDir,
            "feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/overlay/OverlayScaffold.kt"
        )
        val content = file.readText()
        assertThat(content).contains("520.dp")
    }

    @Test
    fun `Confirmation overlay max width is 400dp`() {
        val file = File(
            projectDir,
            "feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/overlay/OverlayScaffold.kt"
        )
        val content = file.readText()
        assertThat(content).contains("400.dp")
    }

    @Test
    fun `compact threshold is 600dp`() {
        val file = File(
            projectDir,
            "feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/overlay/OverlayScaffold.kt"
        )
        val content = file.readText()
        assertThat(content).contains("600.dp")
    }

    @Test
    fun `compact screens have no width constraint`() {
        val file = File(
            projectDir,
            "feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/overlay/OverlayScaffold.kt"
        )
        val content = file.readText()
        // Verify the isCompact check gates the width constraint
        assertThat(content).contains("isCompact")
    }

    @Test
    fun `existing OverlayScaffold API unchanged`() {
        val file = File(
            projectDir,
            "feature/settings/src/main/kotlin/app/dqxn/android/feature/settings/overlay/OverlayScaffold.kt"
        )
        val content = file.readText()
        // Public API signature must be preserved
        assertThat(content).contains("public fun OverlayScaffold(")
        assertThat(content).contains("title: String")
        assertThat(content).contains("overlayType: OverlayType")
        assertThat(content).contains("onClose: () -> Unit")
        assertThat(content).contains("visible: Boolean")
        assertThat(content).contains("content: @Composable () -> Unit")
    }
}
```

Also check existing OverlayScaffoldTest passes -- the public API hasn't changed so existing
tests should still work, but verify.
  </action>
  <verify>
    <automated>cd android && ./gradlew :feature:settings:testDebugUnitTest --tests "*.OverlayScaffoldAdaptiveTest" --console=plain 2>&1 | tail -10</automated>
  </verify>
  <done>
    - All 7 adaptive tests pass
    - Width constraint values verified for each overlay type
    - Compact threshold verified
    - Compact exemption verified
    - Public API unchanged
  </done>
</task>

</tasks>

<verification>
1. `cd android && ./gradlew :feature:settings:compileDebugKotlin --console=plain` -- compiles
2. `cd android && ./gradlew :feature:settings:testDebugUnitTest --tests "*.OverlayScaffoldAdaptiveTest" --console=plain` -- all tests pass
3. `cd android && ./gradlew :feature:settings:testDebugUnitTest --tests "*.OverlayScaffoldTest" --console=plain` -- existing tests pass
4. `cd android && ./gradlew :feature:settings:testDebugUnitTest --console=plain` -- no regressions
</verification>

<success_criteria>
- Hub overlays constrain to max 480dp on medium+ screens
- Preview overlays constrain to max 520dp on medium+ screens
- Confirmation overlays constrain to max 400dp on medium+ screens
- Compact screens (< 600dp) unchanged (no width constraint)
- OverlayScaffold public API unchanged (no breaking changes)
- Hub centered, Preview bottom-anchored on constrained screens
- All tests pass including existing OverlayScaffold tests
</success_criteria>

<output>
After completion, create `.planning/phases/14-ui-visual-interactive-parity/14-12-SUMMARY.md`
</output>
