---
phase: 14-ui-visual-interactive-parity
plan: 07
type: execute
wave: 2
depends_on: [14-03, 14-04]
files_modified:
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/DashboardGrid.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetSlot.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/EditModeCoordinator.kt
  - android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/FocusOverlayToolbar.kt
  - android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/grid/FocusOverlayToolbarTest.kt
autonomous: true
requirements: [F1.8, F2.18]

must_haves:
  truths:
    - "Focused widget in edit mode shows delete and settings action buttons above widget"
    - "Action buttons have press scale animation (0.85f spring)"
    - "Tap on widget content in edit mode toggles focus"
    - "Tap outside focused widget unfocuses"
    - "Interactive widget actions only work in non-focused, non-edit mode"
    - "Focus overlay toolbar has highest z-index (above all widgets)"
    - "settingsAlpha fades non-focused widgets during settings peek"
  artifacts:
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/FocusOverlayToolbar.kt"
      provides: "Focus overlay toolbar composable with delete/settings buttons"
      contains: "FocusOverlayToolbar"
    - path: "android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/DashboardGrid.kt"
      provides: "Focus toolbar rendering at highest z-index"
      contains: "FocusOverlayToolbar"
    - path: "android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/grid/FocusOverlayToolbarTest.kt"
      provides: "Focus overlay tests"
  key_links:
    - from: "DashboardGrid.kt"
      to: "FocusOverlayToolbar.kt"
      via: "Rendered when editState.focusedWidgetId matches widget"
      pattern: "focusedWidgetId"
    - from: "FocusOverlayToolbar.kt"
      to: "DashboardCommand.DeleteWidget"
      via: "Delete button fires command"
      pattern: "DeleteWidget"
---

<objective>
Implement focus overlay toolbar with delete/settings action buttons for focused widgets in edit mode.

Purpose: F1.8 requires overlay toolbar (delete/settings) when a widget has focus in edit mode. F2.18
defines the focus interaction model: tap to focus, tap content to unfocus, interactive actions gated.
Currently the `focusedWidgetId` field exists in EditState but no visual toolbar is rendered. The
tap-to-focus gesture needs wiring in the grid.

Output: FocusOverlayToolbar composable, grid integration, tap-to-focus wiring, tests.
</objective>

<execution_context>
@/Users/ohm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ohm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/DashboardGrid.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/coordinator/EditModeCoordinator.kt
@android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetSlot.kt

<interfaces>
<!-- EditState.focusedWidgetId: String? -- already exists -->
<!-- EditModeCoordinator.focusWidget(widgetId: String?) -- already exists -->
<!-- EditModeCoordinator.isInteractionAllowed(widgetId: String): Boolean -- already exists -->
<!-- DashboardCommand sealed interface includes DeleteWidget(widgetId: String) -->
<!-- DashboardCommand.OpenWidgetSettings(widgetId) — added by 14-04 -->
<!-- DashboardGrid renders widgets in Layout with custom MeasurePolicy -->
<!-- Widget graphicsLayer already has wiggle, bracket, lift animations from Plan 14-03 -->

Old focus overlay toolbar spec:
- Action buttons (delete + settings) in Row above widget, 16dp spacing
- Action button press scale: 0.85f, spring(DampingRatioMediumBouncy, StiffnessMedium)
- settingsAlpha: 0f for non-focused widgets during settings peek, tween(300ms)
- focusScale / focusTranslationX/Y: spring(StiffnessLow, DampingRatioNoBouncy) -- NOT used per F1.8 "no translate or scale"
- Toolbar at highest z-index (above all widgets)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FocusOverlayToolbar and wire into DashboardGrid</name>
  <files>
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/FocusOverlayToolbar.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/grid/DashboardGrid.kt
    android/feature/dashboard/src/main/kotlin/app/dqxn/android/feature/dashboard/binding/WidgetSlot.kt
  </files>
  <action>
**Create FocusOverlayToolbar.kt:**

```kotlin
package app.dqxn.android.feature.dashboard.grid

import androidx.compose.animation.core.Spring
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.spring
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.interaction.collectIsPressedAsState
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.size
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material3.FilledIconButton
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButtonDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.semantics.contentDescription
import androidx.compose.ui.semantics.semantics
import androidx.compose.ui.unit.dp

/**
 * Overlay toolbar rendered above a focused widget in edit mode (F1.8).
 *
 * Contains delete and settings action buttons with press-scale animation:
 * 0.85f spring(DampingRatioMediumBouncy, StiffnessMedium) on press.
 *
 * Positioned above the widget by the caller (DashboardGrid), not self-positioning.
 * Must have the highest z-index in the grid to avoid clipping behind adjacent widgets.
 *
 * Per F1.8: no translate or scale on the widget itself. Only the toolbar animates.
 */
@Composable
internal fun FocusOverlayToolbar(
    widgetId: String,
    onDelete: () -> Unit,
    onSettings: () -> Unit,
    modifier: Modifier = Modifier,
) {
    Row(
        modifier = modifier
            .testTag("focus_toolbar_$widgetId"),
        horizontalArrangement = Arrangement.spacedBy(16.dp),
    ) {
        // Delete button
        ActionButton(
            icon = Icons.Filled.Close,
            description = "Delete widget",
            testTag = "focus_delete_$widgetId",
            onClick = onDelete,
        )

        // Settings button
        ActionButton(
            icon = Icons.Filled.Settings,
            description = "Widget settings",
            testTag = "focus_settings_$widgetId",
            onClick = onSettings,
        )
    }
}

@Composable
private fun ActionButton(
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    description: String,
    testTag: String,
    onClick: () -> Unit,
) {
    val interactionSource = remember { MutableInteractionSource() }
    val isPressed by interactionSource.collectIsPressedAsState()

    val pressScale by animateFloatAsState(
        targetValue = if (isPressed) 0.85f else 1f,
        animationSpec = spring(
            dampingRatio = Spring.DampingRatioMediumBouncy,
            stiffness = Spring.StiffnessMedium,
        ),
        label = "action_press_scale",
    )

    FilledIconButton(
        onClick = onClick,
        modifier = Modifier
            .size(40.dp)
            .graphicsLayer {
                scaleX = pressScale
                scaleY = pressScale
            }
            .testTag(testTag)
            .semantics { contentDescription = description },
        colors = IconButtonDefaults.filledIconButtonColors(
            containerColor = MaterialTheme.colorScheme.surfaceContainer.copy(alpha = 0.92f),
            contentColor = MaterialTheme.colorScheme.onSurface,
        ),
        interactionSource = interactionSource,
    ) {
        Icon(
            imageVector = icon,
            contentDescription = description,
            modifier = Modifier.size(20.dp),
        )
    }
}
```

**Update DashboardGrid.kt:**

1. Add tap-to-focus on each widget. In the per-widget gestureModifier or WidgetSlot, add a clickable handler for focus toggling:

Within the per-widget AnimatedVisibility block, wrap the Box (from 14-03) with a clickable modifier for focus:

```kotlin
// Focus tap handler: in edit mode, tap toggles focus
val isFocused = editState.focusedWidgetId == widget.instanceId
val focusClickModifier = if (isEditMode) {
    Modifier.clickable(
        indication = null,
        interactionSource = remember { MutableInteractionSource() },
        onClick = {
            if (isFocused) {
                editModeCoordinator.focusWidget(null) // Unfocus
            } else {
                editModeCoordinator.focusWidget(widget.instanceId) // Focus
            }
        },
    )
} else {
    Modifier
}
```

Apply this to the Box wrapping the WidgetSlot.

2. Add FocusOverlayToolbar rendering for the focused widget. After the main widget Layout, check if there's a focused widget and render the toolbar positioned above it:

```kotlin
// Focus overlay toolbar (F1.8) -- rendered at highest z-index
val focusedWidgetId = editState.focusedWidgetId
if (isEditMode && focusedWidgetId != null) {
    val focusedWidget = visibleWidgets.find { it.instanceId == focusedWidgetId }
    if (focusedWidget != null) {
        // Position toolbar above the focused widget
        // This needs to be rendered as part of the Layout content, at the end (highest z)
    }
}
```

The cleanest approach: add the FocusOverlayToolbar as an additional composable INSIDE the Layout content block, after all widget items. In the MeasurePolicy, position it above the focused widget. It gets the highest z-index since it's placed last.

Add to the Layout content block (after the `for` loop over widgets):
```kotlin
// Focus toolbar overlay (rendered after all widgets = highest z)
if (isEditMode && editState.focusedWidgetId != null) {
    val focusedWidget = visibleWidgets.find { it.instanceId == editState.focusedWidgetId }
    if (focusedWidget != null) {
        FocusOverlayToolbar(
            widgetId = focusedWidget.instanceId,
            onDelete = { onCommand(DashboardCommand.DeleteWidget(focusedWidget.instanceId)) },
            onSettings = { onCommand(DashboardCommand.OpenWidgetSettings(focusedWidget.instanceId)) },
        )
    }
}
```

In the MeasurePolicy, handle the extra placeable (it will be index == visibleWidgets.size if focused widget exists):
```kotlin
// If there's a focus toolbar, it's the last placeable -- position above focused widget
if (placeables.size > visibleWidgets.size) {
    val focusedWidget = visibleWidgets.find { it.instanceId == editState.focusedWidgetId }
    if (focusedWidget != null) {
        val toolbarPlaceable = placeables.last()
        val widgetX = (focusedWidget.position.col * gridUnitPx).roundToInt()
        val widgetY = (focusedWidget.position.row * gridUnitPx).roundToInt()
        // Center toolbar above widget, offset by toolbar height + 8dp gap
        val toolbarX = widgetX + ((focusedWidget.size.widthUnits * gridUnitPx).roundToInt() - toolbarPlaceable.width) / 2
        val toolbarY = widgetY - toolbarPlaceable.height - with(density) { 8.dp.roundToPx() }
        toolbarPlaceable.placeRelative(
            x = toolbarX.coerceAtLeast(0),
            y = toolbarY.coerceAtLeast(0),
            zIndex = Float.MAX_VALUE, // Above all widgets
        )
    }
}
```

Note: The `density` reference may not be available inside the MeasurePolicy lambda. The gap can be pre-computed: `val toolbarGapPx = with(density) { 8.dp.roundToPx() }` outside the Layout.

3. Add settingsAlpha for dimming non-focused widgets during settings peek. When `editState.focusedWidgetId` is set, non-focused widgets get alpha 0.5:

```kotlin
val settingsAlpha by animateFloatAsState(
    targetValue = if (editState.focusedWidgetId != null && editState.focusedWidgetId != widget.instanceId) 0.5f else 1f,
    animationSpec = tween(300),
    label = "settings_alpha_${widget.instanceId}",
)
```

Add to graphicsLayer:
```kotlin
.graphicsLayer {
    // ... existing properties ...
    alpha = settingsAlpha
}
```

Use `DashboardCommand.OpenWidgetSettings(widgetId)` (added by 14-04) for the settings button action. Do NOT add it here — it already exists.

Add imports: `import androidx.compose.foundation.clickable`, `import androidx.compose.foundation.interaction.MutableInteractionSource`, `import androidx.compose.animation.core.tween`.
  </action>
  <verify>
    <automated>cd android && ./gradlew :feature:dashboard:compileDebugKotlin --console=plain 2>&1 | tail -5</automated>
  </verify>
  <done>
    - FocusOverlayToolbar composable with delete/settings buttons and press-scale animation
    - Toolbar positioned above focused widget at highest z-index
    - Tap-to-focus/unfocus wired in DashboardGrid
    - settingsAlpha dims non-focused widgets
    - Compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Add focus overlay toolbar tests</name>
  <files>
    android/feature/dashboard/src/test/kotlin/app/dqxn/android/feature/dashboard/grid/FocusOverlayToolbarTest.kt
  </files>
  <action>
Create Compose UI tests for the focus overlay toolbar:

```kotlin
package app.dqxn.android.feature.dashboard.grid

import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.performClick
import com.google.common.truth.Truth.assertThat
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner
import org.robolectric.annotation.Config

@RunWith(RobolectricTestRunner::class)
@Config(sdk = [34])
class FocusOverlayToolbarTest {

    @get:Rule
    val composeTestRule = createComposeRule()

    @Test
    fun `toolbar renders with delete and settings buttons`() {
        composeTestRule.setContent {
            FocusOverlayToolbar(
                widgetId = "w1",
                onDelete = {},
                onSettings = {},
            )
        }

        composeTestRule.onNodeWithTag("focus_toolbar_w1").assertExists()
        composeTestRule.onNodeWithTag("focus_delete_w1", useUnmergedTree = true).assertExists()
        composeTestRule.onNodeWithTag("focus_settings_w1", useUnmergedTree = true).assertExists()
    }

    @Test
    fun `delete button fires onDelete callback`() {
        var deleted = false

        composeTestRule.setContent {
            FocusOverlayToolbar(
                widgetId = "w1",
                onDelete = { deleted = true },
                onSettings = {},
            )
        }

        composeTestRule.onNodeWithTag("focus_delete_w1", useUnmergedTree = true).performClick()
        assertThat(deleted).isTrue()
    }

    @Test
    fun `settings button fires onSettings callback`() {
        var settingsOpened = false

        composeTestRule.setContent {
            FocusOverlayToolbar(
                widgetId = "w1",
                onDelete = {},
                onSettings = { settingsOpened = true },
            )
        }

        composeTestRule.onNodeWithTag("focus_settings_w1", useUnmergedTree = true).performClick()
        assertThat(settingsOpened).isTrue()
    }
}
```

Also verify focus gating in EditModeCoordinator (this should already be covered by EditModeCoordinatorTest, but confirm):

```kotlin
@Test
fun `isInteractionAllowed returns false when widget is focused`() {
    // This is already tested in EditModeCoordinatorTest but verify the contract
}
```

Adapt test based on FocusOverlayToolbar visibility. If it's `internal`, the test file must be in the same package.
  </action>
  <verify>
    <automated>cd android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.FocusOverlayToolbarTest" --console=plain 2>&1 | tail -10</automated>
  </verify>
  <done>
    - All 3 toolbar tests pass
    - Delete callback verified
    - Settings callback verified
    - Toolbar renders with correct test tags
  </done>
</task>

</tasks>

<verification>
1. `cd android && ./gradlew :feature:dashboard:compileDebugKotlin --console=plain` -- compiles
2. `cd android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.FocusOverlayToolbarTest" --console=plain` -- all tests pass
3. `cd android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.EditModeCoordinatorTest" --console=plain` -- existing tests pass
4. `cd android && ./gradlew :feature:dashboard:testDebugUnitTest --tests "*.DashboardGridTest" --console=plain` -- existing tests pass
</verification>

<success_criteria>
- Focus overlay toolbar renders above focused widget in edit mode
- Delete and settings buttons with press-scale animation
- Tap-to-focus/unfocus in edit mode
- Non-focused widgets dimmed (settingsAlpha)
- Interactive actions gated in edit/focus mode
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-ui-visual-interactive-parity/14-07-SUMMARY.md`
</output>
