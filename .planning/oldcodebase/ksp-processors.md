# Old Codebase: KSP Processors

**Source:** `/Users/ohm/Workspace/dqxn.old/android/core/plugin-processor/` and `core/agentic-processor/`
**Migration Target:** `codegen/plugin` and `codegen/agentic` in new architecture

---

## 1. Plugin Processor (`core/plugin-processor`)

### Overview

A unified KSP processor with a hub-and-spoke design. One `SymbolProcessor` dispatches to seven specialized handlers. Single-pass execution (`invoked` flag prevents re-entry).

**Entry point:** `app.dqxn.plugin.PluginProcessor` via `app.dqxn.plugin.PluginProcessorProvider`
**Service registration:** `src/main/resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider`
**Build deps:** `ksp-api`, `kotlinpoet`, `kotlinpoet-ksp`, `kotlinx-serialization-json`
**JVM toolchain:** 21

### Handler Summary

| Handler | Annotation | Generates Code? | Purpose |
|---------|-----------|-----------------|---------|
| SettingsHandler | `@SettingsSchema` | Yes — extension properties | Type-safe settings accessors |
| ThemeHandler | `@ThemePackMarker` | Yes — theme definitions + refs | Theme objects from JSON files |
| EntitlementHandler | (none — reads JSON) | Yes — constants object | Entitlement ID constants |
| ResourceHandler | `@PackResourceMarker` | Yes — widget/provider ref lists | Pack manifest resource refs |
| ConstraintHandler | `@ValidConstraints` | No — validation only | Widget constraint validation |
| DataContractHandler | `@DataContract` / `@RequiresData` | No — validation only | Provider-widget data flow checks |
| SetupSchemaHandler | `@DashboardDataProvider` | No — validation only | setupSchema type validation |

---

### 1.1 SettingsHandler

**Source:** `core/plugin-processor/src/main/kotlin/app/dqxn/plugin/handlers/SettingsHandler.kt`

**Input Annotation:**
```kotlin
// Defined in core/plugin-api/src/main/java/app/dqxn/android/core/pluginapi/SettingsSchema.kt
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.SOURCE)
annotation class SettingsSchema
```
No parameters. Applied to `WidgetRenderer` classes that declare a `settingsSchema` property.

**Processing Logic:**

1. Find all classes annotated `@SettingsSchema`
2. For each class, look for a property named `settingsSchema`
3. **Read the source file as raw text** (not via KSP symbol resolution)
4. Parse the source with regex to extract setting definitions from `listOf(...)` calls
5. Recognized setting types: `BooleanSetting`, `EnumSetting`, `IntSetting`, `FloatSetting`, `StringSetting`, `TimezoneSetting`, `UriSetting`, `AppPickerSetting`
6. Extract `key` and `default` value from each
7. For `EnumSetting`, hard-codes known enum FQCNs (`SizeOption`, `TimezonePosition`, `InfoCardLayoutMode`, `DateLayoutOption`)

**Generated Output:**

File: `{package}.generated/{ClassName}Settings.kt`
Generates extension properties on `Map<String, Any?>` for each setting key.

Example generated code:
```kotlin
// Generated by PluginProcessor. Do not edit.
package app.dqxn.android.feature.packs.free.widgets.clock.generated

val Map<String, Any?>.showSeconds: Boolean
    get() = this["showSeconds"] as? Boolean ?: false

val Map<String, Any?>.size: SizeOption
    get() = (this["size"] as? String)?.let { name ->
        SizeOption.entries.find { it.name == name }
    } ?: SizeOption.MEDIUM

val Map<String, Any?>.showTimezone: Boolean
    get() = this["showTimezone"] as? Boolean ?: false

val Map<String, Any?>.opacity: Float
    get() = (this["opacity"] as? Number)?.toFloat() ?: 1.0f

val Map<String, Any?>.label: String
    get() = this["label"] as? String ?: ""
```

**Weaknesses (relevant to migration):**
- Source-file regex parsing is fragile — breaks on unusual formatting, multi-line expressions, or non-standard setting constructors
- Hard-coded enum type resolution (only 4 enum types known)
- Dependencies: `aggregating = false` — may miss incremental compilation scenarios

---

### 1.2 ThemeHandler

**Source:** `core/plugin-processor/src/main/kotlin/app/dqxn/plugin/handlers/ThemeHandler.kt`

**Input Annotation:**
```kotlin
// Defined in core/plugin-api/src/main/java/app/dqxn/android/core/pluginapi/ThemePackMarker.kt
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)  // Note: RUNTIME, not SOURCE
annotation class ThemePackMarker
```
No parameters. Applied to a class/object. Triggers JSON file scanning.

**KSP Options Required:**
- `themesDir`: Path to directory containing `.json` theme definition files

**Processing Logic:**

1. Find classes annotated `@ThemePackMarker`
2. Read `themesDir` KSP option → scan directory for `.json` files
3. Deserialize each JSON file into `ThemeSchemaData` (kotlinx.serialization)
4. Validate each theme:
   - `id` and `name` must be non-blank
   - `colors.primary` and `colors.accent` must be valid hex colors (`#RRGGBB` or `#RRGGBBAA`)
   - All gradient stop colors must be valid hex
5. Sort themes by a hard-coded ordering list (24 themes: 12 dark, 12 light)
6. Generate Kotlin file with theme definition objects

**Theme JSON Schema:**
```json
{
    "id": "cyberpunk",
    "name": "Cyberpunk",
    "isDark": true,
    "colors": {
        "primary": "#E0E0E0",
        "secondary": "#B0B0B0",
        "accent": "#00FFFF",
        "highlight": "#FF00FF",  // optional, defaults to accent
        "widgetBorder": "#00FFFF33"
    },
    "gradients": {
        "background": {
            "type": "VERTICAL",  // VERTICAL | HORIZONTAL | LINEAR | RADIAL
            "stops": ["#0A0A0A", "#1A0A2E"],
            "angle": null,       // optional
            "centerX": null,     // optional
            "centerY": null      // optional
        },
        "widgetBackground": {
            "type": "VERTICAL",
            "stops": ["#1A1A2E80", "#0D0D1A80"]
        }
    },
    "defaults": {
        "backgroundStyle": "SOLID",  // optional, default "SOLID"
        "glowEffect": false          // optional, default false
    },
    "requiredAnyEntitlement": ["premium"]  // optional
}
```

**Generated Output:**

File: `{package}.generated/GeneratedThemes.kt`

Contains:
1. One `DashboardThemeDefinition` property per theme (named by PascalCase of `id`)
2. An `allThemes: List<DashboardThemeDefinition>` property
3. A `generatedThemeRefs: List<PackThemeRef>` property for pack manifests

Example generated code (partial):
```kotlin
// Generated by PluginProcessor. Do not edit.
package app.dqxn.android.feature.packs.free.generated

val Cyberpunk = DashboardThemeDefinition(
    id = "cyberpunk",
    name = "Cyberpunk",
    backgroundBrush = Brush.verticalGradient(colors = listOf(Color(0xFF0A0A0A), Color(0xFF1A0A2E))),
    widgetBackgroundBrush = Brush.verticalGradient(colors = listOf(Color(0xFF1A1A2E80), Color(0xFF0D0D1A80))),
    widgetBorderColor = Color(0xFF00FFFF33),
    primaryTextColor = Color(0xFFE0E0E0),
    secondaryTextColor = Color(0xFFB0B0B0),
    accentColor = Color(0xFF00FFFF),
    highlightColor = Color(0xFFFF00FF),
    isDark = true,
    defaultBackgroundStyle = BackgroundStyle.SOLID,
    defaultHasGlowEffect = false,
    requiredAnyEntitlement = listOf("premium"),
    backgroundGradientSpec = GradientSpec(
        type = GradientType.VERTICAL,
        stops = listOf("#0A0A0A", "#1A0A2E")
    ),
    widgetBackgroundGradientSpec = GradientSpec(
        type = GradientType.VERTICAL,
        stops = listOf("#1A1A2E80", "#0D0D1A80")
    )
)

val allThemes = listOf(Cyberpunk, Tron, NeonPink, /* ... */)

val generatedThemeRefs = listOf(
    PackThemeRef(
        localId = "cyberpunk",
        displayName = "Cyberpunk",
        isDark = true,
        previewColors = listOf("#00FFFF", "#B0B0B0", "#1A0A2E")
    ),
    // ...
)
```

**Preview colors extraction:** `[accent, secondary, last background gradient stop (or widgetBorder)]`

**Weaknesses:**
- Hard-coded theme sort order (24-element list) — fragile if themes change
- Generates Compose `Brush` objects directly in generated code — couples processor to Compose API
- `GradientSpecData.angle/centerX/centerY` are parsed but never used in code generation

---

### 1.3 EntitlementHandler

**Source:** `core/plugin-processor/src/main/kotlin/app/dqxn/plugin/handlers/EntitlementHandler.kt`

**Input:** No annotation. Reads `entitlements.json` file via KSP option `entitlementsPath`.

**KSP Options Required:**
- `entitlementsPath`: Absolute path to `entitlements.json` file

**Processing Logic:**

1. Read `entitlementsPath` KSP option
2. If file doesn't exist, skip silently
3. Deserialize JSON into `EntitlementsSchema`
4. Generate constants object

**JSON Schema:**
```json
{
    "entitlements": [
        { "id": "free", "name": "Free", "default": true },
        { "id": "premium", "name": "Premium" }
    ]
}
```

**Generated Output:**

File: `app.dqxn.android.core.pluginapi/Entitlements.kt`

Note: generates into a **fixed package** (`app.dqxn.android.core.pluginapi`), not relative to the annotated class.

```kotlin
// Generated by PluginProcessor. Do not edit.
package app.dqxn.android.core.pluginapi

object Entitlements {
    /** Generated entitlement constants. Do not edit. */
    const val FREE: String = "free"
    const val PREMIUM: String = "premium"
    val all: List<String> = listOf(FREE, PREMIUM)
    const val DEFAULT: String = "free"
}
```

**ID transformation:** `id.uppercase().replace("-", "_")` → e.g., `"pro-plus"` becomes `PRO_PLUS`

**Dependencies:** `aggregating = true` (no source files tracked — reads external JSON)

---

### 1.4 ResourceHandler

**Source:** `core/plugin-processor/src/main/kotlin/app/dqxn/plugin/handlers/ResourceHandler.kt`

**Input Annotation:**
```kotlin
// Defined in core/plugin-api/src/main/java/app/dqxn/android/core/pluginapi/PackResourceMarker.kt
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.SOURCE)
annotation class PackResourceMarker
```
No parameters. Applied to an object (e.g., `FreePackResources`).

**Companion Annotations Scanned:**
```kotlin
// core/plugin-api/src/main/java/app/dqxn/android/core/pluginapi/DashboardAnnotations.kt

@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.SOURCE)
annotation class DashboardWidget(
    val localId: String,        // e.g., "compass"
    val displayName: String,    // e.g., "Compass"
    val icon: String = ""       // Material icon name, e.g., "explore"
)

@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.SOURCE)
annotation class DashboardDataProvider(
    val localId: String,        // e.g., "speed"
    val displayName: String,    // e.g., "Vehicle Speed"
    val description: String = ""
)
```

**Processing Logic:**

1. Find classes annotated `@PackResourceMarker`
2. Determine base package: `packageName.substringBeforeLast('.')`
3. Scan for all `@DashboardWidget`-annotated classes in that package tree
4. Scan for all `@DashboardDataProvider`-annotated classes in that package tree
5. Extract `localId`, `displayName`, `icon`/`description` from annotation arguments
6. For widgets with no `icon`, derive from `localId` via hard-coded mapping (e.g., `"compass"` → `"explore"`, `"clock*"` → `"schedule"`)
7. Generate resource refs file

**Generated Output:**

File: `{package}.generated/GeneratedResources.kt`

```kotlin
// Generated by PluginProcessor. Do not edit.
package app.dqxn.android.feature.packs.free.generated

import app.dqxn.android.core.pluginapi.PackWidgetRef
import app.dqxn.android.core.pluginapi.PackDataProviderRef

/** Auto-generated PackWidgetRef list from @DashboardWidget annotations. */
val generatedWidgetRefs: List<PackWidgetRef> = listOf(
    PackWidgetRef(
        localId = "compass",
        displayName = "Compass",
        icon = "explore"
    ),
    PackWidgetRef(
        localId = "clock-digital",
        displayName = "Digital Clock",
        icon = "schedule"
    )
)

/** Auto-generated PackDataProviderRef list from @DashboardDataProvider annotations. */
val generatedProviderRefs: List<PackDataProviderRef> = listOf(
    PackDataProviderRef(
        localId = "speed",
        displayName = "Vehicle Speed",
        description = "Current speed from OBU"
    )
)
```

**Weaknesses:**
- Icon derivation has hard-coded `localId` → icon mapping with only ~10 entries, fallback is `"widgets"`
- Package tree scan uses `startsWith(basePackage)` which could pick up unrelated modules if packages overlap

---

### 1.5 ConstraintHandler

**Source:** `core/plugin-processor/src/main/kotlin/app/dqxn/plugin/handlers/ConstraintHandler.kt`

**Input Annotation:**
```kotlin
// core/plugin-api/src/main/java/app/dqxn/android/core/pluginapi/ValidConstraints.kt
@Target(AnnotationTarget.CLASS, AnnotationTarget.PROPERTY)
@Retention(AnnotationRetention.SOURCE)
annotation class ValidConstraints
```

**Processing Logic:**

1. Find classes/properties annotated `@ValidConstraints`
2. For class-level: look for a `constraints` property
3. **Read source file as raw text** and regex-parse `WidgetConstraints(defaultWidthUnits=X, defaultHeightUnits=Y)`
4. Validate: `defaultWidthUnits >= 1`, `defaultHeightUnits >= 1`
5. Report errors via `logger.error()`

**Generated Output:** None. Validation only.

**Weaknesses:**
- Same fragile source-file regex approach as SettingsHandler
- Only validates two fields (`defaultWidthUnits`, `defaultHeightUnits`) — misses other constraint properties

---

### 1.6 DataContractHandler

**Source:** `core/plugin-processor/src/main/kotlin/app/dqxn/plugin/handlers/DataContractHandler.kt`

**Input Annotations:**
```kotlin
// core/plugin-api/src/main/java/app/dqxn/android/core/pluginapi/DataContract.kt

@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.SOURCE)
annotation class DataContract(
    val provides: Array<String> = [],
    val consumes: Array<String> = []
)

@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.SOURCE)
annotation class RequiresData(
    val types: Array<String>
)
```

**Processing Logic:**

1. Collect all `provides` strings from `@DataContract`-annotated classes
2. Collect all `types` strings from `@RequiresData`-annotated classes, tracking which class requires each type
3. Cross-reference: warn if a required type has no provider
4. Info log for orphaned provided types (provided but not consumed)

**Generated Output:** None. Validation only (warnings, not errors).

**Note:** Uses `logger.warn()` not `logger.error()` — missing providers are warnings, not compilation failures. This is a significant difference from the new architecture which mandates compile errors.

---

### 1.7 SetupSchemaHandler

**Source:** `core/plugin-processor/src/main/kotlin/app/dqxn/plugin/handlers/SetupSchemaHandler.kt`

**Input:** Processes classes already annotated `@DashboardDataProvider` (reuses the annotation from ResourceHandler).

**Processing Logic:**

1. Find all `@DashboardDataProvider`-annotated classes
2. Look for a `setupSchema` property
3. Validate that the property type is `List<SetupPageDefinition>` via KSP type resolution
4. If type is wrong, warn

**Generated Output:** None. Type validation only.

**Design note from code comments:** "KSP doesn't provide reliable access to list literal values, so detailed validation of permission strings and definition IDs is deferred to runtime."

---

## 2. Agentic Processor (`core/agentic-processor`)

### Overview

Contains two independent KSP processors registered via a single service file. Both are pure JVM, no Android dependencies.

**Service registration:** `src/main/resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider`
```
app.dqxn.android.core.agentic.processor.AgenticProcessorProvider
app.dqxn.android.core.agentic.processor.RouteListingProcessorProvider
```

**Build deps:** `ksp-api`, `kotlinpoet`, `kotlinpoet-ksp` (no kotlinx-serialization)

---

### 2.1 AgenticProcessor

**Source:** `core/agentic-processor/src/main/kotlin/app/dqxn/android/core/agentic/processor/AgenticProcessor.kt`

**Input Annotation:**
```kotlin
// Defined in core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/AgenticCommand.kt
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.SOURCE)
annotation class AgenticCommand(
    val name: String,           // Command name for dispatch, e.g., "navigate", "ping"
    val description: String,    // Human-readable description
    val category: String = ""   // Optional grouping, e.g., "navigation", "capture"
)
```

**Important:** The annotation parameters (`name`, `description`, `category`) are **not read by the processor**. The processor only uses them as a marker to find classes. The `CommandHandler` interface properties (`name`, `description`, `category`, `aliases`) are what the generated registry uses at runtime.

**Processing Logic:**

1. Find all classes annotated `app.dqxn.android.core.agentic.AgenticCommand`
2. For each annotated class, generate a private property that instantiates it via no-arg constructor: `private val fooHandler: CommandHandler = FooHandler()`
3. Generate an `init {}` block that calls `register(handler)` for each
4. Generate the full `GeneratedCommandRegistry` class

**Generated Output:**

File: `app.dqxn.android.core.agentic.generated/GeneratedCommandRegistry.kt`

```kotlin
package app.dqxn.android.core.agentic.generated

import app.dqxn.android.core.agentic.CommandRegistry
import app.dqxn.android.core.agentic.CommandHandler

class GeneratedCommandRegistry : CommandRegistry {
    private val handlers: MutableMap<String, CommandHandler> = mutableMapOf()
    private val aliasMap: MutableMap<String, CommandHandler> = mutableMapOf()

    private val pingHandler: CommandHandler = PingHandler()
    private val navigateHandler: CommandHandler = NavigateHandler()
    // ... one per @AgenticCommand class

    init {
        register(pingHandler)
        register(navigateHandler)
        // ... one per handler
    }

    override fun register(handler: CommandHandler) {
        handlers[handler.name] = handler
        handler.aliases.forEach { aliasMap[it] = handler }
    }

    override fun getHandler(name: String): CommandHandler? {
        return handlers[name]
    }

    override fun findHandler(nameOrAlias: String): CommandHandler? {
        return handlers[nameOrAlias] ?: aliasMap[nameOrAlias]
    }

    override fun getAllHandlers(): List<CommandHandler> {
        return handlers.values.toList()
    }
}
```

**Target interfaces (from `core/agentic`):**

```kotlin
// CommandRegistry interface
interface CommandRegistry {
    fun register(handler: CommandHandler)
    fun getHandler(name: String): CommandHandler?
    fun findHandler(nameOrAlias: String): CommandHandler?
    fun getAllHandlers(): List<CommandHandler>
}

// CommandHandler interface
interface CommandHandler {
    val name: String
    val description: String
    val category: String
    val aliases: List<String>  // default = emptyList()
    suspend fun execute(params: JsonObject, commandId: String): CommandResult
    fun paramsSchema(): JsonObject
}
```

**Registration Mechanism:**
- No Hilt integration — the generated class directly instantiates handlers via no-arg constructors
- Assumes all `@AgenticCommand` classes have no-arg constructors (no `@Inject`)
- The consumer (presumably `:app` or `:core:agentic`) creates `GeneratedCommandRegistry()` directly

**Weaknesses:**
- No-arg constructor assumption — breaks if handlers need injected dependencies
- `register()` doesn't throw on duplicates (unlike `DefaultCommandRegistry` which uses `require()`)
- Annotation parameters (`name`, `description`, `category`) are completely unused — metadata comes from the `CommandHandler` interface at runtime, making the annotation redundant except as a marker
- `aggregating = true` dependencies — correct for multi-file scanning

---

### 2.2 RouteListingProcessor

**Source:** `core/agentic-processor/src/main/kotlin/app/dqxn/android/core/agentic/processor/RouteListingProcessor.kt`

**Input:** Not annotation-driven. Finds a sealed interface named `Route` by fully-qualified name.

**Companion Annotation (optional per-route):**
```kotlin
// Defined in core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/RouteDescription.kt
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.SOURCE)
annotation class RouteDescription(val value: String)
```
Format convention: `"Purpose: X. Shows: Y. Actions: Z."`

**KSP Options Required:**
- `routePackage`: Package containing the `Route` sealed interface (e.g., `app.dqxn.android.feature.dashboard.nav`)

**Processing Logic:**

1. Read `routePackage` KSP option
2. Resolve `{routePackage}.Route` as a sealed interface
3. Get all sealed subclasses
4. For each subclass, extract:
   - **name**: Simple class name (e.g., `WidgetSettings`)
   - **path**: CamelCase → kebab-case conversion (e.g., `widget-settings`). For data classes with params, appends `/{paramName}` placeholders
   - **params**: From primary constructor — tracks name, Kotlin type, required/nullable, and generates example values via heuristic mapping
   - **description**: From `@RouteDescription` annotation if present, otherwise generated from class name patterns (Settings, Selector, Picker, Editor, Confirmation, Dashboard, Empty)
   - **deepLink**: Only for a hard-coded set of "sheet routes" → `https://dqxn.app/open/sheets/{path}`

**CamelCase to kebab-case:** `"WidgetSettings"` → `"widget-settings"` (regex: `([a-z])([A-Z])` → `$1-$2` then lowercase)

**Parameter example generation heuristics:**
| paramName pattern | Example value |
|---|---|
| `*widgetId*` | `"speed-abc12345"` |
| `*themeId*` | `"dark-ocean"` |
| `*presetId*` | `"minimal-speed"` |
| `*packageName*` / `*Package*` | `"com.example.app"` |
| `*settingKey*` | `"displayFormat"` |
| `*currentValue*` | `"default"` |
| `*Id*` | `"item-12345"` |
| String type | `"example-value"` |
| Int/Long type | `"0"` |
| Boolean type | `"true"` |
| Float/Double type | `"0.0"` |

**Deep link route set (hard-coded):**
`WidgetSettings`, `ThemeSelector`, `ThemeModeSelector`, `WidgetPicker`, `PackBrowser`, `ThemeEditor`, `TimezoneSelector`, `DateFormatSelector`, `AppSelector`, plus anything containing `"Selector"`.

**Generated Output:**

File: `{routePackage}/GeneratedRouteRegistry.kt`

```kotlin
package app.dqxn.android.feature.dashboard.nav

import app.dqxn.android.core.agentic.RouteInfo
import app.dqxn.android.core.agentic.ParamInfo
import app.dqxn.android.core.agentic.RouteRegistry

object GeneratedRouteRegistry : RouteRegistry {
    override fun getAllRoutes(): List<RouteInfo> = listOf(
        RouteInfo(
            name = "WidgetSettings",
            path = "widget-settings/{widgetId}",
            params = listOf(
                ParamInfo(
                    name = "widgetId",
                    type = "String",
                    required = true,
                    nullable = false,
                    example = "speed-abc12345"
                )
            ),
            description = "Purpose: Configure widget. Shows: Settings sheet. Actions: Update settings.",
            deepLink = "https://dqxn.app/open/sheets/widget-settings/{widgetId}"
        ),
        RouteInfo(
            name = "Dashboard",
            path = "dashboard",
            params = emptyList(),
            description = "Purpose: Main dashboard. Shows: Widget grid. Actions: View, edit widgets.",
            deepLink = null
        ),
        // ...
    )
}
```

**Target types (from `core/agentic`):**
```kotlin
@Serializable
data class RouteInfo(
    val name: String,
    val path: String,
    val params: List<ParamInfo>,
    val description: String,
    val deepLink: String? = null
)

@Serializable
data class ParamInfo(
    val name: String,
    val type: String,
    val required: Boolean,
    val nullable: Boolean,
    val example: String? = null
)

interface RouteRegistry {
    fun getAllRoutes(): List<RouteInfo>
}
```

**Weaknesses:**
- Hard-coded deep link route set and URL pattern
- Default description generation is pattern-matched on class name substrings — brittle
- No validation that Route subclasses are actually navigable

---

## 3. Migration Mapping

### `core/plugin-processor` → `codegen/plugin`

| Old Handler | New Equivalent | Changes Needed |
|---|---|---|
| **SettingsHandler** | Keep, but fix regex parsing | Replace source-file regex with proper KSP symbol resolution or annotation-driven schema. Enum type resolution needs to be dynamic, not hard-coded. |
| **ThemeHandler** | Keep JSON-to-code generation | Remove hard-coded sort order. Decouple from Compose `Brush` API if possible (or accept the dependency). Move theme JSON schema validation to a shared schema definition. |
| **EntitlementHandler** | Evaluate whether still needed | New architecture may handle entitlements differently. If kept, should generate into `:sdk:contracts` package, not `core.pluginapi`. |
| **ResourceHandler** | **Replace** with `PackManifest` generation | New arch uses `@DashboardWidget(typeId = "{packId}:{widget-name}")` format. Generates `PackManifest` implementations + Hilt multibinding modules instead of ref lists. Icon derivation should be annotation-driven, not hard-coded fallback. |
| **ConstraintHandler** | Merge into widget validation | Constraint validation should use KSP type resolution, not source regex. Can be part of `@DashboardWidget` processing. |
| **DataContractHandler** | **Replace** with `@DashboardSnapshot` validation | New architecture uses typed `DataSnapshot` subtypes validated by `@DashboardSnapshot`. Errors should be `logger.error()` (compile failure), not `logger.warn()`. |
| **SetupSchemaHandler** | Keep or defer to runtime | Minimal value as-is. Could be expanded or removed in favor of pure runtime validation. |

**New responsibilities not in old processor:**
- `@DashboardSnapshot` validation: no duplicate `dataType` strings across modules, `@Immutable` required, only `val` properties, implements `DataSnapshot`
- Hilt `@Module` generation with `@Binds @IntoSet` for `WidgetRenderer` and `DataProvider`
- Compose stability config file generation (list of all `@DashboardSnapshot` types wired into Compose compiler)
- `typeId` format validation: must match `{packId}:{widget-name}` pattern

### `core/agentic-processor` → `codegen/agentic`

| Old Processor | New Equivalent | Changes Needed |
|---|---|---|
| **AgenticProcessor** | Expand significantly | Old generates simple registry with no-arg constructor instantiation. New needs: Hilt-compatible wiring (not direct instantiation), param validation codegen from annotation schema, `list-commands` schema output generation, compile error on missing handler implementation. |
| **RouteListingProcessor** | Keep and improve | Remove hard-coded deep link set and description patterns. Consider annotation-driven deep link declaration. Parameter example generation could move to annotations. |

**Critical differences between old and new:**

1. **DI integration**: Old agentic processor creates handler instances directly (`FooHandler()`). New architecture uses Hilt — generated code must produce `@Module` + `@Binds @IntoSet` or similar DI wiring, not direct construction.

2. **Annotation semantics**: Old `@AgenticCommand` parameters are decorative (never read by processor). New processor should read and use them for schema generation (`list-commands` output).

3. **Error severity**: Old DataContractHandler uses `warn` for missing providers. New architecture mandates compile errors (`logger.error()`).

4. **Package structure**: Old processor lives in `app.dqxn.plugin` (flat, no `android` segment). New should follow `app.dqxn.android.codegen.plugin` namespace.

5. **`@DashboardWidget` shape change**: Old uses `localId` + `displayName` + `icon`. New uses `typeId` (format: `{packId}:{widget-name}`) which replaces `localId` with a qualified identifier.

6. **No `@PackResourceMarker` needed**: In new arch, `PackManifest` generation is driven directly by `@DashboardWidget`/`@DashboardDataProvider` annotations — no separate marker object needed.

7. **Snapshot modules**: Entirely new concept. `@DashboardSnapshot` processing and Compose stability config generation have no old-codebase precedent.

---

## 4. File Inventory

### `core/plugin-processor/`

```
build.gradle.kts
src/main/kotlin/app/dqxn/plugin/
├── PluginProcessor.kt               # Hub processor — delegates to handlers
├── PluginProcessorProvider.kt        # KSP service provider
└── handlers/
    ├── ConstraintHandler.kt          # @ValidConstraints → compile-time validation
    ├── DataContractHandler.kt        # @DataContract/@RequiresData → flow validation
    ├── EntitlementHandler.kt         # entitlements.json → Entitlements object
    ├── ResourceHandler.kt            # @PackResourceMarker → widget/provider refs
    ├── SettingsHandler.kt            # @SettingsSchema → typed accessors
    ├── SetupSchemaHandler.kt         # @DashboardDataProvider → setupSchema validation
    └── ThemeHandler.kt               # @ThemePackMarker → theme definitions from JSON
src/main/resources/META-INF/services/
    com.google.devtools.ksp.processing.SymbolProcessorProvider
```

### `core/agentic-processor/`

```
build.gradle.kts
src/main/kotlin/app/dqxn/android/core/agentic/processor/
├── AgenticProcessor.kt              # @AgenticCommand → GeneratedCommandRegistry
├── AgenticProcessorProvider.kt      # KSP service provider
├── RouteListingProcessor.kt         # Route sealed interface → GeneratedRouteRegistry
└── RouteListingProcessorProvider.kt # KSP service provider
src/main/resources/META-INF/services/
    com.google.devtools.ksp.processing.SymbolProcessorProvider
```

### Annotation Sources (in other modules)

```
core/plugin-api/src/main/java/app/dqxn/android/core/pluginapi/
├── DashboardAnnotations.kt          # @DashboardWidget, @DashboardDataProvider
├── SettingsSchema.kt                # @SettingsSchema
├── ThemePackMarker.kt               # @ThemePackMarker
├── PackResourceMarker.kt            # @PackResourceMarker
├── ValidConstraints.kt              # @ValidConstraints
└── DataContract.kt                  # @DataContract, @RequiresData

core/agentic/src/main/kotlin/app/dqxn/android/core/agentic/
├── AgenticCommand.kt                # @AgenticCommand
├── RouteDescription.kt              # @RouteDescription
├── CommandRegistry.kt               # CommandRegistry interface + DefaultCommandRegistry
├── CommandHandler.kt                # CommandHandler interface
├── RouteRegistry.kt                 # RouteRegistry interface
└── RouteInfo.kt                     # RouteInfo + ParamInfo data classes
```
